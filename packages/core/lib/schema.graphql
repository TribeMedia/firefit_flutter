type Agent implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  name: String!
  shortDescription: String
  longDescriptionMarkdown: String
  metadata: JSON
  applicationAgentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationAgentFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationAgentOrderBy!]
  ): ApplicationAgentConnection
  agentToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AgentToolFilter
    # Sort order to apply to the collection
    orderBy: [AgentToolOrderBy!]
  ): AgentToolConnection
}

type AgentConnection {
  edges: [AgentEdge!]!
  pageInfo: PageInfo!
}

type AgentDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Agent!]!
}

type AgentEdge {
  cursor: String!
  node: Agent!
}

input AgentFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AgentFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AgentFilter!]
  # Negates a filter
  not: AgentFilter
}

input AgentInsertInput {
  id: UUID
  createdAt: Datetime
  name: String
  shortDescription: String
  longDescriptionMarkdown: String
  metadata: JSON
}

type AgentInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Agent!]!
}

input AgentOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
}

type AgentTool implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  agentId: UUID!
  toolId: UUID!
  tool: Tool!
  agent: Agent!
}

type AgentToolConnection {
  edges: [AgentToolEdge!]!
  pageInfo: PageInfo!
}

type AgentToolDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AgentTool!]!
}

type AgentToolEdge {
  cursor: String!
  node: AgentTool!
}

input AgentToolFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  agentId: UUIDFilter
  toolId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AgentToolFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AgentToolFilter!]
  # Negates a filter
  not: AgentToolFilter
}

input AgentToolInsertInput {
  id: UUID
  createdAt: Datetime
  agentId: UUID
  toolId: UUID
}

type AgentToolInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AgentTool!]!
}

input AgentToolOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  agentId: OrderByDirection
  toolId: OrderByDirection
}

input AgentToolUpdateInput {
  id: UUID
  createdAt: Datetime
  agentId: UUID
  toolId: UUID
}

type AgentToolUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AgentTool!]!
}

input AgentUpdateInput {
  id: UUID
  createdAt: Datetime
  name: String
  shortDescription: String
  longDescriptionMarkdown: String
  metadata: JSON
}

type AgentUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Agent!]!
}

type AiConfig implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  aiConfigTypeId: UUID!
  baseUrl: String!
  apiKey: String!
  data: JSON
  createdAt: Datetime!
  updatedAt: Datetime
  name: String!
  key: String!
  applicationId: UUID!
  application: Application!
  aiConfigType: AiConfigType!
}

type AiConfigConnection {
  edges: [AiConfigEdge!]!
  pageInfo: PageInfo!
}

type AiConfigDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfig!]!
}

type AiConfigEdge {
  cursor: String!
  node: AiConfig!
}

input AiConfigFilter {
  id: UUIDFilter
  aiConfigTypeId: UUIDFilter
  baseUrl: StringFilter
  apiKey: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  name: StringFilter
  key: StringFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AiConfigFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AiConfigFilter!]
  # Negates a filter
  not: AiConfigFilter
}

input AiConfigInsertInput {
  id: UUID
  aiConfigTypeId: UUID
  baseUrl: String
  apiKey: String
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
  name: String
  key: String
  applicationId: UUID
}

type AiConfigInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfig!]!
}

input AiConfigOrderBy {
  id: OrderByDirection
  aiConfigTypeId: OrderByDirection
  baseUrl: OrderByDirection
  apiKey: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  applicationId: OrderByDirection
}

type AiConfigType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  aiConfigCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AiConfigFilter
    # Sort order to apply to the collection
    orderBy: [AiConfigOrderBy!]
  ): AiConfigConnection
}

type AiConfigTypeConnection {
  edges: [AiConfigTypeEdge!]!
  pageInfo: PageInfo!
}

type AiConfigTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfigType!]!
}

type AiConfigTypeEdge {
  cursor: String!
  node: AiConfigType!
}

input AiConfigTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AiConfigTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AiConfigTypeFilter!]
  # Negates a filter
  not: AiConfigTypeFilter
}

input AiConfigTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type AiConfigTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfigType!]!
}

input AiConfigTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input AiConfigTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type AiConfigTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfigType!]!
}

input AiConfigUpdateInput {
  id: UUID
  aiConfigTypeId: UUID
  baseUrl: String
  apiKey: String
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
  name: String
  key: String
  applicationId: UUID
}

type AiConfigUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AiConfig!]!
}

type AnswerChoice implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  questionId: UUID!
  index: Int
  choiceText: String
  metadata: JSON
  createdAt: Datetime!
  question: Question!
  questionAnwserChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionAnwserChoiceFilter
    # Sort order to apply to the collection
    orderBy: [QuestionAnwserChoiceOrderBy!]
  ): QuestionAnwserChoiceConnection
  userFormQuestionAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormQuestionAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserFormQuestionAnswerOrderBy!]
  ): UserFormQuestionAnswerConnection
  userSurveyAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyAnswerOrderBy!]
  ): UserSurveyAnswerConnection
}

type AnswerChoiceConnection {
  edges: [AnswerChoiceEdge!]!
  pageInfo: PageInfo!
}

type AnswerChoiceDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AnswerChoice!]!
}

type AnswerChoiceEdge {
  cursor: String!
  node: AnswerChoice!
}

input AnswerChoiceFilter {
  id: UUIDFilter
  questionId: UUIDFilter
  index: IntFilter
  choiceText: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AnswerChoiceFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AnswerChoiceFilter!]
  # Negates a filter
  not: AnswerChoiceFilter
}

input AnswerChoiceInsertInput {
  id: UUID
  questionId: UUID
  index: Int
  choiceText: String
  metadata: JSON
  createdAt: Datetime
}

type AnswerChoiceInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AnswerChoice!]!
}

input AnswerChoiceOrderBy {
  id: OrderByDirection
  questionId: OrderByDirection
  index: OrderByDirection
  choiceText: OrderByDirection
  createdAt: OrderByDirection
}

input AnswerChoiceUpdateInput {
  id: UUID
  questionId: UUID
  index: Int
  choiceText: String
  metadata: JSON
  createdAt: Datetime
}

type AnswerChoiceUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AnswerChoice!]!
}

type ApiType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  schema: JSON
  createdAt: Datetime!
}

type ApiTypeConnection {
  edges: [ApiTypeEdge!]!
  pageInfo: PageInfo!
}

type ApiTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApiType!]!
}

type ApiTypeEdge {
  cursor: String!
  node: ApiType!
}

input ApiTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApiTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApiTypeFilter!]
  # Negates a filter
  not: ApiTypeFilter
}

input ApiTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
}

type ApiTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApiType!]!
}

input ApiTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
}

input ApiTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
}

type ApiTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApiType!]!
}

type Application implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  ownerId: UUID
  name: String!
  shortDescription: String
  longDescriptionMarkdown: String
  applicationTypeId: UUID!
  createdAt: Datetime!
  iconUrl: String
  coverUrl: String
  owner: User
  applicationType: ApplicationType!
  applicationAgentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationAgentFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationAgentOrderBy!]
  ): ApplicationAgentConnection
  applicationToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationToolFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationToolOrderBy!]
  ): ApplicationToolConnection
  applicationTableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationTableFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationTableOrderBy!]
  ): ApplicationTableConnection
  aiConfigCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AiConfigFilter
    # Sort order to apply to the collection
    orderBy: [AiConfigOrderBy!]
  ): AiConfigConnection
  chatSessionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatSessionFilter
    # Sort order to apply to the collection
    orderBy: [ChatSessionOrderBy!]
  ): ChatSessionConnection
  contentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateOrderBy!]
  ): ContentTemplateConnection
  assetTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetTypeFilter
    # Sort order to apply to the collection
    orderBy: [AssetTypeOrderBy!]
  ): AssetTypeConnection
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
  applicationUserCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserOrderBy!]
  ): ApplicationUserConnection
  notificationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: NotificationFilter
    # Sort order to apply to the collection
    orderBy: [NotificationOrderBy!]
  ): NotificationConnection
  documentTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentTypeFilter
    # Sort order to apply to the collection
    orderBy: [DocumentTypeOrderBy!]
  ): DocumentTypeConnection
  contentTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTypeFilter
    # Sort order to apply to the collection
    orderBy: [ContentTypeOrderBy!]
  ): ContentTypeConnection
  applicationUserRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserRoleFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserRoleOrderBy!]
  ): ApplicationUserRoleConnection
  documentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentFilter
    # Sort order to apply to the collection
    orderBy: [DocumentOrderBy!]
  ): DocumentConnection
  onboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingOrderBy!]
  ): OnboardingConnection
  personaCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PersonaFilter
    # Sort order to apply to the collection
    orderBy: [PersonaOrderBy!]
  ): PersonaConnection
}

type ApplicationAgent implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  applicationId: UUID!
  agentId: UUID!
  application: Application!
  agent: Agent!
}

type ApplicationAgentConnection {
  edges: [ApplicationAgentEdge!]!
  pageInfo: PageInfo!
}

type ApplicationAgentDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationAgent!]!
}

type ApplicationAgentEdge {
  cursor: String!
  node: ApplicationAgent!
}

input ApplicationAgentFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  agentId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationAgentFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationAgentFilter!]
  # Negates a filter
  not: ApplicationAgentFilter
}

input ApplicationAgentInsertInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  agentId: UUID
}

type ApplicationAgentInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationAgent!]!
}

input ApplicationAgentOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  agentId: OrderByDirection
}

input ApplicationAgentUpdateInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  agentId: UUID
}

type ApplicationAgentUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationAgent!]!
}

type ApplicationConnection {
  edges: [ApplicationEdge!]!
  pageInfo: PageInfo!
}

type ApplicationDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Application!]!
}

type ApplicationEdge {
  cursor: String!
  node: Application!
}

input ApplicationFilter {
  id: UUIDFilter
  ownerId: UUIDFilter
  name: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  applicationTypeId: UUIDFilter
  createdAt: DatetimeFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationFilter!]
  # Negates a filter
  not: ApplicationFilter
}

input ApplicationInsertInput {
  id: UUID
  ownerId: UUID
  name: String
  shortDescription: String
  longDescriptionMarkdown: String
  applicationTypeId: UUID
  createdAt: Datetime
  iconUrl: String
  coverUrl: String
}

type ApplicationInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Application!]!
}

input ApplicationOrderBy {
  id: OrderByDirection
  ownerId: OrderByDirection
  name: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  applicationTypeId: OrderByDirection
  createdAt: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
}

type ApplicationTable implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  applicationId: UUID
  tableName: String!
  schemaName: String!
  application: Application
}

type ApplicationTableConnection {
  edges: [ApplicationTableEdge!]!
  pageInfo: PageInfo!
}

type ApplicationTableDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTable!]!
}

type ApplicationTableEdge {
  cursor: String!
  node: ApplicationTable!
}

input ApplicationTableFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  tableName: StringFilter
  schemaName: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationTableFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationTableFilter!]
  # Negates a filter
  not: ApplicationTableFilter
}

input ApplicationTableInsertInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  tableName: String
  schemaName: String
}

type ApplicationTableInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTable!]!
}

input ApplicationTableOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  tableName: OrderByDirection
  schemaName: OrderByDirection
}

input ApplicationTableUpdateInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  tableName: String
  schemaName: String
}

type ApplicationTableUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTable!]!
}

type ApplicationTool implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  applicationId: UUID!
  toolId: UUID!
  tool: Tool!
  application: Application!
}

type ApplicationToolConnection {
  edges: [ApplicationToolEdge!]!
  pageInfo: PageInfo!
}

type ApplicationToolDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTool!]!
}

type ApplicationToolEdge {
  cursor: String!
  node: ApplicationTool!
}

input ApplicationToolFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  toolId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationToolFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationToolFilter!]
  # Negates a filter
  not: ApplicationToolFilter
}

input ApplicationToolInsertInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  toolId: UUID
}

type ApplicationToolInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTool!]!
}

input ApplicationToolOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  toolId: OrderByDirection
}

input ApplicationToolUpdateInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  toolId: UUID
}

type ApplicationToolUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationTool!]!
}

type ApplicationType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  key: String!
  name: String!
  schema: JSON
  createdAt: Datetime!
  applicationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationOrderBy!]
  ): ApplicationConnection
}

type ApplicationTypeConnection {
  edges: [ApplicationTypeEdge!]!
  pageInfo: PageInfo!
}

type ApplicationTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationType!]!
}

type ApplicationTypeEdge {
  cursor: String!
  node: ApplicationType!
}

input ApplicationTypeFilter {
  id: UUIDFilter
  key: StringFilter
  name: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationTypeFilter!]
  # Negates a filter
  not: ApplicationTypeFilter
}

input ApplicationTypeInsertInput {
  id: UUID
  key: String
  name: String
  schema: JSON
  createdAt: Datetime
}

type ApplicationTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationType!]!
}

input ApplicationTypeOrderBy {
  id: OrderByDirection
  key: OrderByDirection
  name: OrderByDirection
  createdAt: OrderByDirection
}

input ApplicationTypeUpdateInput {
  id: UUID
  key: String
  name: String
  schema: JSON
  createdAt: Datetime
}

type ApplicationTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationType!]!
}

input ApplicationUpdateInput {
  id: UUID
  ownerId: UUID
  name: String
  shortDescription: String
  longDescriptionMarkdown: String
  applicationTypeId: UUID
  createdAt: Datetime
  iconUrl: String
  coverUrl: String
}

type ApplicationUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Application!]!
}

type ApplicationUser implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  applicationId: UUID!
  userId: UUID!
  user: User
  application: Application!
}

type ApplicationUserConnection {
  edges: [ApplicationUserEdge!]!
  pageInfo: PageInfo!
}

type ApplicationUserDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUser!]!
}

type ApplicationUserEdge {
  cursor: String!
  node: ApplicationUser!
}

input ApplicationUserFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  userId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationUserFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationUserFilter!]
  # Negates a filter
  not: ApplicationUserFilter
}

input ApplicationUserInsertInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  userId: UUID
}

type ApplicationUserInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUser!]!
}

input ApplicationUserOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  userId: OrderByDirection
}

type ApplicationUserRole implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  applicationId: UUID!
  userId: UUID!
  roleId: UUID!
  user: User
  role: Role!
  application: Application!
}

type ApplicationUserRoleConnection {
  edges: [ApplicationUserRoleEdge!]!
  pageInfo: PageInfo!
}

type ApplicationUserRoleDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUserRole!]!
}

type ApplicationUserRoleEdge {
  cursor: String!
  node: ApplicationUserRole!
}

input ApplicationUserRoleFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  userId: UUIDFilter
  roleId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ApplicationUserRoleFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ApplicationUserRoleFilter!]
  # Negates a filter
  not: ApplicationUserRoleFilter
}

input ApplicationUserRoleInsertInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  userId: UUID
  roleId: UUID
}

type ApplicationUserRoleInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUserRole!]!
}

input ApplicationUserRoleOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  userId: OrderByDirection
  roleId: OrderByDirection
}

input ApplicationUserRoleUpdateInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  userId: UUID
  roleId: UUID
}

type ApplicationUserRoleUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUserRole!]!
}

input ApplicationUserUpdateInput {
  id: UUID
  createdAt: Datetime
  applicationId: UUID
  userId: UUID
}

type ApplicationUserUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ApplicationUser!]!
}

type Asset implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  fileName: String!
  description: String
  fileSize: Float
  data: JSON
  hash: String
  url: String
  createdAt: Datetime!
  updatedAt: Datetime
  mimeTypeId: UUID!
  assetTypeId: UUID!
  ownerId: UUID
  isApproved: Boolean!
  isPublished: Boolean!
  approvedAt: Datetime
  publishedAt: Datetime
  publicationUrl: String
  coverUrl: String
  isArchived: Boolean!
  archivedAt: Datetime
  statusId: UUID
  promptId: UUID
  creationTypeId: UUID
  applicationId: UUID!
  status: AssetStatus
  prompt: Prompt
  owner: User
  mimeType: MimeType!
  creationType: CreationType
  assetType: AssetType!
  application: Application!
}

type AssetConnection {
  edges: [AssetEdge!]!
  pageInfo: PageInfo!
}

type AssetDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Asset!]!
}

type AssetEdge {
  cursor: String!
  node: Asset!
}

input AssetFilter {
  id: UUIDFilter
  name: StringFilter
  fileName: StringFilter
  description: StringFilter
  fileSize: FloatFilter
  hash: StringFilter
  url: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  mimeTypeId: UUIDFilter
  assetTypeId: UUIDFilter
  ownerId: UUIDFilter
  isApproved: BooleanFilter
  isPublished: BooleanFilter
  approvedAt: DatetimeFilter
  publishedAt: DatetimeFilter
  publicationUrl: StringFilter
  coverUrl: StringFilter
  isArchived: BooleanFilter
  archivedAt: DatetimeFilter
  statusId: UUIDFilter
  promptId: UUIDFilter
  creationTypeId: UUIDFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AssetFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AssetFilter!]
  # Negates a filter
  not: AssetFilter
}

input AssetInsertInput {
  id: UUID
  name: String
  fileName: String
  description: String
  fileSize: Float
  data: JSON
  hash: String
  url: String
  createdAt: Datetime
  updatedAt: Datetime
  mimeTypeId: UUID
  assetTypeId: UUID
  ownerId: UUID
  isApproved: Boolean
  isPublished: Boolean
  approvedAt: Datetime
  publishedAt: Datetime
  publicationUrl: String
  coverUrl: String
  isArchived: Boolean
  archivedAt: Datetime
  statusId: UUID
  promptId: UUID
  creationTypeId: UUID
  applicationId: UUID
}

type AssetInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Asset!]!
}

input AssetOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  fileName: OrderByDirection
  description: OrderByDirection
  fileSize: OrderByDirection
  hash: OrderByDirection
  url: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  mimeTypeId: OrderByDirection
  assetTypeId: OrderByDirection
  ownerId: OrderByDirection
  isApproved: OrderByDirection
  isPublished: OrderByDirection
  approvedAt: OrderByDirection
  publishedAt: OrderByDirection
  publicationUrl: OrderByDirection
  coverUrl: OrderByDirection
  isArchived: OrderByDirection
  archivedAt: OrderByDirection
  statusId: OrderByDirection
  promptId: OrderByDirection
  creationTypeId: OrderByDirection
  applicationId: OrderByDirection
}

type AssetStatus implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  createdAt: Datetime!
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
}

type AssetStatusConnection {
  edges: [AssetStatusEdge!]!
  pageInfo: PageInfo!
}

type AssetStatusDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetStatus!]!
}

type AssetStatusEdge {
  cursor: String!
  node: AssetStatus!
}

input AssetStatusFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AssetStatusFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AssetStatusFilter!]
  # Negates a filter
  not: AssetStatusFilter
}

input AssetStatusInsertInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type AssetStatusInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetStatus!]!
}

input AssetStatusOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input AssetStatusUpdateInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type AssetStatusUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetStatus!]!
}

type AssetType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  schema: JSON
  createdAt: Datetime!
  applicationId: UUID
  application: Application
  assetTypeMimeTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetTypeMimeTypeFilter
    # Sort order to apply to the collection
    orderBy: [AssetTypeMimeTypeOrderBy!]
  ): AssetTypeMimeTypeConnection
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
}

type AssetTypeConnection {
  edges: [AssetTypeEdge!]!
  pageInfo: PageInfo!
}

type AssetTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetType!]!
}

type AssetTypeEdge {
  cursor: String!
  node: AssetType!
}

input AssetTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AssetTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AssetTypeFilter!]
  # Negates a filter
  not: AssetTypeFilter
}

input AssetTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  applicationId: UUID
}

type AssetTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetType!]!
}

type AssetTypeMimeType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  assetTypeId: UUID!
  mimeTypeId: UUID
  createdAt: Datetime!
  mimeType: MimeType
  assetType: AssetType!
}

type AssetTypeMimeTypeConnection {
  edges: [AssetTypeMimeTypeEdge!]!
  pageInfo: PageInfo!
}

type AssetTypeMimeTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetTypeMimeType!]!
}

type AssetTypeMimeTypeEdge {
  cursor: String!
  node: AssetTypeMimeType!
}

input AssetTypeMimeTypeFilter {
  id: UUIDFilter
  assetTypeId: UUIDFilter
  mimeTypeId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [AssetTypeMimeTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [AssetTypeMimeTypeFilter!]
  # Negates a filter
  not: AssetTypeMimeTypeFilter
}

input AssetTypeMimeTypeInsertInput {
  id: UUID
  assetTypeId: UUID
  mimeTypeId: UUID
  createdAt: Datetime
}

type AssetTypeMimeTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetTypeMimeType!]!
}

input AssetTypeMimeTypeOrderBy {
  id: OrderByDirection
  assetTypeId: OrderByDirection
  mimeTypeId: OrderByDirection
  createdAt: OrderByDirection
}

input AssetTypeMimeTypeUpdateInput {
  id: UUID
  assetTypeId: UUID
  mimeTypeId: UUID
  createdAt: Datetime
}

type AssetTypeMimeTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetTypeMimeType!]!
}

input AssetTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
}

input AssetTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  applicationId: UUID
}

type AssetTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [AssetType!]!
}

input AssetUpdateInput {
  id: UUID
  name: String
  fileName: String
  description: String
  fileSize: Float
  data: JSON
  hash: String
  url: String
  createdAt: Datetime
  updatedAt: Datetime
  mimeTypeId: UUID
  assetTypeId: UUID
  ownerId: UUID
  isApproved: Boolean
  isPublished: Boolean
  approvedAt: Datetime
  publishedAt: Datetime
  publicationUrl: String
  coverUrl: String
  isArchived: Boolean
  archivedAt: Datetime
  statusId: UUID
  promptId: UUID
  creationTypeId: UUID
  applicationId: UUID
}

type AssetUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Asset!]!
}

# A high precision floating point value represented as a string
scalar BigFloat

# Boolean expression comparing fields on type "BigFloat"
input BigFloatFilter {
  eq: BigFloat
  gt: BigFloat
  gte: BigFloat
  in: [BigFloat!]
  is: FilterIs
  lt: BigFloat
  lte: BigFloat
  neq: BigFloat
}

# Boolean expression comparing fields on type "BigFloatList"
input BigFloatListFilter {
  containedBy: [BigFloat!]
  contains: [BigFloat!]
  eq: [BigFloat!]
  is: FilterIs
  overlaps: [BigFloat!]
}

# An arbitrary size integer represented as a string
scalar BigInt

# Boolean expression comparing fields on type "BigInt"
input BigIntFilter {
  eq: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  is: FilterIs
  lt: BigInt
  lte: BigInt
  neq: BigInt
}

# Boolean expression comparing fields on type "BigIntList"
input BigIntListFilter {
  containedBy: [BigInt!]
  contains: [BigInt!]
  eq: [BigInt!]
  is: FilterIs
  overlaps: [BigInt!]
}

# Boolean expression comparing fields on type "Boolean"
input BooleanFilter {
  eq: Boolean
  is: FilterIs
}

# Boolean expression comparing fields on type "BooleanList"
input BooleanListFilter {
  containedBy: [Boolean!]
  contains: [Boolean!]
  eq: [Boolean!]
  is: FilterIs
  overlaps: [Boolean!]
}

type ChatMessage implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  content: String!
  roleId: UUID
  createdAt: Datetime!
  data: JSON
  chatSessionId: UUID
  index: BigInt!
  previousMessageId: UUID
  role: ChatRole
  previousMessage: ChatMessage
  chatSession: ChatSession
  chatMessageCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatMessageFilter
    # Sort order to apply to the collection
    orderBy: [ChatMessageOrderBy!]
  ): ChatMessageConnection
}

type ChatMessageConnection {
  edges: [ChatMessageEdge!]!
  pageInfo: PageInfo!
}

type ChatMessageDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatMessage!]!
}

type ChatMessageEdge {
  cursor: String!
  node: ChatMessage!
}

input ChatMessageFilter {
  id: UUIDFilter
  content: StringFilter
  roleId: UUIDFilter
  createdAt: DatetimeFilter
  chatSessionId: UUIDFilter
  index: BigIntFilter
  previousMessageId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ChatMessageFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ChatMessageFilter!]
  # Negates a filter
  not: ChatMessageFilter
}

input ChatMessageInsertInput {
  id: UUID
  content: String
  roleId: UUID
  createdAt: Datetime
  data: JSON
  chatSessionId: UUID
  index: BigInt
  previousMessageId: UUID
}

type ChatMessageInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatMessage!]!
}

input ChatMessageOrderBy {
  id: OrderByDirection
  content: OrderByDirection
  roleId: OrderByDirection
  createdAt: OrderByDirection
  chatSessionId: OrderByDirection
  index: OrderByDirection
  previousMessageId: OrderByDirection
}

input ChatMessageUpdateInput {
  id: UUID
  content: String
  roleId: UUID
  createdAt: Datetime
  data: JSON
  chatSessionId: UUID
  index: BigInt
  previousMessageId: UUID
}

type ChatMessageUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatMessage!]!
}

type ChatRole implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  createdAt: Datetime!
  chatMessageCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatMessageFilter
    # Sort order to apply to the collection
    orderBy: [ChatMessageOrderBy!]
  ): ChatMessageConnection
}

type ChatRoleConnection {
  edges: [ChatRoleEdge!]!
  pageInfo: PageInfo!
}

type ChatRoleDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatRole!]!
}

type ChatRoleEdge {
  cursor: String!
  node: ChatRole!
}

input ChatRoleFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ChatRoleFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ChatRoleFilter!]
  # Negates a filter
  not: ChatRoleFilter
}

input ChatRoleInsertInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type ChatRoleInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatRole!]!
}

input ChatRoleOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input ChatRoleUpdateInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type ChatRoleUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatRole!]!
}

type ChatSession implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID
  createdAt: Datetime!
  startedAt: Datetime
  endedAt: Datetime
  lastActiveAt: Datetime
  data: JSON
  title: String
  notes: String
  applicationId: UUID!
  user: User
  application: Application!
  chatMessageCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatMessageFilter
    # Sort order to apply to the collection
    orderBy: [ChatMessageOrderBy!]
  ): ChatMessageConnection
}

type ChatSessionConnection {
  edges: [ChatSessionEdge!]!
  pageInfo: PageInfo!
}

type ChatSessionDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatSession!]!
}

type ChatSessionEdge {
  cursor: String!
  node: ChatSession!
}

input ChatSessionFilter {
  id: UUIDFilter
  userId: UUIDFilter
  createdAt: DatetimeFilter
  startedAt: DatetimeFilter
  endedAt: DatetimeFilter
  lastActiveAt: DatetimeFilter
  title: StringFilter
  notes: StringFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ChatSessionFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ChatSessionFilter!]
  # Negates a filter
  not: ChatSessionFilter
}

input ChatSessionInsertInput {
  id: UUID
  userId: UUID
  createdAt: Datetime
  startedAt: Datetime
  endedAt: Datetime
  lastActiveAt: Datetime
  data: JSON
  title: String
  notes: String
  applicationId: UUID
}

type ChatSessionInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatSession!]!
}

input ChatSessionOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  createdAt: OrderByDirection
  startedAt: OrderByDirection
  endedAt: OrderByDirection
  lastActiveAt: OrderByDirection
  title: OrderByDirection
  notes: OrderByDirection
  applicationId: OrderByDirection
}

input ChatSessionUpdateInput {
  id: UUID
  userId: UUID
  createdAt: Datetime
  startedAt: Datetime
  endedAt: Datetime
  lastActiveAt: Datetime
  data: JSON
  title: String
  notes: String
  applicationId: UUID
}

type ChatSessionUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ChatSession!]!
}

type Content implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  applicationId: UUID!
  title: String!
  description: String
  body: String!
  contentTypeId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime
  authorId: UUID
  data: JSON
  version: Int
  isApproved: Boolean!
  approvedAt: Datetime
  publicationStateId: UUID!
  coverUrl: String
  contentTemplateId: UUID
  publicationUrl: String
  bodyMarkdown: String
  creationTypeId: UUID
  publicationState: PublicationState!
  creationType: CreationType
  contentType: ContentType!
  contentTemplate: ContentTemplate
  author: User
  application: Application!
  contentContentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentContentPartOrderBy!]
  ): ContentContentPartConnection
  teamUpdateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateOrderBy!]
  ): TeamUpdateConnection
  contentTemplateVariableValueCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableValueFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableValueOrderBy!]
  ): ContentTemplateVariableValueConnection
}

type ContentConnection {
  edges: [ContentEdge!]!
  pageInfo: PageInfo!
}

type ContentContentPart implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  contentId: UUID!
  contentPartId: UUID!
  index: Int!
  createdAt: Datetime!
  contentPart: ContentPart!
  content: Content!
}

type ContentContentPartConnection {
  edges: [ContentContentPartEdge!]!
  pageInfo: PageInfo!
}

type ContentContentPartDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentContentPart!]!
}

type ContentContentPartEdge {
  cursor: String!
  node: ContentContentPart!
}

input ContentContentPartFilter {
  id: UUIDFilter
  contentId: UUIDFilter
  contentPartId: UUIDFilter
  index: IntFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentContentPartFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentContentPartFilter!]
  # Negates a filter
  not: ContentContentPartFilter
}

input ContentContentPartInsertInput {
  id: UUID
  contentId: UUID
  contentPartId: UUID
  index: Int
  createdAt: Datetime
}

type ContentContentPartInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentContentPart!]!
}

input ContentContentPartOrderBy {
  id: OrderByDirection
  contentId: OrderByDirection
  contentPartId: OrderByDirection
  index: OrderByDirection
  createdAt: OrderByDirection
}

input ContentContentPartUpdateInput {
  id: UUID
  contentId: UUID
  contentPartId: UUID
  index: Int
  createdAt: Datetime
}

type ContentContentPartUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentContentPart!]!
}

type ContentDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Content!]!
}

type ContentEdge {
  cursor: String!
  node: Content!
}

input ContentFilter {
  id: UUIDFilter
  applicationId: UUIDFilter
  title: StringFilter
  description: StringFilter
  body: StringFilter
  contentTypeId: UUIDFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  authorId: UUIDFilter
  version: IntFilter
  isApproved: BooleanFilter
  approvedAt: DatetimeFilter
  publicationStateId: UUIDFilter
  coverUrl: StringFilter
  contentTemplateId: UUIDFilter
  publicationUrl: StringFilter
  bodyMarkdown: StringFilter
  creationTypeId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentFilter!]
  # Negates a filter
  not: ContentFilter
}

input ContentInsertInput {
  id: UUID
  applicationId: UUID
  title: String
  description: String
  body: String
  contentTypeId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  authorId: UUID
  data: JSON
  version: Int
  isApproved: Boolean
  approvedAt: Datetime
  publicationStateId: UUID
  coverUrl: String
  contentTemplateId: UUID
  publicationUrl: String
  bodyMarkdown: String
  creationTypeId: UUID
}

type ContentInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Content!]!
}

input ContentOrderBy {
  id: OrderByDirection
  applicationId: OrderByDirection
  title: OrderByDirection
  description: OrderByDirection
  body: OrderByDirection
  contentTypeId: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  authorId: OrderByDirection
  version: OrderByDirection
  isApproved: OrderByDirection
  approvedAt: OrderByDirection
  publicationStateId: OrderByDirection
  coverUrl: OrderByDirection
  contentTemplateId: OrderByDirection
  publicationUrl: OrderByDirection
  bodyMarkdown: OrderByDirection
  creationTypeId: OrderByDirection
}

type ContentPart implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  contentTypeId: UUID!
  title: String!
  body: String!
  version: Int!
  createdAt: Datetime!
  updatedAt: Datetime
  aiContext: String
  bodyMarkdown: String
  data: JSON
  contentType: ContentType!
  contentContentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentContentPartOrderBy!]
  ): ContentContentPartConnection
  contentPartContentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentPartContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentPartContentPartOrderBy!]
  ): ContentPartContentPartConnection
}

type ContentPartConnection {
  edges: [ContentPartEdge!]!
  pageInfo: PageInfo!
}

type ContentPartContentPart implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  parentContentPartId: UUID!
  childContentPartId: UUID!
  index: Int!
  createdAt: Datetime!
  parentContentPart: ContentPart!
  childContentPart: ContentPart!
}

type ContentPartContentPartConnection {
  edges: [ContentPartContentPartEdge!]!
  pageInfo: PageInfo!
}

type ContentPartContentPartDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPartContentPart!]!
}

type ContentPartContentPartEdge {
  cursor: String!
  node: ContentPartContentPart!
}

input ContentPartContentPartFilter {
  id: UUIDFilter
  parentContentPartId: UUIDFilter
  childContentPartId: UUIDFilter
  index: IntFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentPartContentPartFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentPartContentPartFilter!]
  # Negates a filter
  not: ContentPartContentPartFilter
}

input ContentPartContentPartInsertInput {
  id: UUID
  parentContentPartId: UUID
  childContentPartId: UUID
  index: Int
  createdAt: Datetime
}

type ContentPartContentPartInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPartContentPart!]!
}

input ContentPartContentPartOrderBy {
  id: OrderByDirection
  parentContentPartId: OrderByDirection
  childContentPartId: OrderByDirection
  index: OrderByDirection
  createdAt: OrderByDirection
}

input ContentPartContentPartUpdateInput {
  id: UUID
  parentContentPartId: UUID
  childContentPartId: UUID
  index: Int
  createdAt: Datetime
}

type ContentPartContentPartUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPartContentPart!]!
}

type ContentPartDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPart!]!
}

type ContentPartEdge {
  cursor: String!
  node: ContentPart!
}

input ContentPartFilter {
  id: UUIDFilter
  contentTypeId: UUIDFilter
  title: StringFilter
  body: StringFilter
  version: IntFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  aiContext: StringFilter
  bodyMarkdown: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentPartFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentPartFilter!]
  # Negates a filter
  not: ContentPartFilter
}

input ContentPartInsertInput {
  id: UUID
  contentTypeId: UUID
  title: String
  body: String
  version: Int
  createdAt: Datetime
  updatedAt: Datetime
  aiContext: String
  bodyMarkdown: String
  data: JSON
}

type ContentPartInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPart!]!
}

input ContentPartOrderBy {
  id: OrderByDirection
  contentTypeId: OrderByDirection
  title: OrderByDirection
  body: OrderByDirection
  version: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  aiContext: OrderByDirection
  bodyMarkdown: OrderByDirection
}

input ContentPartUpdateInput {
  id: UUID
  contentTypeId: UUID
  title: String
  body: String
  version: Int
  createdAt: Datetime
  updatedAt: Datetime
  aiContext: String
  bodyMarkdown: String
  data: JSON
}

type ContentPartUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentPart!]!
}

type ContentTemplate implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  contentTypeId: UUID!
  title: String!
  body: String!
  createdAt: Datetime!
  data: JSON
  updatedAt: Datetime
  iconUrl: String
  coverUrl: String
  isActive: Boolean!
  activatedAt: Datetime
  deactivatedAt: Datetime
  isArchived: Boolean
  archivedAt: Datetime
  ownerId: UUID
  applicationId: UUID!
  owner: User
  contentType: ContentType!
  application: Application!
  contentTemplateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableOrderBy!]
  ): ContentTemplateVariableConnection
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
}

type ContentTemplateConnection {
  edges: [ContentTemplateEdge!]!
  pageInfo: PageInfo!
}

type ContentTemplateDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplate!]!
}

type ContentTemplateEdge {
  cursor: String!
  node: ContentTemplate!
}

input ContentTemplateFilter {
  id: UUIDFilter
  contentTypeId: UUIDFilter
  title: StringFilter
  body: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  isActive: BooleanFilter
  activatedAt: DatetimeFilter
  deactivatedAt: DatetimeFilter
  isArchived: BooleanFilter
  archivedAt: DatetimeFilter
  ownerId: UUIDFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentTemplateFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentTemplateFilter!]
  # Negates a filter
  not: ContentTemplateFilter
}

input ContentTemplateInsertInput {
  id: UUID
  contentTypeId: UUID
  title: String
  body: String
  createdAt: Datetime
  data: JSON
  updatedAt: Datetime
  iconUrl: String
  coverUrl: String
  isActive: Boolean
  activatedAt: Datetime
  deactivatedAt: Datetime
  isArchived: Boolean
  archivedAt: Datetime
  ownerId: UUID
  applicationId: UUID
}

type ContentTemplateInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplate!]!
}

input ContentTemplateOrderBy {
  id: OrderByDirection
  contentTypeId: OrderByDirection
  title: OrderByDirection
  body: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
  isActive: OrderByDirection
  activatedAt: OrderByDirection
  deactivatedAt: OrderByDirection
  isArchived: OrderByDirection
  archivedAt: OrderByDirection
  ownerId: OrderByDirection
  applicationId: OrderByDirection
}

input ContentTemplateUpdateInput {
  id: UUID
  contentTypeId: UUID
  title: String
  body: String
  createdAt: Datetime
  data: JSON
  updatedAt: Datetime
  iconUrl: String
  coverUrl: String
  isActive: Boolean
  activatedAt: Datetime
  deactivatedAt: Datetime
  isArchived: Boolean
  archivedAt: Datetime
  ownerId: UUID
  applicationId: UUID
}

type ContentTemplateUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplate!]!
}

type ContentTemplateVariable implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  templateVariableTypeId: UUID
  contentTemplateId: UUID!
  createdAt: Datetime!
  data: JSON
  templateVariableType: TemplateVariableType
  contentTemplate: ContentTemplate!
}

type ContentTemplateVariableConnection {
  edges: [ContentTemplateVariableEdge!]!
  pageInfo: PageInfo!
}

type ContentTemplateVariableDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariable!]!
}

type ContentTemplateVariableEdge {
  cursor: String!
  node: ContentTemplateVariable!
}

input ContentTemplateVariableFilter {
  id: UUIDFilter
  templateVariableTypeId: UUIDFilter
  contentTemplateId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentTemplateVariableFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentTemplateVariableFilter!]
  # Negates a filter
  not: ContentTemplateVariableFilter
}

input ContentTemplateVariableInsertInput {
  id: UUID
  templateVariableTypeId: UUID
  contentTemplateId: UUID
  createdAt: Datetime
  data: JSON
}

type ContentTemplateVariableInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariable!]!
}

input ContentTemplateVariableOrderBy {
  id: OrderByDirection
  templateVariableTypeId: OrderByDirection
  contentTemplateId: OrderByDirection
  createdAt: OrderByDirection
}

input ContentTemplateVariableUpdateInput {
  id: UUID
  templateVariableTypeId: UUID
  contentTemplateId: UUID
  createdAt: Datetime
  data: JSON
}

type ContentTemplateVariableUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariable!]!
}

type ContentTemplateVariableValue implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  contentId: UUID
  data: JSON
  valueString: String
  valueNumber: BigFloat
  valueDate: Datetime
  valueBool: Boolean
  createdAt: Datetime!
  updatedAt: Datetime
  content: Content
}

type ContentTemplateVariableValueConnection {
  edges: [ContentTemplateVariableValueEdge!]!
  pageInfo: PageInfo!
}

type ContentTemplateVariableValueDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariableValue!]!
}

type ContentTemplateVariableValueEdge {
  cursor: String!
  node: ContentTemplateVariableValue!
}

input ContentTemplateVariableValueFilter {
  id: UUIDFilter
  contentId: UUIDFilter
  valueString: StringFilter
  valueNumber: BigFloatFilter
  valueDate: DatetimeFilter
  valueBool: BooleanFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentTemplateVariableValueFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentTemplateVariableValueFilter!]
  # Negates a filter
  not: ContentTemplateVariableValueFilter
}

input ContentTemplateVariableValueInsertInput {
  id: UUID
  contentId: UUID
  data: JSON
  valueString: String
  valueNumber: BigFloat
  valueDate: Datetime
  valueBool: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

type ContentTemplateVariableValueInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariableValue!]!
}

input ContentTemplateVariableValueOrderBy {
  id: OrderByDirection
  contentId: OrderByDirection
  valueString: OrderByDirection
  valueNumber: OrderByDirection
  valueDate: OrderByDirection
  valueBool: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input ContentTemplateVariableValueUpdateInput {
  id: UUID
  contentId: UUID
  data: JSON
  valueString: String
  valueNumber: BigFloat
  valueDate: Datetime
  valueBool: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

type ContentTemplateVariableValueUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentTemplateVariableValue!]!
}

type ContentType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  schema: JSON
  createdAt: Datetime!
  requiresApproval: Boolean
  applicationId: UUID
  application: Application
  contentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentPartOrderBy!]
  ): ContentPartConnection
  contentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateOrderBy!]
  ): ContentTemplateConnection
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
}

type ContentTypeConnection {
  edges: [ContentTypeEdge!]!
  pageInfo: PageInfo!
}

type ContentTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentType!]!
}

type ContentTypeEdge {
  cursor: String!
  node: ContentType!
}

input ContentTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  requiresApproval: BooleanFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ContentTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ContentTypeFilter!]
  # Negates a filter
  not: ContentTypeFilter
}

input ContentTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  requiresApproval: Boolean
  applicationId: UUID
}

type ContentTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentType!]!
}

input ContentTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
  requiresApproval: OrderByDirection
  applicationId: OrderByDirection
}

input ContentTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  requiresApproval: Boolean
  applicationId: UUID
}

type ContentTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ContentType!]!
}

input ContentUpdateInput {
  id: UUID
  applicationId: UUID
  title: String
  description: String
  body: String
  contentTypeId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  authorId: UUID
  data: JSON
  version: Int
  isApproved: Boolean
  approvedAt: Datetime
  publicationStateId: UUID
  coverUrl: String
  contentTemplateId: UUID
  publicationUrl: String
  bodyMarkdown: String
  creationTypeId: UUID
}

type ContentUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Content!]!
}

type CreationType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  createdAt: Datetime!
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
}

type CreationTypeConnection {
  edges: [CreationTypeEdge!]!
  pageInfo: PageInfo!
}

type CreationTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [CreationType!]!
}

type CreationTypeEdge {
  cursor: String!
  node: CreationType!
}

input CreationTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [CreationTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [CreationTypeFilter!]
  # Negates a filter
  not: CreationTypeFilter
}

input CreationTypeInsertInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type CreationTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [CreationType!]!
}

input CreationTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input CreationTypeUpdateInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type CreationTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [CreationType!]!
}

# An opaque string using for tracking a position in results during pagination
scalar Cursor

# A date wihout time information
scalar Date

# Boolean expression comparing fields on type "Date"
input DateFilter {
  eq: Date
  gt: Date
  gte: Date
  in: [Date!]
  is: FilterIs
  lt: Date
  lte: Date
  neq: Date
}

# Boolean expression comparing fields on type "DateList"
input DateListFilter {
  containedBy: [Date!]
  contains: [Date!]
  eq: [Date!]
  is: FilterIs
  overlaps: [Date!]
}

# A date and time
scalar Datetime

# Boolean expression comparing fields on type "Datetime"
input DatetimeFilter {
  eq: Datetime
  gt: Datetime
  gte: Datetime
  in: [Datetime!]
  is: FilterIs
  lt: Datetime
  lte: Datetime
  neq: Datetime
}

# Boolean expression comparing fields on type "DatetimeList"
input DatetimeListFilter {
  containedBy: [Datetime!]
  contains: [Datetime!]
  eq: [Datetime!]
  is: FilterIs
  overlaps: [Datetime!]
}

type Document implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  mimeTypeId: UUID!
  fileName: String
  content: String
  originalFileUrl: String
  createdAt: Datetime!
  updatedAt: Datetime
  userId: UUID
  documentTypeId: UUID
  contentMarkdown: String
  applicationId: UUID!
  user: User
  mimeType: MimeType!
  documentType: DocumentType
  application: Application!
}

type DocumentConnection {
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Document!]!
}

type DocumentEdge {
  cursor: String!
  node: Document!
}

input DocumentFilter {
  id: UUIDFilter
  name: StringFilter
  mimeTypeId: UUIDFilter
  fileName: StringFilter
  content: StringFilter
  originalFileUrl: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  userId: UUIDFilter
  documentTypeId: UUIDFilter
  contentMarkdown: StringFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [DocumentFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [DocumentFilter!]
  # Negates a filter
  not: DocumentFilter
}

input DocumentInsertInput {
  id: UUID
  name: String
  mimeTypeId: UUID
  fileName: String
  content: String
  originalFileUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  userId: UUID
  documentTypeId: UUID
  contentMarkdown: String
  applicationId: UUID
}

type DocumentInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Document!]!
}

input DocumentOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  mimeTypeId: OrderByDirection
  fileName: OrderByDirection
  content: OrderByDirection
  originalFileUrl: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  userId: OrderByDirection
  documentTypeId: OrderByDirection
  contentMarkdown: OrderByDirection
  applicationId: OrderByDirection
}

type DocumentTemplate implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  documentTypeId: UUID!
  template: String!
  createdAt: Datetime!
  updatedAt: Datetime
  documentType: DocumentType!
}

type DocumentTemplateConnection {
  edges: [DocumentTemplateEdge!]!
  pageInfo: PageInfo!
}

type DocumentTemplateDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentTemplate!]!
}

type DocumentTemplateEdge {
  cursor: String!
  node: DocumentTemplate!
}

input DocumentTemplateFilter {
  id: UUIDFilter
  documentTypeId: UUIDFilter
  template: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [DocumentTemplateFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [DocumentTemplateFilter!]
  # Negates a filter
  not: DocumentTemplateFilter
}

input DocumentTemplateInsertInput {
  id: UUID
  documentTypeId: UUID
  template: String
  createdAt: Datetime
  updatedAt: Datetime
}

type DocumentTemplateInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentTemplate!]!
}

input DocumentTemplateOrderBy {
  id: OrderByDirection
  documentTypeId: OrderByDirection
  template: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input DocumentTemplateUpdateInput {
  id: UUID
  documentTypeId: UUID
  template: String
  createdAt: Datetime
  updatedAt: Datetime
}

type DocumentTemplateUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentTemplate!]!
}

type DocumentType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  schema: JSON
  createdAt: Datetime!
  requiresApproval: Boolean
  intentKeywords: [String]
  applicationId: UUID
  application: Application
  documentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [DocumentTemplateOrderBy!]
  ): DocumentTemplateConnection
  documentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentFilter
    # Sort order to apply to the collection
    orderBy: [DocumentOrderBy!]
  ): DocumentConnection
}

type DocumentTypeConnection {
  edges: [DocumentTypeEdge!]!
  pageInfo: PageInfo!
}

type DocumentTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentType!]!
}

type DocumentTypeEdge {
  cursor: String!
  node: DocumentType!
}

input DocumentTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  requiresApproval: BooleanFilter
  intentKeywords: StringListFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [DocumentTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [DocumentTypeFilter!]
  # Negates a filter
  not: DocumentTypeFilter
}

input DocumentTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  requiresApproval: Boolean
  intentKeywords: [String]
  applicationId: UUID
}

type DocumentTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentType!]!
}

input DocumentTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
  requiresApproval: OrderByDirection
  applicationId: OrderByDirection
}

input DocumentTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  createdAt: Datetime
  requiresApproval: Boolean
  intentKeywords: [String]
  applicationId: UUID
}

type DocumentTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [DocumentType!]!
}

input DocumentUpdateInput {
  id: UUID
  name: String
  mimeTypeId: UUID
  fileName: String
  content: String
  originalFileUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  userId: UUID
  documentTypeId: UUID
  contentMarkdown: String
  applicationId: UUID
}

type DocumentUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Document!]!
}

type Feature implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  title: String!
  description: String!
  longDescriptionMarkdown: String
  createdAt: Datetime!
  iconUrl: String
}

type FeatureConnection {
  edges: [FeatureEdge!]!
  pageInfo: PageInfo!
}

type FeatureDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Feature!]!
}

type FeatureEdge {
  cursor: String!
  node: Feature!
}

input FeatureFilter {
  id: UUIDFilter
  title: StringFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  iconUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FeatureFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FeatureFilter!]
  # Negates a filter
  not: FeatureFilter
}

input FeatureInsertInput {
  id: UUID
  title: String
  description: String
  longDescriptionMarkdown: String
  createdAt: Datetime
  iconUrl: String
}

type FeatureInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Feature!]!
}

input FeatureOrderBy {
  id: OrderByDirection
  title: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
  iconUrl: OrderByDirection
}

input FeatureUpdateInput {
  id: UUID
  title: String
  description: String
  longDescriptionMarkdown: String
  createdAt: Datetime
  iconUrl: String
}

type FeatureUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Feature!]!
}

enum FilterIs {
  NULL
  NOT_NULL
}

type FirefighterStatus implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  createdAt: Datetime!
}

type FirefighterStatusConnection {
  edges: [FirefighterStatusEdge!]!
  pageInfo: PageInfo!
}

type FirefighterStatusDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirefighterStatus!]!
}

type FirefighterStatusEdge {
  cursor: String!
  node: FirefighterStatus!
}

input FirefighterStatusFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FirefighterStatusFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FirefighterStatusFilter!]
  # Negates a filter
  not: FirefighterStatusFilter
}

input FirefighterStatusInsertInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type FirefighterStatusInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirefighterStatus!]!
}

input FirefighterStatusOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input FirefighterStatusUpdateInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type FirefighterStatusUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirefighterStatus!]!
}

type FirstResponder implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  badgeNumber: String
  currentStationId: UUID
  imageUrl: String
  data: JSON
  createdAt: Datetime!
  updatedAt: Datetime
  firstResponderTypeId: UUID!
  firstResponderType: FirstResponderType
  currentStation: Station
  user: User
  firstResponderStationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderStationFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderStationOrderBy!]
  ): FirstResponderStationConnection
}

type FirstResponderConnection {
  edges: [FirstResponderEdge!]!
  pageInfo: PageInfo!
}

type FirstResponderDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponder!]!
}

type FirstResponderEdge {
  cursor: String!
  node: FirstResponder!
}

input FirstResponderFilter {
  id: UUIDFilter
  userId: UUIDFilter
  badgeNumber: StringFilter
  currentStationId: UUIDFilter
  imageUrl: StringFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  firstResponderTypeId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FirstResponderFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FirstResponderFilter!]
  # Negates a filter
  not: FirstResponderFilter
}

input FirstResponderInsertInput {
  id: UUID
  userId: UUID
  badgeNumber: String
  currentStationId: UUID
  imageUrl: String
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
  firstResponderTypeId: UUID
}

type FirstResponderInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponder!]!
}

input FirstResponderOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  badgeNumber: OrderByDirection
  currentStationId: OrderByDirection
  imageUrl: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
  firstResponderTypeId: OrderByDirection
}

type FirstResponderStation implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  firstResponderId: UUID!
  stationId: UUID!
  createdAt: Datetime!
  station: Station!
  firstResponder: FirstResponder!
}

type FirstResponderStationConnection {
  edges: [FirstResponderStationEdge!]!
  pageInfo: PageInfo!
}

type FirstResponderStationDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderStation!]!
}

type FirstResponderStationEdge {
  cursor: String!
  node: FirstResponderStation!
}

input FirstResponderStationFilter {
  id: UUIDFilter
  firstResponderId: UUIDFilter
  stationId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FirstResponderStationFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FirstResponderStationFilter!]
  # Negates a filter
  not: FirstResponderStationFilter
}

input FirstResponderStationInsertInput {
  id: UUID
  firstResponderId: UUID
  stationId: UUID
  createdAt: Datetime
}

type FirstResponderStationInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderStation!]!
}

input FirstResponderStationOrderBy {
  id: OrderByDirection
  firstResponderId: OrderByDirection
  stationId: OrderByDirection
  createdAt: OrderByDirection
}

input FirstResponderStationUpdateInput {
  id: UUID
  firstResponderId: UUID
  stationId: UUID
  createdAt: Datetime
}

type FirstResponderStationUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderStation!]!
}

type FirstResponderType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  firstResponderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderOrderBy!]
  ): FirstResponderConnection
}

type FirstResponderTypeConnection {
  edges: [FirstResponderTypeEdge!]!
  pageInfo: PageInfo!
}

type FirstResponderTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderType!]!
}

type FirstResponderTypeEdge {
  cursor: String!
  node: FirstResponderType!
}

input FirstResponderTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FirstResponderTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FirstResponderTypeFilter!]
  # Negates a filter
  not: FirstResponderTypeFilter
}

input FirstResponderTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type FirstResponderTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderType!]!
}

input FirstResponderTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input FirstResponderTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type FirstResponderTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponderType!]!
}

input FirstResponderUpdateInput {
  id: UUID
  userId: UUID
  badgeNumber: String
  currentStationId: UUID
  imageUrl: String
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
  firstResponderTypeId: UUID
}

type FirstResponderUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FirstResponder!]!
}

# Boolean expression comparing fields on type "Float"
input FloatFilter {
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: FilterIs
  lt: Float
  lte: Float
  neq: Float
}

# Boolean expression comparing fields on type "FloatList"
input FloatListFilter {
  containedBy: [Float!]
  contains: [Float!]
  eq: [Float!]
  is: FilterIs
  overlaps: [Float!]
}

type Form implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  description: String
  createdAt: Datetime!
  onboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingStepOrderBy!]
  ): OnboardingStepConnection
  userFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormFilter
    # Sort order to apply to the collection
    orderBy: [UserFormOrderBy!]
  ): UserFormConnection
  formQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FormQuestionFilter
    # Sort order to apply to the collection
    orderBy: [FormQuestionOrderBy!]
  ): FormQuestionConnection
  onboardingFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFormFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingFormOrderBy!]
  ): OnboardingFormConnection
}

type FormConnection {
  edges: [FormEdge!]!
  pageInfo: PageInfo!
}

type FormDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Form!]!
}

type FormEdge {
  cursor: String!
  node: Form!
}

input FormFilter {
  id: UUIDFilter
  name: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FormFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FormFilter!]
  # Negates a filter
  not: FormFilter
}

input FormInsertInput {
  id: UUID
  name: String
  description: String
  createdAt: Datetime
}

type FormInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Form!]!
}

input FormOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
}

type FormQuestion implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  formId: UUID!
  questionId: UUID!
  index: Int!
  createdAt: Datetime!
  question: Question!
  form: Form!
}

type FormQuestionConnection {
  edges: [FormQuestionEdge!]!
  pageInfo: PageInfo!
}

type FormQuestionDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FormQuestion!]!
}

type FormQuestionEdge {
  cursor: String!
  node: FormQuestion!
}

input FormQuestionFilter {
  id: UUIDFilter
  formId: UUIDFilter
  questionId: UUIDFilter
  index: IntFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [FormQuestionFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [FormQuestionFilter!]
  # Negates a filter
  not: FormQuestionFilter
}

input FormQuestionInsertInput {
  id: UUID
  formId: UUID
  questionId: UUID
  index: Int
  createdAt: Datetime
}

type FormQuestionInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FormQuestion!]!
}

input FormQuestionOrderBy {
  id: OrderByDirection
  formId: OrderByDirection
  questionId: OrderByDirection
  index: OrderByDirection
  createdAt: OrderByDirection
}

input FormQuestionUpdateInput {
  id: UUID
  formId: UUID
  questionId: UUID
  index: Int
  createdAt: Datetime
}

type FormQuestionUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [FormQuestion!]!
}

input FormUpdateInput {
  id: UUID
  name: String
  description: String
  createdAt: Datetime
}

type FormUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Form!]!
}

type HeroItem implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  title: String
  subtitle: String
  coverImage: String
  targetUrl: String
}

type HeroItemConnection {
  edges: [HeroItemEdge!]!
  pageInfo: PageInfo!
}

type HeroItemDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [HeroItem!]!
}

type HeroItemEdge {
  cursor: String!
  node: HeroItem!
}

input HeroItemFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  title: StringFilter
  subtitle: StringFilter
  coverImage: StringFilter
  targetUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [HeroItemFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [HeroItemFilter!]
  # Negates a filter
  not: HeroItemFilter
}

input HeroItemInsertInput {
  id: UUID
  createdAt: Datetime
  title: String
  subtitle: String
  coverImage: String
  targetUrl: String
}

type HeroItemInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [HeroItem!]!
}

input HeroItemOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  title: OrderByDirection
  subtitle: OrderByDirection
  coverImage: OrderByDirection
  targetUrl: OrderByDirection
}

input HeroItemUpdateInput {
  id: UUID
  createdAt: Datetime
  title: String
  subtitle: String
  coverImage: String
  targetUrl: String
}

type HeroItemUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [HeroItem!]!
}

# Boolean expression comparing fields on type "ID"
input IDFilter {
  eq: ID
}

# Boolean expression comparing fields on type "Int"
input IntFilter {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  is: FilterIs
  lt: Int
  lte: Int
  neq: Int
}

# Boolean expression comparing fields on type "IntList"
input IntListFilter {
  containedBy: [Int!]
  contains: [Int!]
  eq: [Int!]
  is: FilterIs
  overlaps: [Int!]
}

# A Javascript Object Notation value serialized as a string
scalar JSON

type Menu implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  menuTypeId: UUID!
  name: String!
  key: String!
  data: JSON
  updatedAt: Datetime
  providerId: UUID!
  iconUrl: String
  coverUrl: String
  description: String
  provider: Provider!
  menuType: MenuType!
  menuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuItemFilter
    # Sort order to apply to the collection
    orderBy: [MenuItemOrderBy!]
  ): MenuItemConnection
}

type MenuConnection {
  edges: [MenuEdge!]!
  pageInfo: PageInfo!
}

type MenuDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Menu!]!
}

type MenuEdge {
  cursor: String!
  node: Menu!
}

input MenuFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  menuTypeId: UUIDFilter
  name: StringFilter
  key: StringFilter
  updatedAt: DatetimeFilter
  providerId: UUIDFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  description: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [MenuFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [MenuFilter!]
  # Negates a filter
  not: MenuFilter
}

input MenuInsertInput {
  id: UUID
  createdAt: Datetime
  menuTypeId: UUID
  name: String
  key: String
  data: JSON
  updatedAt: Datetime
  providerId: UUID
  iconUrl: String
  coverUrl: String
  description: String
}

type MenuInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Menu!]!
}

type MenuItem implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  menuId: UUID
  name: String!
  createdAt: Datetime!
  data: JSON
  notes: String
  imageUrl: String
  coverUrl: String
  price: Float!
  isAvailable: Boolean!
  categories: [String]!
  menu: Menu
  shoppingCartMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartMenuItemOrderBy!]
  ): ShoppingCartMenuItemConnection
  orderItemMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderItemMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [OrderItemMenuItemOrderBy!]
  ): OrderItemMenuItemConnection
}

type MenuItemConnection {
  edges: [MenuItemEdge!]!
  pageInfo: PageInfo!
}

type MenuItemDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuItem!]!
}

type MenuItemEdge {
  cursor: String!
  node: MenuItem!
}

input MenuItemFilter {
  id: UUIDFilter
  menuId: UUIDFilter
  name: StringFilter
  createdAt: DatetimeFilter
  notes: StringFilter
  imageUrl: StringFilter
  coverUrl: StringFilter
  price: FloatFilter
  isAvailable: BooleanFilter
  categories: StringListFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [MenuItemFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [MenuItemFilter!]
  # Negates a filter
  not: MenuItemFilter
}

input MenuItemInsertInput {
  id: UUID
  menuId: UUID
  name: String
  createdAt: Datetime
  data: JSON
  notes: String
  imageUrl: String
  coverUrl: String
  price: Float
  isAvailable: Boolean
  categories: [String]
}

type MenuItemInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuItem!]!
}

input MenuItemOrderBy {
  id: OrderByDirection
  menuId: OrderByDirection
  name: OrderByDirection
  createdAt: OrderByDirection
  notes: OrderByDirection
  imageUrl: OrderByDirection
  coverUrl: OrderByDirection
  price: OrderByDirection
  isAvailable: OrderByDirection
}

input MenuItemUpdateInput {
  id: UUID
  menuId: UUID
  name: String
  createdAt: Datetime
  data: JSON
  notes: String
  imageUrl: String
  coverUrl: String
  price: Float
  isAvailable: Boolean
  categories: [String]
}

type MenuItemUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuItem!]!
}

input MenuOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  menuTypeId: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  updatedAt: OrderByDirection
  providerId: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
  description: OrderByDirection
}

type MenuType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  createdAt: Datetime!
  iconUrl: String
  coverUrl: String
  schema: JSON
  menuCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuFilter
    # Sort order to apply to the collection
    orderBy: [MenuOrderBy!]
  ): MenuConnection
}

type MenuTypeConnection {
  edges: [MenuTypeEdge!]!
  pageInfo: PageInfo!
}

type MenuTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuType!]!
}

type MenuTypeEdge {
  cursor: String!
  node: MenuType!
}

input MenuTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [MenuTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [MenuTypeFilter!]
  # Negates a filter
  not: MenuTypeFilter
}

input MenuTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  createdAt: Datetime
  iconUrl: String
  coverUrl: String
  schema: JSON
}

type MenuTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuType!]!
}

input MenuTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
}

input MenuTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  createdAt: Datetime
  iconUrl: String
  coverUrl: String
  schema: JSON
}

type MenuTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MenuType!]!
}

input MenuUpdateInput {
  id: UUID
  createdAt: Datetime
  menuTypeId: UUID
  name: String
  key: String
  data: JSON
  updatedAt: Datetime
  providerId: UUID
  iconUrl: String
  coverUrl: String
  description: String
}

type MenuUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Menu!]!
}

type MimeType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  mime: String!
  name: String
  extensions: [String]!
  createdAt: Datetime!
  assetTypeMimeTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetTypeMimeTypeFilter
    # Sort order to apply to the collection
    orderBy: [AssetTypeMimeTypeOrderBy!]
  ): AssetTypeMimeTypeConnection
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
  documentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentFilter
    # Sort order to apply to the collection
    orderBy: [DocumentOrderBy!]
  ): DocumentConnection
}

type MimeTypeConnection {
  edges: [MimeTypeEdge!]!
  pageInfo: PageInfo!
}

type MimeTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MimeType!]!
}

type MimeTypeEdge {
  cursor: String!
  node: MimeType!
}

input MimeTypeFilter {
  id: UUIDFilter
  mime: StringFilter
  name: StringFilter
  extensions: StringListFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [MimeTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [MimeTypeFilter!]
  # Negates a filter
  not: MimeTypeFilter
}

input MimeTypeInsertInput {
  id: UUID
  mime: String
  name: String
  extensions: [String]
  createdAt: Datetime
}

type MimeTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MimeType!]!
}

input MimeTypeOrderBy {
  id: OrderByDirection
  mime: OrderByDirection
  name: OrderByDirection
  createdAt: OrderByDirection
}

input MimeTypeUpdateInput {
  id: UUID
  mime: String
  name: String
  extensions: [String]
  createdAt: Datetime
}

type MimeTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [MimeType!]!
}

# The root type for creating and mutating data
type Mutation {
  # Deletes zero or more records from the `Agent` collection
  deleteFromAgentCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AgentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AgentDeleteResponse!
  # Deletes zero or more records from the `AgentTool` collection
  deleteFromAgentToolCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AgentToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AgentToolDeleteResponse!
  # Deletes zero or more records from the `AiConfig` collection
  deleteFromAiConfigCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AiConfigFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AiConfigDeleteResponse!
  # Deletes zero or more records from the `AiConfigType` collection
  deleteFromAiConfigTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AiConfigTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AiConfigTypeDeleteResponse!
  # Deletes zero or more records from the `AnswerChoice` collection
  deleteFromAnswerChoiceCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AnswerChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AnswerChoiceDeleteResponse!
  # Deletes zero or more records from the `ApiType` collection
  deleteFromApiTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApiTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApiTypeDeleteResponse!
  # Deletes zero or more records from the `ApplicationAgent` collection
  deleteFromApplicationAgentCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationAgentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationAgentDeleteResponse!
  # Deletes zero or more records from the `Application` collection
  deleteFromApplicationCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationDeleteResponse!
  # Deletes zero or more records from the `ApplicationTable` collection
  deleteFromApplicationTableCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationTableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationTableDeleteResponse!
  # Deletes zero or more records from the `ApplicationTool` collection
  deleteFromApplicationToolCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationToolDeleteResponse!
  # Deletes zero or more records from the `ApplicationType` collection
  deleteFromApplicationTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationTypeDeleteResponse!
  # Deletes zero or more records from the `ApplicationUser` collection
  deleteFromApplicationUserCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationUserFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationUserDeleteResponse!
  # Deletes zero or more records from the `ApplicationUserRole` collection
  deleteFromApplicationUserRoleCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationUserRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationUserRoleDeleteResponse!
  # Deletes zero or more records from the `Asset` collection
  deleteFromAssetCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetDeleteResponse!
  # Deletes zero or more records from the `AssetStatus` collection
  deleteFromAssetStatusCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetStatusDeleteResponse!
  # Deletes zero or more records from the `AssetType` collection
  deleteFromAssetTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetTypeDeleteResponse!
  # Deletes zero or more records from the `AssetTypeMimeType` collection
  deleteFromAssetTypeMimeTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetTypeMimeTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetTypeMimeTypeDeleteResponse!
  # Deletes zero or more records from the `ChatMessage` collection
  deleteFromChatMessageCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatMessageFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatMessageDeleteResponse!
  # Deletes zero or more records from the `ChatRole` collection
  deleteFromChatRoleCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatRoleDeleteResponse!
  # Deletes zero or more records from the `ChatSession` collection
  deleteFromChatSessionCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatSessionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatSessionDeleteResponse!
  # Deletes zero or more records from the `Content` collection
  deleteFromContentCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentDeleteResponse!
  # Deletes zero or more records from the `ContentContentPart` collection
  deleteFromContentContentPartCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentContentPartDeleteResponse!
  # Deletes zero or more records from the `ContentPart` collection
  deleteFromContentPartCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentPartDeleteResponse!
  # Deletes zero or more records from the `ContentPartContentPart` collection
  deleteFromContentPartContentPartCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentPartContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentPartContentPartDeleteResponse!
  # Deletes zero or more records from the `ContentTemplate` collection
  deleteFromContentTemplateCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateDeleteResponse!
  # Deletes zero or more records from the `ContentTemplateVariable` collection
  deleteFromContentTemplateVariableCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateVariableDeleteResponse!
  # Deletes zero or more records from the `ContentTemplateVariableValue` collection
  deleteFromContentTemplateVariableValueCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateVariableValueFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateVariableValueDeleteResponse!
  # Deletes zero or more records from the `ContentType` collection
  deleteFromContentTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTypeDeleteResponse!
  # Deletes zero or more records from the `CreationType` collection
  deleteFromCreationTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: CreationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): CreationTypeDeleteResponse!
  # Deletes zero or more records from the `Document` collection
  deleteFromDocumentCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentDeleteResponse!
  # Deletes zero or more records from the `DocumentTemplate` collection
  deleteFromDocumentTemplateCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentTemplateDeleteResponse!
  # Deletes zero or more records from the `DocumentType` collection
  deleteFromDocumentTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentTypeDeleteResponse!
  # Deletes zero or more records from the `Feature` collection
  deleteFromFeatureCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FeatureFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FeatureDeleteResponse!
  # Deletes zero or more records from the `FirefighterStatus` collection
  deleteFromFirefighterStatusCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FirefighterStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirefighterStatusDeleteResponse!
  # Deletes zero or more records from the `FirstResponder` collection
  deleteFromFirstResponderCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderDeleteResponse!
  # Deletes zero or more records from the `FirstResponderStation` collection
  deleteFromFirstResponderStationCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderStationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderStationDeleteResponse!
  # Deletes zero or more records from the `FirstResponderType` collection
  deleteFromFirstResponderTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderTypeDeleteResponse!
  # Deletes zero or more records from the `Form` collection
  deleteFromFormCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FormDeleteResponse!
  # Deletes zero or more records from the `FormQuestion` collection
  deleteFromFormQuestionCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: FormQuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FormQuestionDeleteResponse!
  # Deletes zero or more records from the `HeroItem` collection
  deleteFromHeroItemCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: HeroItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): HeroItemDeleteResponse!
  # Deletes zero or more records from the `Menu` collection
  deleteFromMenuCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuDeleteResponse!
  # Deletes zero or more records from the `MenuItem` collection
  deleteFromMenuItemCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuItemDeleteResponse!
  # Deletes zero or more records from the `MenuType` collection
  deleteFromMenuTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuTypeDeleteResponse!
  # Deletes zero or more records from the `MimeType` collection
  deleteFromMimeTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: MimeTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MimeTypeDeleteResponse!
  # Deletes zero or more records from the `Notification` collection
  deleteFromNotificationCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: NotificationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): NotificationDeleteResponse!
  # Deletes zero or more records from the `NotificationType` collection
  deleteFromNotificationTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: NotificationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): NotificationTypeDeleteResponse!
  # Deletes zero or more records from the `Onboarding` collection
  deleteFromOnboardingCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingDeleteResponse!
  # Deletes zero or more records from the `OnboardingForm` collection
  deleteFromOnboardingFormCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingFormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingFormDeleteResponse!
  # Deletes zero or more records from the `OnboardingStep` collection
  deleteFromOnboardingStepCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingStepFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingStepDeleteResponse!
  # Deletes zero or more records from the `OnboardingSurvey` collection
  deleteFromOnboardingSurveyCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingSurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingSurveyDeleteResponse!
  # Deletes zero or more records from the `OnboardingType` collection
  deleteFromOnboardingTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingTypeDeleteResponse!
  # Deletes zero or more records from the `Order` collection
  deleteFromOrderCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderDeleteResponse!
  # Deletes zero or more records from the `OrderItem` collection
  deleteFromOrderItemCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderItemDeleteResponse!
  # Deletes zero or more records from the `OrderItemMenuItem` collection
  deleteFromOrderItemMenuItemCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderItemMenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderItemMenuItemDeleteResponse!
  # Deletes zero or more records from the `OrderStatus` collection
  deleteFromOrderStatusCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderStatusDeleteResponse!
  # Deletes zero or more records from the `OrderTransaction` collection
  deleteFromOrderTransactionCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderTransactionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderTransactionDeleteResponse!
  # Deletes zero or more records from the `OrderType` collection
  deleteFromOrderTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderTypeDeleteResponse!
  # Deletes zero or more records from the `Partner` collection
  deleteFromPartnerCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PartnerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PartnerDeleteResponse!
  # Deletes zero or more records from the `PartnerType` collection
  deleteFromPartnerTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PartnerTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PartnerTypeDeleteResponse!
  # Deletes zero or more records from the `PaymentInfo` collection
  deleteFromPaymentInfoCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PaymentInfoFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PaymentInfoDeleteResponse!
  # Deletes zero or more records from the `PaymentType` collection
  deleteFromPaymentTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PaymentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PaymentTypeDeleteResponse!
  # Deletes zero or more records from the `Persona` collection
  deleteFromPersonaCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PersonaFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PersonaDeleteResponse!
  # Deletes zero or more records from the `PersonaOnboarding` collection
  deleteFromPersonaOnboardingCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PersonaOnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PersonaOnboardingDeleteResponse!
  # Deletes zero or more records from the `ProfileType` collection
  deleteFromProfileTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ProfileTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProfileTypeDeleteResponse!
  # Deletes zero or more records from the `Prompt` collection
  deleteFromPromptCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptDeleteResponse!
  # Deletes zero or more records from the `PromptTemplate` collection
  deleteFromPromptTemplateCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptTemplateDeleteResponse!
  # Deletes zero or more records from the `PromptTemplateVariable` collection
  deleteFromPromptTemplateVariableCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptTemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptTemplateVariableDeleteResponse!
  # Deletes zero or more records from the `Provider` collection
  deleteFromProviderCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ProviderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProviderDeleteResponse!
  # Deletes zero or more records from the `ProviderType` collection
  deleteFromProviderTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ProviderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProviderTypeDeleteResponse!
  # Deletes zero or more records from the `PublicationState` collection
  deleteFromPublicationStateCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: PublicationStateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PublicationStateDeleteResponse!
  # Deletes zero or more records from the `QuestionAnwserChoice` collection
  deleteFromQuestionAnwserChoiceCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionAnwserChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionAnwserChoiceDeleteResponse!
  # Deletes zero or more records from the `Question` collection
  deleteFromQuestionCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionDeleteResponse!
  # Deletes zero or more records from the `QuestionType` collection
  deleteFromQuestionTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionTypeDeleteResponse!
  # Deletes zero or more records from the `Role` collection
  deleteFromRoleCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: RoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): RoleDeleteResponse!
  # Deletes zero or more records from the `SchemaMigrations` collection
  deleteFromSchemaMigrationsCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: SchemaMigrationsFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SchemaMigrationsDeleteResponse!
  # Deletes zero or more records from the `Shift` collection
  deleteFromShiftCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftDeleteResponse!
  # Deletes zero or more records from the `ShiftScheduleStatus` collection
  deleteFromShiftScheduleStatusCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftScheduleStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftScheduleStatusDeleteResponse!
  # Deletes zero or more records from the `ShiftType` collection
  deleteFromShiftTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftTypeDeleteResponse!
  # Deletes zero or more records from the `ShoppingCart` collection
  deleteFromShoppingCartCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ShoppingCartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShoppingCartDeleteResponse!
  # Deletes zero or more records from the `ShoppingCartMenuItem` collection
  deleteFromShoppingCartMenuItemCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ShoppingCartMenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShoppingCartMenuItemDeleteResponse!
  # Deletes zero or more records from the `Station` collection
  deleteFromStationCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: StationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationDeleteResponse!
  # Deletes zero or more records from the `StationPartner` collection
  deleteFromStationPartnerCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: StationPartnerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationPartnerDeleteResponse!
  # Deletes zero or more records from the `StationProvider` collection
  deleteFromStationProviderCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: StationProviderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationProviderDeleteResponse!
  # Deletes zero or more records from the `Survey` collection
  deleteFromSurveyCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: SurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SurveyDeleteResponse!
  # Deletes zero or more records from the `SurveyQuestion` collection
  deleteFromSurveyQuestionCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: SurveyQuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SurveyQuestionDeleteResponse!
  # Deletes zero or more records from the `TeamUpdate` collection
  deleteFromTeamUpdateCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: TeamUpdateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TeamUpdateDeleteResponse!
  # Deletes zero or more records from the `TeamUpdateType` collection
  deleteFromTeamUpdateTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: TeamUpdateTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TeamUpdateTypeDeleteResponse!
  # Deletes zero or more records from the `TemplateVariable` collection
  deleteFromTemplateVariableCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: TemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TemplateVariableDeleteResponse!
  # Deletes zero or more records from the `TemplateVariableType` collection
  deleteFromTemplateVariableTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: TemplateVariableTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TemplateVariableTypeDeleteResponse!
  # Deletes zero or more records from the `Testimonial` collection
  deleteFromTestimonialCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: TestimonialFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TestimonialDeleteResponse!
  # Deletes zero or more records from the `Tool` collection
  deleteFromToolCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ToolDeleteResponse!
  # Deletes zero or more records from the `ToolType` collection
  deleteFromToolTypeCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: ToolTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ToolTypeDeleteResponse!
  # Deletes zero or more records from the `UserAnswerChoice` collection
  deleteFromUserAnswerChoiceCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserAnswerChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserAnswerChoiceDeleteResponse!
  # Deletes zero or more records from the `User` collection
  deleteFromUserCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserDeleteResponse!
  # Deletes zero or more records from the `UserForm` collection
  deleteFromUserFormCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserFormDeleteResponse!
  # Deletes zero or more records from the `UserFormQuestionAnswer` collection
  deleteFromUserFormQuestionAnswerCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFormQuestionAnswerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserFormQuestionAnswerDeleteResponse!
  # Deletes zero or more records from the `UserOnboarding` collection
  deleteFromUserOnboardingCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserOnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserOnboardingDeleteResponse!
  # Deletes zero or more records from the `UserOnboardingStep` collection
  deleteFromUserOnboardingStepCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserOnboardingStepFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserOnboardingStepDeleteResponse!
  # Deletes zero or more records from the `UserPersona` collection
  deleteFromUserPersonaCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserPersonaFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserPersonaDeleteResponse!
  # Deletes zero or more records from the `UserProfile` collection
  deleteFromUserProfileCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserProfileFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserProfileDeleteResponse!
  # Deletes zero or more records from the `UserRole` collection
  deleteFromUserRoleCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserRoleDeleteResponse!
  # Deletes zero or more records from the `UserSurveyAnswer` collection
  deleteFromUserSurveyAnswerCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserSurveyAnswerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserSurveyAnswerDeleteResponse!
  # Deletes zero or more records from the `UserSurvey` collection
  deleteFromUserSurveyCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: UserSurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserSurveyDeleteResponse!
  # Deletes zero or more records from the `VectorDatabase` collection
  deleteFromVectorDatabaseCollection(
    # Restricts the mutation's impact to records matching the criteria
    filter: VectorDatabaseFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): VectorDatabaseDeleteResponse!
  # Adds one or more `Agent` records to the collection
  insertIntoAgentCollection(objects: [AgentInsertInput!]!): AgentInsertResponse
  # Adds one or more `AgentTool` records to the collection
  insertIntoAgentToolCollection(
    objects: [AgentToolInsertInput!]!
  ): AgentToolInsertResponse
  # Adds one or more `AiConfig` records to the collection
  insertIntoAiConfigCollection(
    objects: [AiConfigInsertInput!]!
  ): AiConfigInsertResponse
  # Adds one or more `AiConfigType` records to the collection
  insertIntoAiConfigTypeCollection(
    objects: [AiConfigTypeInsertInput!]!
  ): AiConfigTypeInsertResponse
  # Adds one or more `AnswerChoice` records to the collection
  insertIntoAnswerChoiceCollection(
    objects: [AnswerChoiceInsertInput!]!
  ): AnswerChoiceInsertResponse
  # Adds one or more `ApiType` records to the collection
  insertIntoApiTypeCollection(
    objects: [ApiTypeInsertInput!]!
  ): ApiTypeInsertResponse
  # Adds one or more `ApplicationAgent` records to the collection
  insertIntoApplicationAgentCollection(
    objects: [ApplicationAgentInsertInput!]!
  ): ApplicationAgentInsertResponse
  # Adds one or more `Application` records to the collection
  insertIntoApplicationCollection(
    objects: [ApplicationInsertInput!]!
  ): ApplicationInsertResponse
  # Adds one or more `ApplicationTable` records to the collection
  insertIntoApplicationTableCollection(
    objects: [ApplicationTableInsertInput!]!
  ): ApplicationTableInsertResponse
  # Adds one or more `ApplicationTool` records to the collection
  insertIntoApplicationToolCollection(
    objects: [ApplicationToolInsertInput!]!
  ): ApplicationToolInsertResponse
  # Adds one or more `ApplicationType` records to the collection
  insertIntoApplicationTypeCollection(
    objects: [ApplicationTypeInsertInput!]!
  ): ApplicationTypeInsertResponse
  # Adds one or more `ApplicationUser` records to the collection
  insertIntoApplicationUserCollection(
    objects: [ApplicationUserInsertInput!]!
  ): ApplicationUserInsertResponse
  # Adds one or more `ApplicationUserRole` records to the collection
  insertIntoApplicationUserRoleCollection(
    objects: [ApplicationUserRoleInsertInput!]!
  ): ApplicationUserRoleInsertResponse
  # Adds one or more `Asset` records to the collection
  insertIntoAssetCollection(objects: [AssetInsertInput!]!): AssetInsertResponse
  # Adds one or more `AssetStatus` records to the collection
  insertIntoAssetStatusCollection(
    objects: [AssetStatusInsertInput!]!
  ): AssetStatusInsertResponse
  # Adds one or more `AssetType` records to the collection
  insertIntoAssetTypeCollection(
    objects: [AssetTypeInsertInput!]!
  ): AssetTypeInsertResponse
  # Adds one or more `AssetTypeMimeType` records to the collection
  insertIntoAssetTypeMimeTypeCollection(
    objects: [AssetTypeMimeTypeInsertInput!]!
  ): AssetTypeMimeTypeInsertResponse
  # Adds one or more `ChatMessage` records to the collection
  insertIntoChatMessageCollection(
    objects: [ChatMessageInsertInput!]!
  ): ChatMessageInsertResponse
  # Adds one or more `ChatRole` records to the collection
  insertIntoChatRoleCollection(
    objects: [ChatRoleInsertInput!]!
  ): ChatRoleInsertResponse
  # Adds one or more `ChatSession` records to the collection
  insertIntoChatSessionCollection(
    objects: [ChatSessionInsertInput!]!
  ): ChatSessionInsertResponse
  # Adds one or more `Content` records to the collection
  insertIntoContentCollection(
    objects: [ContentInsertInput!]!
  ): ContentInsertResponse
  # Adds one or more `ContentContentPart` records to the collection
  insertIntoContentContentPartCollection(
    objects: [ContentContentPartInsertInput!]!
  ): ContentContentPartInsertResponse
  # Adds one or more `ContentPart` records to the collection
  insertIntoContentPartCollection(
    objects: [ContentPartInsertInput!]!
  ): ContentPartInsertResponse
  # Adds one or more `ContentPartContentPart` records to the collection
  insertIntoContentPartContentPartCollection(
    objects: [ContentPartContentPartInsertInput!]!
  ): ContentPartContentPartInsertResponse
  # Adds one or more `ContentTemplate` records to the collection
  insertIntoContentTemplateCollection(
    objects: [ContentTemplateInsertInput!]!
  ): ContentTemplateInsertResponse
  # Adds one or more `ContentTemplateVariable` records to the collection
  insertIntoContentTemplateVariableCollection(
    objects: [ContentTemplateVariableInsertInput!]!
  ): ContentTemplateVariableInsertResponse
  # Adds one or more `ContentTemplateVariableValue` records to the collection
  insertIntoContentTemplateVariableValueCollection(
    objects: [ContentTemplateVariableValueInsertInput!]!
  ): ContentTemplateVariableValueInsertResponse
  # Adds one or more `ContentType` records to the collection
  insertIntoContentTypeCollection(
    objects: [ContentTypeInsertInput!]!
  ): ContentTypeInsertResponse
  # Adds one or more `CreationType` records to the collection
  insertIntoCreationTypeCollection(
    objects: [CreationTypeInsertInput!]!
  ): CreationTypeInsertResponse
  # Adds one or more `Document` records to the collection
  insertIntoDocumentCollection(
    objects: [DocumentInsertInput!]!
  ): DocumentInsertResponse
  # Adds one or more `DocumentTemplate` records to the collection
  insertIntoDocumentTemplateCollection(
    objects: [DocumentTemplateInsertInput!]!
  ): DocumentTemplateInsertResponse
  # Adds one or more `DocumentType` records to the collection
  insertIntoDocumentTypeCollection(
    objects: [DocumentTypeInsertInput!]!
  ): DocumentTypeInsertResponse
  # Adds one or more `Feature` records to the collection
  insertIntoFeatureCollection(
    objects: [FeatureInsertInput!]!
  ): FeatureInsertResponse
  # Adds one or more `FirefighterStatus` records to the collection
  insertIntoFirefighterStatusCollection(
    objects: [FirefighterStatusInsertInput!]!
  ): FirefighterStatusInsertResponse
  # Adds one or more `FirstResponder` records to the collection
  insertIntoFirstResponderCollection(
    objects: [FirstResponderInsertInput!]!
  ): FirstResponderInsertResponse
  # Adds one or more `FirstResponderStation` records to the collection
  insertIntoFirstResponderStationCollection(
    objects: [FirstResponderStationInsertInput!]!
  ): FirstResponderStationInsertResponse
  # Adds one or more `FirstResponderType` records to the collection
  insertIntoFirstResponderTypeCollection(
    objects: [FirstResponderTypeInsertInput!]!
  ): FirstResponderTypeInsertResponse
  # Adds one or more `Form` records to the collection
  insertIntoFormCollection(objects: [FormInsertInput!]!): FormInsertResponse
  # Adds one or more `FormQuestion` records to the collection
  insertIntoFormQuestionCollection(
    objects: [FormQuestionInsertInput!]!
  ): FormQuestionInsertResponse
  # Adds one or more `HeroItem` records to the collection
  insertIntoHeroItemCollection(
    objects: [HeroItemInsertInput!]!
  ): HeroItemInsertResponse
  # Adds one or more `Menu` records to the collection
  insertIntoMenuCollection(objects: [MenuInsertInput!]!): MenuInsertResponse
  # Adds one or more `MenuItem` records to the collection
  insertIntoMenuItemCollection(
    objects: [MenuItemInsertInput!]!
  ): MenuItemInsertResponse
  # Adds one or more `MenuType` records to the collection
  insertIntoMenuTypeCollection(
    objects: [MenuTypeInsertInput!]!
  ): MenuTypeInsertResponse
  # Adds one or more `MimeType` records to the collection
  insertIntoMimeTypeCollection(
    objects: [MimeTypeInsertInput!]!
  ): MimeTypeInsertResponse
  # Adds one or more `Notification` records to the collection
  insertIntoNotificationCollection(
    objects: [NotificationInsertInput!]!
  ): NotificationInsertResponse
  # Adds one or more `NotificationType` records to the collection
  insertIntoNotificationTypeCollection(
    objects: [NotificationTypeInsertInput!]!
  ): NotificationTypeInsertResponse
  # Adds one or more `Onboarding` records to the collection
  insertIntoOnboardingCollection(
    objects: [OnboardingInsertInput!]!
  ): OnboardingInsertResponse
  # Adds one or more `OnboardingForm` records to the collection
  insertIntoOnboardingFormCollection(
    objects: [OnboardingFormInsertInput!]!
  ): OnboardingFormInsertResponse
  # Adds one or more `OnboardingStep` records to the collection
  insertIntoOnboardingStepCollection(
    objects: [OnboardingStepInsertInput!]!
  ): OnboardingStepInsertResponse
  # Adds one or more `OnboardingSurvey` records to the collection
  insertIntoOnboardingSurveyCollection(
    objects: [OnboardingSurveyInsertInput!]!
  ): OnboardingSurveyInsertResponse
  # Adds one or more `OnboardingType` records to the collection
  insertIntoOnboardingTypeCollection(
    objects: [OnboardingTypeInsertInput!]!
  ): OnboardingTypeInsertResponse
  # Adds one or more `Order` records to the collection
  insertIntoOrderCollection(objects: [OrderInsertInput!]!): OrderInsertResponse
  # Adds one or more `OrderItem` records to the collection
  insertIntoOrderItemCollection(
    objects: [OrderItemInsertInput!]!
  ): OrderItemInsertResponse
  # Adds one or more `OrderItemMenuItem` records to the collection
  insertIntoOrderItemMenuItemCollection(
    objects: [OrderItemMenuItemInsertInput!]!
  ): OrderItemMenuItemInsertResponse
  # Adds one or more `OrderStatus` records to the collection
  insertIntoOrderStatusCollection(
    objects: [OrderStatusInsertInput!]!
  ): OrderStatusInsertResponse
  # Adds one or more `OrderTransaction` records to the collection
  insertIntoOrderTransactionCollection(
    objects: [OrderTransactionInsertInput!]!
  ): OrderTransactionInsertResponse
  # Adds one or more `OrderType` records to the collection
  insertIntoOrderTypeCollection(
    objects: [OrderTypeInsertInput!]!
  ): OrderTypeInsertResponse
  # Adds one or more `Partner` records to the collection
  insertIntoPartnerCollection(
    objects: [PartnerInsertInput!]!
  ): PartnerInsertResponse
  # Adds one or more `PartnerType` records to the collection
  insertIntoPartnerTypeCollection(
    objects: [PartnerTypeInsertInput!]!
  ): PartnerTypeInsertResponse
  # Adds one or more `PaymentInfo` records to the collection
  insertIntoPaymentInfoCollection(
    objects: [PaymentInfoInsertInput!]!
  ): PaymentInfoInsertResponse
  # Adds one or more `PaymentType` records to the collection
  insertIntoPaymentTypeCollection(
    objects: [PaymentTypeInsertInput!]!
  ): PaymentTypeInsertResponse
  # Adds one or more `Persona` records to the collection
  insertIntoPersonaCollection(
    objects: [PersonaInsertInput!]!
  ): PersonaInsertResponse
  # Adds one or more `PersonaOnboarding` records to the collection
  insertIntoPersonaOnboardingCollection(
    objects: [PersonaOnboardingInsertInput!]!
  ): PersonaOnboardingInsertResponse
  # Adds one or more `ProfileType` records to the collection
  insertIntoProfileTypeCollection(
    objects: [ProfileTypeInsertInput!]!
  ): ProfileTypeInsertResponse
  # Adds one or more `Prompt` records to the collection
  insertIntoPromptCollection(
    objects: [PromptInsertInput!]!
  ): PromptInsertResponse
  # Adds one or more `PromptTemplate` records to the collection
  insertIntoPromptTemplateCollection(
    objects: [PromptTemplateInsertInput!]!
  ): PromptTemplateInsertResponse
  # Adds one or more `PromptTemplateVariable` records to the collection
  insertIntoPromptTemplateVariableCollection(
    objects: [PromptTemplateVariableInsertInput!]!
  ): PromptTemplateVariableInsertResponse
  # Adds one or more `Provider` records to the collection
  insertIntoProviderCollection(
    objects: [ProviderInsertInput!]!
  ): ProviderInsertResponse
  # Adds one or more `ProviderType` records to the collection
  insertIntoProviderTypeCollection(
    objects: [ProviderTypeInsertInput!]!
  ): ProviderTypeInsertResponse
  # Adds one or more `PublicationState` records to the collection
  insertIntoPublicationStateCollection(
    objects: [PublicationStateInsertInput!]!
  ): PublicationStateInsertResponse
  # Adds one or more `QuestionAnwserChoice` records to the collection
  insertIntoQuestionAnwserChoiceCollection(
    objects: [QuestionAnwserChoiceInsertInput!]!
  ): QuestionAnwserChoiceInsertResponse
  # Adds one or more `Question` records to the collection
  insertIntoQuestionCollection(
    objects: [QuestionInsertInput!]!
  ): QuestionInsertResponse
  # Adds one or more `QuestionType` records to the collection
  insertIntoQuestionTypeCollection(
    objects: [QuestionTypeInsertInput!]!
  ): QuestionTypeInsertResponse
  # Adds one or more `Role` records to the collection
  insertIntoRoleCollection(objects: [RoleInsertInput!]!): RoleInsertResponse
  # Adds one or more `SchemaMigrations` records to the collection
  insertIntoSchemaMigrationsCollection(
    objects: [SchemaMigrationsInsertInput!]!
  ): SchemaMigrationsInsertResponse
  # Adds one or more `Shift` records to the collection
  insertIntoShiftCollection(objects: [ShiftInsertInput!]!): ShiftInsertResponse
  # Adds one or more `ShiftScheduleStatus` records to the collection
  insertIntoShiftScheduleStatusCollection(
    objects: [ShiftScheduleStatusInsertInput!]!
  ): ShiftScheduleStatusInsertResponse
  # Adds one or more `ShiftType` records to the collection
  insertIntoShiftTypeCollection(
    objects: [ShiftTypeInsertInput!]!
  ): ShiftTypeInsertResponse
  # Adds one or more `ShoppingCart` records to the collection
  insertIntoShoppingCartCollection(
    objects: [ShoppingCartInsertInput!]!
  ): ShoppingCartInsertResponse
  # Adds one or more `ShoppingCartMenuItem` records to the collection
  insertIntoShoppingCartMenuItemCollection(
    objects: [ShoppingCartMenuItemInsertInput!]!
  ): ShoppingCartMenuItemInsertResponse
  # Adds one or more `Station` records to the collection
  insertIntoStationCollection(
    objects: [StationInsertInput!]!
  ): StationInsertResponse
  # Adds one or more `StationPartner` records to the collection
  insertIntoStationPartnerCollection(
    objects: [StationPartnerInsertInput!]!
  ): StationPartnerInsertResponse
  # Adds one or more `StationProvider` records to the collection
  insertIntoStationProviderCollection(
    objects: [StationProviderInsertInput!]!
  ): StationProviderInsertResponse
  # Adds one or more `Survey` records to the collection
  insertIntoSurveyCollection(
    objects: [SurveyInsertInput!]!
  ): SurveyInsertResponse
  # Adds one or more `SurveyQuestion` records to the collection
  insertIntoSurveyQuestionCollection(
    objects: [SurveyQuestionInsertInput!]!
  ): SurveyQuestionInsertResponse
  # Adds one or more `TeamUpdate` records to the collection
  insertIntoTeamUpdateCollection(
    objects: [TeamUpdateInsertInput!]!
  ): TeamUpdateInsertResponse
  # Adds one or more `TeamUpdateType` records to the collection
  insertIntoTeamUpdateTypeCollection(
    objects: [TeamUpdateTypeInsertInput!]!
  ): TeamUpdateTypeInsertResponse
  # Adds one or more `TemplateVariable` records to the collection
  insertIntoTemplateVariableCollection(
    objects: [TemplateVariableInsertInput!]!
  ): TemplateVariableInsertResponse
  # Adds one or more `TemplateVariableType` records to the collection
  insertIntoTemplateVariableTypeCollection(
    objects: [TemplateVariableTypeInsertInput!]!
  ): TemplateVariableTypeInsertResponse
  # Adds one or more `Testimonial` records to the collection
  insertIntoTestimonialCollection(
    objects: [TestimonialInsertInput!]!
  ): TestimonialInsertResponse
  # Adds one or more `Tool` records to the collection
  insertIntoToolCollection(objects: [ToolInsertInput!]!): ToolInsertResponse
  # Adds one or more `ToolType` records to the collection
  insertIntoToolTypeCollection(
    objects: [ToolTypeInsertInput!]!
  ): ToolTypeInsertResponse
  # Adds one or more `UserAnswerChoice` records to the collection
  insertIntoUserAnswerChoiceCollection(
    objects: [UserAnswerChoiceInsertInput!]!
  ): UserAnswerChoiceInsertResponse
  # Adds one or more `User` records to the collection
  insertIntoUserCollection(objects: [UserInsertInput!]!): UserInsertResponse
  # Adds one or more `UserForm` records to the collection
  insertIntoUserFormCollection(
    objects: [UserFormInsertInput!]!
  ): UserFormInsertResponse
  # Adds one or more `UserFormQuestionAnswer` records to the collection
  insertIntoUserFormQuestionAnswerCollection(
    objects: [UserFormQuestionAnswerInsertInput!]!
  ): UserFormQuestionAnswerInsertResponse
  # Adds one or more `UserOnboarding` records to the collection
  insertIntoUserOnboardingCollection(
    objects: [UserOnboardingInsertInput!]!
  ): UserOnboardingInsertResponse
  # Adds one or more `UserOnboardingStep` records to the collection
  insertIntoUserOnboardingStepCollection(
    objects: [UserOnboardingStepInsertInput!]!
  ): UserOnboardingStepInsertResponse
  # Adds one or more `UserPersona` records to the collection
  insertIntoUserPersonaCollection(
    objects: [UserPersonaInsertInput!]!
  ): UserPersonaInsertResponse
  # Adds one or more `UserProfile` records to the collection
  insertIntoUserProfileCollection(
    objects: [UserProfileInsertInput!]!
  ): UserProfileInsertResponse
  # Adds one or more `UserRole` records to the collection
  insertIntoUserRoleCollection(
    objects: [UserRoleInsertInput!]!
  ): UserRoleInsertResponse
  # Adds one or more `UserSurveyAnswer` records to the collection
  insertIntoUserSurveyAnswerCollection(
    objects: [UserSurveyAnswerInsertInput!]!
  ): UserSurveyAnswerInsertResponse
  # Adds one or more `UserSurvey` records to the collection
  insertIntoUserSurveyCollection(
    objects: [UserSurveyInsertInput!]!
  ): UserSurveyInsertResponse
  # Adds one or more `VectorDatabase` records to the collection
  insertIntoVectorDatabaseCollection(
    objects: [VectorDatabaseInsertInput!]!
  ): VectorDatabaseInsertResponse
  # Updates zero or more records in the `Agent` collection
  updateAgentCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AgentUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AgentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AgentUpdateResponse!
  # Updates zero or more records in the `AgentTool` collection
  updateAgentToolCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AgentToolUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AgentToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AgentToolUpdateResponse!
  # Updates zero or more records in the `AiConfig` collection
  updateAiConfigCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AiConfigUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AiConfigFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AiConfigUpdateResponse!
  # Updates zero or more records in the `AiConfigType` collection
  updateAiConfigTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AiConfigTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AiConfigTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AiConfigTypeUpdateResponse!
  # Updates zero or more records in the `AnswerChoice` collection
  updateAnswerChoiceCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AnswerChoiceUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AnswerChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AnswerChoiceUpdateResponse!
  # Updates zero or more records in the `ApiType` collection
  updateApiTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApiTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApiTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApiTypeUpdateResponse!
  # Updates zero or more records in the `ApplicationAgent` collection
  updateApplicationAgentCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationAgentUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationAgentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationAgentUpdateResponse!
  # Updates zero or more records in the `Application` collection
  updateApplicationCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationUpdateResponse!
  # Updates zero or more records in the `ApplicationTable` collection
  updateApplicationTableCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationTableUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationTableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationTableUpdateResponse!
  # Updates zero or more records in the `ApplicationTool` collection
  updateApplicationToolCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationToolUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationToolUpdateResponse!
  # Updates zero or more records in the `ApplicationType` collection
  updateApplicationTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationTypeUpdateResponse!
  # Updates zero or more records in the `ApplicationUser` collection
  updateApplicationUserCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationUserUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationUserFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationUserUpdateResponse!
  # Updates zero or more records in the `ApplicationUserRole` collection
  updateApplicationUserRoleCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ApplicationUserRoleUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ApplicationUserRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ApplicationUserRoleUpdateResponse!
  # Updates zero or more records in the `Asset` collection
  updateAssetCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AssetUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetUpdateResponse!
  # Updates zero or more records in the `AssetStatus` collection
  updateAssetStatusCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AssetStatusUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetStatusUpdateResponse!
  # Updates zero or more records in the `AssetType` collection
  updateAssetTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AssetTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetTypeUpdateResponse!
  # Updates zero or more records in the `AssetTypeMimeType` collection
  updateAssetTypeMimeTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: AssetTypeMimeTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: AssetTypeMimeTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): AssetTypeMimeTypeUpdateResponse!
  # Updates zero or more records in the `ChatMessage` collection
  updateChatMessageCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ChatMessageUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatMessageFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatMessageUpdateResponse!
  # Updates zero or more records in the `ChatRole` collection
  updateChatRoleCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ChatRoleUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatRoleUpdateResponse!
  # Updates zero or more records in the `ChatSession` collection
  updateChatSessionCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ChatSessionUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ChatSessionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ChatSessionUpdateResponse!
  # Updates zero or more records in the `Content` collection
  updateContentCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentUpdateResponse!
  # Updates zero or more records in the `ContentContentPart` collection
  updateContentContentPartCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentContentPartUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentContentPartUpdateResponse!
  # Updates zero or more records in the `ContentPart` collection
  updateContentPartCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentPartUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentPartUpdateResponse!
  # Updates zero or more records in the `ContentPartContentPart` collection
  updateContentPartContentPartCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentPartContentPartUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentPartContentPartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentPartContentPartUpdateResponse!
  # Updates zero or more records in the `ContentTemplate` collection
  updateContentTemplateCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentTemplateUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateUpdateResponse!
  # Updates zero or more records in the `ContentTemplateVariable` collection
  updateContentTemplateVariableCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentTemplateVariableUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateVariableUpdateResponse!
  # Updates zero or more records in the `ContentTemplateVariableValue` collection
  updateContentTemplateVariableValueCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentTemplateVariableValueUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTemplateVariableValueFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTemplateVariableValueUpdateResponse!
  # Updates zero or more records in the `ContentType` collection
  updateContentTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ContentTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ContentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ContentTypeUpdateResponse!
  # Updates zero or more records in the `CreationType` collection
  updateCreationTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: CreationTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: CreationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): CreationTypeUpdateResponse!
  # Updates zero or more records in the `Document` collection
  updateDocumentCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: DocumentUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentUpdateResponse!
  # Updates zero or more records in the `DocumentTemplate` collection
  updateDocumentTemplateCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: DocumentTemplateUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentTemplateUpdateResponse!
  # Updates zero or more records in the `DocumentType` collection
  updateDocumentTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: DocumentTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: DocumentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): DocumentTypeUpdateResponse!
  # Updates zero or more records in the `Feature` collection
  updateFeatureCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FeatureUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FeatureFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FeatureUpdateResponse!
  # Updates zero or more records in the `FirefighterStatus` collection
  updateFirefighterStatusCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FirefighterStatusUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FirefighterStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirefighterStatusUpdateResponse!
  # Updates zero or more records in the `FirstResponder` collection
  updateFirstResponderCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FirstResponderUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderUpdateResponse!
  # Updates zero or more records in the `FirstResponderStation` collection
  updateFirstResponderStationCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FirstResponderStationUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderStationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderStationUpdateResponse!
  # Updates zero or more records in the `FirstResponderType` collection
  updateFirstResponderTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FirstResponderTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FirstResponderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FirstResponderTypeUpdateResponse!
  # Updates zero or more records in the `Form` collection
  updateFormCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FormUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FormUpdateResponse!
  # Updates zero or more records in the `FormQuestion` collection
  updateFormQuestionCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: FormQuestionUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: FormQuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): FormQuestionUpdateResponse!
  # Updates zero or more records in the `HeroItem` collection
  updateHeroItemCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: HeroItemUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: HeroItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): HeroItemUpdateResponse!
  # Updates zero or more records in the `Menu` collection
  updateMenuCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: MenuUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuUpdateResponse!
  # Updates zero or more records in the `MenuItem` collection
  updateMenuItemCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: MenuItemUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuItemUpdateResponse!
  # Updates zero or more records in the `MenuType` collection
  updateMenuTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: MenuTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: MenuTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MenuTypeUpdateResponse!
  # Updates zero or more records in the `MimeType` collection
  updateMimeTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: MimeTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: MimeTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): MimeTypeUpdateResponse!
  # Updates zero or more records in the `Notification` collection
  updateNotificationCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: NotificationUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: NotificationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): NotificationUpdateResponse!
  # Updates zero or more records in the `NotificationType` collection
  updateNotificationTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: NotificationTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: NotificationTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): NotificationTypeUpdateResponse!
  # Updates zero or more records in the `Onboarding` collection
  updateOnboardingCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OnboardingUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingUpdateResponse!
  # Updates zero or more records in the `OnboardingForm` collection
  updateOnboardingFormCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OnboardingFormUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingFormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingFormUpdateResponse!
  # Updates zero or more records in the `OnboardingStep` collection
  updateOnboardingStepCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OnboardingStepUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingStepFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingStepUpdateResponse!
  # Updates zero or more records in the `OnboardingSurvey` collection
  updateOnboardingSurveyCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OnboardingSurveyUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingSurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingSurveyUpdateResponse!
  # Updates zero or more records in the `OnboardingType` collection
  updateOnboardingTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OnboardingTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OnboardingTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OnboardingTypeUpdateResponse!
  # Updates zero or more records in the `Order` collection
  updateOrderCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderUpdateResponse!
  # Updates zero or more records in the `OrderItem` collection
  updateOrderItemCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderItemUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderItemUpdateResponse!
  # Updates zero or more records in the `OrderItemMenuItem` collection
  updateOrderItemMenuItemCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderItemMenuItemUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderItemMenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderItemMenuItemUpdateResponse!
  # Updates zero or more records in the `OrderStatus` collection
  updateOrderStatusCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderStatusUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderStatusUpdateResponse!
  # Updates zero or more records in the `OrderTransaction` collection
  updateOrderTransactionCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderTransactionUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderTransactionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderTransactionUpdateResponse!
  # Updates zero or more records in the `OrderType` collection
  updateOrderTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: OrderTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: OrderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): OrderTypeUpdateResponse!
  # Updates zero or more records in the `Partner` collection
  updatePartnerCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PartnerUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PartnerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PartnerUpdateResponse!
  # Updates zero or more records in the `PartnerType` collection
  updatePartnerTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PartnerTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PartnerTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PartnerTypeUpdateResponse!
  # Updates zero or more records in the `PaymentInfo` collection
  updatePaymentInfoCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PaymentInfoUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PaymentInfoFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PaymentInfoUpdateResponse!
  # Updates zero or more records in the `PaymentType` collection
  updatePaymentTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PaymentTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PaymentTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PaymentTypeUpdateResponse!
  # Updates zero or more records in the `Persona` collection
  updatePersonaCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PersonaUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PersonaFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PersonaUpdateResponse!
  # Updates zero or more records in the `PersonaOnboarding` collection
  updatePersonaOnboardingCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PersonaOnboardingUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PersonaOnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PersonaOnboardingUpdateResponse!
  # Updates zero or more records in the `ProfileType` collection
  updateProfileTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ProfileTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ProfileTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProfileTypeUpdateResponse!
  # Updates zero or more records in the `Prompt` collection
  updatePromptCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PromptUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptUpdateResponse!
  # Updates zero or more records in the `PromptTemplate` collection
  updatePromptTemplateCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PromptTemplateUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptTemplateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptTemplateUpdateResponse!
  # Updates zero or more records in the `PromptTemplateVariable` collection
  updatePromptTemplateVariableCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PromptTemplateVariableUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PromptTemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PromptTemplateVariableUpdateResponse!
  # Updates zero or more records in the `Provider` collection
  updateProviderCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ProviderUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ProviderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProviderUpdateResponse!
  # Updates zero or more records in the `ProviderType` collection
  updateProviderTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ProviderTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ProviderTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ProviderTypeUpdateResponse!
  # Updates zero or more records in the `PublicationState` collection
  updatePublicationStateCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: PublicationStateUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: PublicationStateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): PublicationStateUpdateResponse!
  # Updates zero or more records in the `QuestionAnwserChoice` collection
  updateQuestionAnwserChoiceCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: QuestionAnwserChoiceUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionAnwserChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionAnwserChoiceUpdateResponse!
  # Updates zero or more records in the `Question` collection
  updateQuestionCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: QuestionUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionUpdateResponse!
  # Updates zero or more records in the `QuestionType` collection
  updateQuestionTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: QuestionTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: QuestionTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): QuestionTypeUpdateResponse!
  # Updates zero or more records in the `Role` collection
  updateRoleCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: RoleUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: RoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): RoleUpdateResponse!
  # Updates zero or more records in the `SchemaMigrations` collection
  updateSchemaMigrationsCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: SchemaMigrationsUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: SchemaMigrationsFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SchemaMigrationsUpdateResponse!
  # Updates zero or more records in the `Shift` collection
  updateShiftCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ShiftUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftUpdateResponse!
  # Updates zero or more records in the `ShiftScheduleStatus` collection
  updateShiftScheduleStatusCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ShiftScheduleStatusUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftScheduleStatusFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftScheduleStatusUpdateResponse!
  # Updates zero or more records in the `ShiftType` collection
  updateShiftTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ShiftTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ShiftTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShiftTypeUpdateResponse!
  # Updates zero or more records in the `ShoppingCart` collection
  updateShoppingCartCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ShoppingCartUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ShoppingCartFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShoppingCartUpdateResponse!
  # Updates zero or more records in the `ShoppingCartMenuItem` collection
  updateShoppingCartMenuItemCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ShoppingCartMenuItemUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ShoppingCartMenuItemFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ShoppingCartMenuItemUpdateResponse!
  # Updates zero or more records in the `Station` collection
  updateStationCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: StationUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: StationFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationUpdateResponse!
  # Updates zero or more records in the `StationPartner` collection
  updateStationPartnerCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: StationPartnerUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: StationPartnerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationPartnerUpdateResponse!
  # Updates zero or more records in the `StationProvider` collection
  updateStationProviderCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: StationProviderUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: StationProviderFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): StationProviderUpdateResponse!
  # Updates zero or more records in the `Survey` collection
  updateSurveyCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: SurveyUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: SurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SurveyUpdateResponse!
  # Updates zero or more records in the `SurveyQuestion` collection
  updateSurveyQuestionCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: SurveyQuestionUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: SurveyQuestionFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): SurveyQuestionUpdateResponse!
  # Updates zero or more records in the `TeamUpdate` collection
  updateTeamUpdateCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: TeamUpdateUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: TeamUpdateFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TeamUpdateUpdateResponse!
  # Updates zero or more records in the `TeamUpdateType` collection
  updateTeamUpdateTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: TeamUpdateTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: TeamUpdateTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TeamUpdateTypeUpdateResponse!
  # Updates zero or more records in the `TemplateVariable` collection
  updateTemplateVariableCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: TemplateVariableUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: TemplateVariableFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TemplateVariableUpdateResponse!
  # Updates zero or more records in the `TemplateVariableType` collection
  updateTemplateVariableTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: TemplateVariableTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: TemplateVariableTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TemplateVariableTypeUpdateResponse!
  # Updates zero or more records in the `Testimonial` collection
  updateTestimonialCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: TestimonialUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: TestimonialFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): TestimonialUpdateResponse!
  # Updates zero or more records in the `Tool` collection
  updateToolCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ToolUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ToolFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ToolUpdateResponse!
  # Updates zero or more records in the `ToolType` collection
  updateToolTypeCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: ToolTypeUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: ToolTypeFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): ToolTypeUpdateResponse!
  # Updates zero or more records in the `UserAnswerChoice` collection
  updateUserAnswerChoiceCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserAnswerChoiceUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserAnswerChoiceFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserAnswerChoiceUpdateResponse!
  # Updates zero or more records in the `User` collection
  updateUserCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserUpdateResponse!
  # Updates zero or more records in the `UserForm` collection
  updateUserFormCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserFormUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFormFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserFormUpdateResponse!
  # Updates zero or more records in the `UserFormQuestionAnswer` collection
  updateUserFormQuestionAnswerCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserFormQuestionAnswerUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserFormQuestionAnswerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserFormQuestionAnswerUpdateResponse!
  # Updates zero or more records in the `UserOnboarding` collection
  updateUserOnboardingCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserOnboardingUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserOnboardingFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserOnboardingUpdateResponse!
  # Updates zero or more records in the `UserOnboardingStep` collection
  updateUserOnboardingStepCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserOnboardingStepUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserOnboardingStepFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserOnboardingStepUpdateResponse!
  # Updates zero or more records in the `UserPersona` collection
  updateUserPersonaCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserPersonaUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserPersonaFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserPersonaUpdateResponse!
  # Updates zero or more records in the `UserProfile` collection
  updateUserProfileCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserProfileUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserProfileFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserProfileUpdateResponse!
  # Updates zero or more records in the `UserRole` collection
  updateUserRoleCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserRoleUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserRoleFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserRoleUpdateResponse!
  # Updates zero or more records in the `UserSurveyAnswer` collection
  updateUserSurveyAnswerCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserSurveyAnswerUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserSurveyAnswerFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserSurveyAnswerUpdateResponse!
  # Updates zero or more records in the `UserSurvey` collection
  updateUserSurveyCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: UserSurveyUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: UserSurveyFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): UserSurveyUpdateResponse!
  # Updates zero or more records in the `VectorDatabase` collection
  updateVectorDatabaseCollection(
    # Fields that are set will be updated for all records matching the `filter`
    set: VectorDatabaseUpdateInput!
    # Restricts the mutation's impact to records matching the criteria
    filter: VectorDatabaseFilter
    # The maximum number of records in the collection permitted to be affected
    atMost: Int! = 1
  ): VectorDatabaseUpdateResponse!
}

interface Node {
  # Retrieves a record by `ID`
  nodeId: ID!
}

type Notification implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  notificationTypeId: UUID!
  title: String!
  subtitle: String
  messageMarkdown: String!
  createdAt: Datetime!
  data: JSON
  userId: UUID
  isRead: Boolean!
  iconUrl: String
  applicationId: UUID!
  user: User
  notificationType: NotificationType!
  application: Application!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  pageInfo: PageInfo!
}

type NotificationDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Notification!]!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

input NotificationFilter {
  id: UUIDFilter
  notificationTypeId: UUIDFilter
  title: StringFilter
  subtitle: StringFilter
  messageMarkdown: StringFilter
  createdAt: DatetimeFilter
  userId: UUIDFilter
  isRead: BooleanFilter
  iconUrl: StringFilter
  applicationId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [NotificationFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [NotificationFilter!]
  # Negates a filter
  not: NotificationFilter
}

input NotificationInsertInput {
  id: UUID
  notificationTypeId: UUID
  title: String
  subtitle: String
  messageMarkdown: String
  createdAt: Datetime
  data: JSON
  userId: UUID
  isRead: Boolean
  iconUrl: String
  applicationId: UUID
}

type NotificationInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Notification!]!
}

input NotificationOrderBy {
  id: OrderByDirection
  notificationTypeId: OrderByDirection
  title: OrderByDirection
  subtitle: OrderByDirection
  messageMarkdown: OrderByDirection
  createdAt: OrderByDirection
  userId: OrderByDirection
  isRead: OrderByDirection
  iconUrl: OrderByDirection
  applicationId: OrderByDirection
}

type NotificationType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  iconUrl: String
  notificationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: NotificationFilter
    # Sort order to apply to the collection
    orderBy: [NotificationOrderBy!]
  ): NotificationConnection
}

type NotificationTypeConnection {
  edges: [NotificationTypeEdge!]!
  pageInfo: PageInfo!
}

type NotificationTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [NotificationType!]!
}

type NotificationTypeEdge {
  cursor: String!
  node: NotificationType!
}

input NotificationTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  iconUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [NotificationTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [NotificationTypeFilter!]
  # Negates a filter
  not: NotificationTypeFilter
}

input NotificationTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
  iconUrl: String
}

type NotificationTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [NotificationType!]!
}

input NotificationTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
  iconUrl: OrderByDirection
}

input NotificationTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
  iconUrl: String
}

type NotificationTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [NotificationType!]!
}

input NotificationUpdateInput {
  id: UUID
  notificationTypeId: UUID
  title: String
  subtitle: String
  messageMarkdown: String
  createdAt: Datetime
  data: JSON
  userId: UUID
  isRead: Boolean
  iconUrl: String
  applicationId: UUID
}

type NotificationUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Notification!]!
}

type Onboarding implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  onboardingTypeId: UUID!
  applicationId: UUID
  name: String!
  description: String
  createdAt: Datetime!
  data: JSON
  onboardingType: OnboardingType!
  application: Application
  personaOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PersonaOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [PersonaOnboardingOrderBy!]
  ): PersonaOnboardingConnection
  onboardingSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingSurveyFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingSurveyOrderBy!]
  ): OnboardingSurveyConnection
  onboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingStepOrderBy!]
  ): OnboardingStepConnection
  userOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingOrderBy!]
  ): UserOnboardingConnection
  onboardingFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFormFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingFormOrderBy!]
  ): OnboardingFormConnection
}

type OnboardingConnection {
  edges: [OnboardingEdge!]!
  pageInfo: PageInfo!
}

type OnboardingDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Onboarding!]!
}

type OnboardingEdge {
  cursor: String!
  node: Onboarding!
}

input OnboardingFilter {
  id: UUIDFilter
  onboardingTypeId: UUIDFilter
  applicationId: UUIDFilter
  name: StringFilter
  description: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OnboardingFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OnboardingFilter!]
  # Negates a filter
  not: OnboardingFilter
}

type OnboardingForm implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  onboardingId: UUID!
  formId: UUID!
  data: JSON
  createdAt: Datetime!
  isRequired: Boolean!
  onboarding: Onboarding!
  form: Form!
}

type OnboardingFormConnection {
  edges: [OnboardingFormEdge!]!
  pageInfo: PageInfo!
}

type OnboardingFormDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingForm!]!
}

type OnboardingFormEdge {
  cursor: String!
  node: OnboardingForm!
}

input OnboardingFormFilter {
  id: UUIDFilter
  onboardingId: UUIDFilter
  formId: UUIDFilter
  createdAt: DatetimeFilter
  isRequired: BooleanFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OnboardingFormFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OnboardingFormFilter!]
  # Negates a filter
  not: OnboardingFormFilter
}

input OnboardingFormInsertInput {
  id: UUID
  onboardingId: UUID
  formId: UUID
  data: JSON
  createdAt: Datetime
  isRequired: Boolean
}

type OnboardingFormInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingForm!]!
}

input OnboardingFormOrderBy {
  id: OrderByDirection
  onboardingId: OrderByDirection
  formId: OrderByDirection
  createdAt: OrderByDirection
  isRequired: OrderByDirection
}

input OnboardingFormUpdateInput {
  id: UUID
  onboardingId: UUID
  formId: UUID
  data: JSON
  createdAt: Datetime
  isRequired: Boolean
}

type OnboardingFormUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingForm!]!
}

input OnboardingInsertInput {
  id: UUID
  onboardingTypeId: UUID
  applicationId: UUID
  name: String
  description: String
  createdAt: Datetime
  data: JSON
}

type OnboardingInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Onboarding!]!
}

input OnboardingOrderBy {
  id: OrderByDirection
  onboardingTypeId: OrderByDirection
  applicationId: OrderByDirection
  name: OrderByDirection
  description: OrderByDirection
  createdAt: OrderByDirection
}

type OnboardingStep implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  index: Int!
  createdAt: Datetime!
  data: JSON
  description: String
  formId: UUID
  surveyId: UUID
  onboardingId: UUID!
  survey: Survey
  onboarding: Onboarding!
  form: Form
  userOnboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingStepOrderBy!]
  ): UserOnboardingStepConnection
}

type OnboardingStepConnection {
  edges: [OnboardingStepEdge!]!
  pageInfo: PageInfo!
}

type OnboardingStepDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingStep!]!
}

type OnboardingStepEdge {
  cursor: String!
  node: OnboardingStep!
}

input OnboardingStepFilter {
  id: UUIDFilter
  name: StringFilter
  index: IntFilter
  createdAt: DatetimeFilter
  description: StringFilter
  formId: UUIDFilter
  surveyId: UUIDFilter
  onboardingId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OnboardingStepFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OnboardingStepFilter!]
  # Negates a filter
  not: OnboardingStepFilter
}

input OnboardingStepInsertInput {
  id: UUID
  name: String
  index: Int
  createdAt: Datetime
  data: JSON
  description: String
  formId: UUID
  surveyId: UUID
  onboardingId: UUID
}

type OnboardingStepInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingStep!]!
}

input OnboardingStepOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  index: OrderByDirection
  createdAt: OrderByDirection
  description: OrderByDirection
  formId: OrderByDirection
  surveyId: OrderByDirection
  onboardingId: OrderByDirection
}

input OnboardingStepUpdateInput {
  id: UUID
  name: String
  index: Int
  createdAt: Datetime
  data: JSON
  description: String
  formId: UUID
  surveyId: UUID
  onboardingId: UUID
}

type OnboardingStepUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingStep!]!
}

type OnboardingSurvey implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  surveyId: UUID!
  isRequired: Boolean!
  data: JSON
  onboardingId: UUID!
  survey: Survey
  onboarding: Onboarding!
}

type OnboardingSurveyConnection {
  edges: [OnboardingSurveyEdge!]!
  pageInfo: PageInfo!
}

type OnboardingSurveyDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingSurvey!]!
}

type OnboardingSurveyEdge {
  cursor: String!
  node: OnboardingSurvey!
}

input OnboardingSurveyFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  surveyId: UUIDFilter
  isRequired: BooleanFilter
  onboardingId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OnboardingSurveyFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OnboardingSurveyFilter!]
  # Negates a filter
  not: OnboardingSurveyFilter
}

input OnboardingSurveyInsertInput {
  id: UUID
  createdAt: Datetime
  surveyId: UUID
  isRequired: Boolean
  data: JSON
  onboardingId: UUID
}

type OnboardingSurveyInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingSurvey!]!
}

input OnboardingSurveyOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  surveyId: OrderByDirection
  isRequired: OrderByDirection
  onboardingId: OrderByDirection
}

input OnboardingSurveyUpdateInput {
  id: UUID
  createdAt: Datetime
  surveyId: UUID
  isRequired: Boolean
  data: JSON
  onboardingId: UUID
}

type OnboardingSurveyUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingSurvey!]!
}

type OnboardingType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  description: String
  longDescriptionMarkdown: String
  createdAt: Datetime!
  onboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingOrderBy!]
  ): OnboardingConnection
}

type OnboardingTypeConnection {
  edges: [OnboardingTypeEdge!]!
  pageInfo: PageInfo!
}

type OnboardingTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingType!]!
}

type OnboardingTypeEdge {
  cursor: String!
  node: OnboardingType!
}

input OnboardingTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OnboardingTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OnboardingTypeFilter!]
  # Negates a filter
  not: OnboardingTypeFilter
}

input OnboardingTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  description: String
  longDescriptionMarkdown: String
  createdAt: Datetime
}

type OnboardingTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingType!]!
}

input OnboardingTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
}

input OnboardingTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  description: String
  longDescriptionMarkdown: String
  createdAt: Datetime
}

type OnboardingTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OnboardingType!]!
}

input OnboardingUpdateInput {
  id: UUID
  onboardingTypeId: UUID
  applicationId: UUID
  name: String
  description: String
  createdAt: Datetime
  data: JSON
}

type OnboardingUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Onboarding!]!
}

# Any type not handled by the type system
scalar Opaque

# Boolean expression comparing fields on type "Opaque"
input OpaqueFilter {
  eq: Opaque
  is: FilterIs
}

type Order implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  orderTypeId: UUID!
  userId: UUID!
  createdAt: Datetime!
  units: BigInt!
  pricePerUnit: Float!
  notes: String
  data: JSON
  updatedAt: Datetime
  orderStatusId: UUID!
  stationId: UUID!
  paymentInfoId: UUID
  isPaid: Boolean!
  paymentInfo: PaymentInfo
  station: Station!
  user: User
  orderType: OrderType!
  orderStatus: OrderStatus!
  orderTransactionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderTransactionFilter
    # Sort order to apply to the collection
    orderBy: [OrderTransactionOrderBy!]
  ): OrderTransactionConnection
  orderItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderItemFilter
    # Sort order to apply to the collection
    orderBy: [OrderItemOrderBy!]
  ): OrderItemConnection
  shoppingCartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartOrderBy!]
  ): ShoppingCartConnection
}

# Defines a per-field sorting order
enum OrderByDirection {
  # Ascending order, nulls first
  AscNullsFirst
  # Ascending order, nulls last
  AscNullsLast
  # Descending order, nulls first
  DescNullsFirst
  # Descending order, nulls last
  DescNullsLast
}

type OrderConnection {
  edges: [OrderEdge!]!
  pageInfo: PageInfo!
}

type OrderDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Order!]!
}

type OrderEdge {
  cursor: String!
  node: Order!
}

input OrderFilter {
  id: UUIDFilter
  orderTypeId: UUIDFilter
  userId: UUIDFilter
  createdAt: DatetimeFilter
  units: BigIntFilter
  pricePerUnit: FloatFilter
  notes: StringFilter
  updatedAt: DatetimeFilter
  orderStatusId: UUIDFilter
  stationId: UUIDFilter
  paymentInfoId: UUIDFilter
  isPaid: BooleanFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderFilter!]
  # Negates a filter
  not: OrderFilter
}

input OrderInsertInput {
  id: UUID
  orderTypeId: UUID
  userId: UUID
  createdAt: Datetime
  units: BigInt
  pricePerUnit: Float
  notes: String
  data: JSON
  updatedAt: Datetime
  orderStatusId: UUID
  stationId: UUID
  paymentInfoId: UUID
  isPaid: Boolean
}

type OrderInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Order!]!
}

type OrderItem implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  orderId: UUID!
  createdAt: Datetime!
  name: String!
  pricePerUnit: Float!
  units: BigInt!
  updatedAt: Datetime
  order: Order!
  orderItemMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderItemMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [OrderItemMenuItemOrderBy!]
  ): OrderItemMenuItemConnection
}

type OrderItemConnection {
  edges: [OrderItemEdge!]!
  pageInfo: PageInfo!
}

type OrderItemDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItem!]!
}

type OrderItemEdge {
  cursor: String!
  node: OrderItem!
}

input OrderItemFilter {
  id: UUIDFilter
  orderId: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  pricePerUnit: FloatFilter
  units: BigIntFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderItemFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderItemFilter!]
  # Negates a filter
  not: OrderItemFilter
}

input OrderItemInsertInput {
  id: UUID
  orderId: UUID
  createdAt: Datetime
  name: String
  pricePerUnit: Float
  units: BigInt
  updatedAt: Datetime
}

type OrderItemInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItem!]!
}

type OrderItemMenuItem implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  orderItemId: UUID!
  createdAt: Datetime!
  menuItemId: UUID!
  notes: String
  orderItem: OrderItem!
  menuItem: MenuItem!
}

type OrderItemMenuItemConnection {
  edges: [OrderItemMenuItemEdge!]!
  pageInfo: PageInfo!
}

type OrderItemMenuItemDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItemMenuItem!]!
}

type OrderItemMenuItemEdge {
  cursor: String!
  node: OrderItemMenuItem!
}

input OrderItemMenuItemFilter {
  id: UUIDFilter
  orderItemId: UUIDFilter
  createdAt: DatetimeFilter
  menuItemId: UUIDFilter
  notes: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderItemMenuItemFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderItemMenuItemFilter!]
  # Negates a filter
  not: OrderItemMenuItemFilter
}

input OrderItemMenuItemInsertInput {
  id: UUID
  orderItemId: UUID
  createdAt: Datetime
  menuItemId: UUID
  notes: String
}

type OrderItemMenuItemInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItemMenuItem!]!
}

input OrderItemMenuItemOrderBy {
  id: OrderByDirection
  orderItemId: OrderByDirection
  createdAt: OrderByDirection
  menuItemId: OrderByDirection
  notes: OrderByDirection
}

input OrderItemMenuItemUpdateInput {
  id: UUID
  orderItemId: UUID
  createdAt: Datetime
  menuItemId: UUID
  notes: String
}

type OrderItemMenuItemUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItemMenuItem!]!
}

input OrderItemOrderBy {
  id: OrderByDirection
  orderId: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  pricePerUnit: OrderByDirection
  units: OrderByDirection
  updatedAt: OrderByDirection
}

input OrderItemUpdateInput {
  id: UUID
  orderId: UUID
  createdAt: Datetime
  name: String
  pricePerUnit: Float
  units: BigInt
  updatedAt: Datetime
}

type OrderItemUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderItem!]!
}

input OrderOrderBy {
  id: OrderByDirection
  orderTypeId: OrderByDirection
  userId: OrderByDirection
  createdAt: OrderByDirection
  units: OrderByDirection
  pricePerUnit: OrderByDirection
  notes: OrderByDirection
  updatedAt: OrderByDirection
  orderStatusId: OrderByDirection
  stationId: OrderByDirection
  paymentInfoId: OrderByDirection
  isPaid: OrderByDirection
}

type OrderStatus implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  createdAt: Datetime!
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
}

type OrderStatusConnection {
  edges: [OrderStatusEdge!]!
  pageInfo: PageInfo!
}

type OrderStatusDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderStatus!]!
}

type OrderStatusEdge {
  cursor: String!
  node: OrderStatus!
}

input OrderStatusFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderStatusFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderStatusFilter!]
  # Negates a filter
  not: OrderStatusFilter
}

input OrderStatusInsertInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type OrderStatusInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderStatus!]!
}

input OrderStatusOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input OrderStatusUpdateInput {
  id: UUID
  name: String
  key: String
  createdAt: Datetime
}

type OrderStatusUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderStatus!]!
}

type OrderTransaction implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  orderId: UUID!
  paymentInfoId: UUID!
  amount: Float!
  payerTransactionId: String
  createdAt: Datetime!
  paymentInfo: PaymentInfo!
  order: Order!
}

type OrderTransactionConnection {
  edges: [OrderTransactionEdge!]!
  pageInfo: PageInfo!
}

type OrderTransactionDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderTransaction!]!
}

type OrderTransactionEdge {
  cursor: String!
  node: OrderTransaction!
}

input OrderTransactionFilter {
  id: UUIDFilter
  orderId: UUIDFilter
  paymentInfoId: UUIDFilter
  amount: FloatFilter
  payerTransactionId: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderTransactionFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderTransactionFilter!]
  # Negates a filter
  not: OrderTransactionFilter
}

input OrderTransactionInsertInput {
  id: UUID
  orderId: UUID
  paymentInfoId: UUID
  amount: Float
  payerTransactionId: String
  createdAt: Datetime
}

type OrderTransactionInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderTransaction!]!
}

input OrderTransactionOrderBy {
  id: OrderByDirection
  orderId: OrderByDirection
  paymentInfoId: OrderByDirection
  amount: OrderByDirection
  payerTransactionId: OrderByDirection
  createdAt: OrderByDirection
}

input OrderTransactionUpdateInput {
  id: UUID
  orderId: UUID
  paymentInfoId: UUID
  amount: Float
  payerTransactionId: String
  createdAt: Datetime
}

type OrderTransactionUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderTransaction!]!
}

type OrderType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  name: String!
  key: String!
  schema: JSON
  description: String
  iconUrl: String
  coverUrl: String
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
}

type OrderTypeConnection {
  edges: [OrderTypeEdge!]!
  pageInfo: PageInfo!
}

type OrderTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderType!]!
}

type OrderTypeEdge {
  cursor: String!
  node: OrderType!
}

input OrderTypeFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [OrderTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [OrderTypeFilter!]
  # Negates a filter
  not: OrderTypeFilter
}

input OrderTypeInsertInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
  schema: JSON
  description: String
  iconUrl: String
  coverUrl: String
}

type OrderTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderType!]!
}

input OrderTypeOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
}

input OrderTypeUpdateInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
  schema: JSON
  description: String
  iconUrl: String
  coverUrl: String
}

type OrderTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [OrderType!]!
}

input OrderUpdateInput {
  id: UUID
  orderTypeId: UUID
  userId: UUID
  createdAt: Datetime
  units: BigInt
  pricePerUnit: Float
  notes: String
  data: JSON
  updatedAt: Datetime
  orderStatusId: UUID
  stationId: UUID
  paymentInfoId: UUID
  isPaid: Boolean
}

type OrderUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Order!]!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Partner implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  partnerTypeId: UUID!
  name: String!
  iconUrl: String
  coverUrl: String
  createdAt: Datetime!
  description: String
  longDescriptionMarkdown: String
  data: JSON
  updatedAt: Datetime
  webSiteUrl: String
  phone: String
  partnerType: PartnerType
  stationPartnerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationPartnerFilter
    # Sort order to apply to the collection
    orderBy: [StationPartnerOrderBy!]
  ): StationPartnerConnection
}

type PartnerConnection {
  edges: [PartnerEdge!]!
  pageInfo: PageInfo!
}

type PartnerDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Partner!]!
}

type PartnerEdge {
  cursor: String!
  node: Partner!
}

input PartnerFilter {
  id: UUIDFilter
  partnerTypeId: UUIDFilter
  name: StringFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  createdAt: DatetimeFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  updatedAt: DatetimeFilter
  webSiteUrl: StringFilter
  phone: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PartnerFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PartnerFilter!]
  # Negates a filter
  not: PartnerFilter
}

input PartnerInsertInput {
  id: UUID
  partnerTypeId: UUID
  name: String
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
  description: String
  longDescriptionMarkdown: String
  data: JSON
  updatedAt: Datetime
  webSiteUrl: String
  phone: String
}

type PartnerInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Partner!]!
}

input PartnerOrderBy {
  id: OrderByDirection
  partnerTypeId: OrderByDirection
  name: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
  createdAt: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  updatedAt: OrderByDirection
  webSiteUrl: OrderByDirection
  phone: OrderByDirection
}

type PartnerType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime!
  partnerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PartnerFilter
    # Sort order to apply to the collection
    orderBy: [PartnerOrderBy!]
  ): PartnerConnection
}

type PartnerTypeConnection {
  edges: [PartnerTypeEdge!]!
  pageInfo: PageInfo!
}

type PartnerTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PartnerType!]!
}

type PartnerTypeEdge {
  cursor: String!
  node: PartnerType!
}

input PartnerTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PartnerTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PartnerTypeFilter!]
  # Negates a filter
  not: PartnerTypeFilter
}

input PartnerTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime
}

type PartnerTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PartnerType!]!
}

input PartnerTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
}

input PartnerTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime
}

type PartnerTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PartnerType!]!
}

input PartnerUpdateInput {
  id: UUID
  partnerTypeId: UUID
  name: String
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
  description: String
  longDescriptionMarkdown: String
  data: JSON
  updatedAt: Datetime
  webSiteUrl: String
  phone: String
}

type PartnerUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Partner!]!
}

type PaymentInfo implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  paymentTypeId: UUID!
  name: String!
  data: JSON
  createdAt: Datetime!
  userId: UUID!
  user: User
  paymentType: PaymentType!
  orderTransactionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderTransactionFilter
    # Sort order to apply to the collection
    orderBy: [OrderTransactionOrderBy!]
  ): OrderTransactionConnection
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
}

type PaymentInfoConnection {
  edges: [PaymentInfoEdge!]!
  pageInfo: PageInfo!
}

type PaymentInfoDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentInfo!]!
}

type PaymentInfoEdge {
  cursor: String!
  node: PaymentInfo!
}

input PaymentInfoFilter {
  id: UUIDFilter
  paymentTypeId: UUIDFilter
  name: StringFilter
  createdAt: DatetimeFilter
  userId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PaymentInfoFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PaymentInfoFilter!]
  # Negates a filter
  not: PaymentInfoFilter
}

input PaymentInfoInsertInput {
  id: UUID
  paymentTypeId: UUID
  name: String
  data: JSON
  createdAt: Datetime
  userId: UUID
}

type PaymentInfoInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentInfo!]!
}

input PaymentInfoOrderBy {
  id: OrderByDirection
  paymentTypeId: OrderByDirection
  name: OrderByDirection
  createdAt: OrderByDirection
  userId: OrderByDirection
}

input PaymentInfoUpdateInput {
  id: UUID
  paymentTypeId: UUID
  name: String
  data: JSON
  createdAt: Datetime
  userId: UUID
}

type PaymentInfoUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentInfo!]!
}

type PaymentType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  paymentInfoCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PaymentInfoFilter
    # Sort order to apply to the collection
    orderBy: [PaymentInfoOrderBy!]
  ): PaymentInfoConnection
}

type PaymentTypeConnection {
  edges: [PaymentTypeEdge!]!
  pageInfo: PageInfo!
}

type PaymentTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentType!]!
}

type PaymentTypeEdge {
  cursor: String!
  node: PaymentType!
}

input PaymentTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PaymentTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PaymentTypeFilter!]
  # Negates a filter
  not: PaymentTypeFilter
}

input PaymentTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type PaymentTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentType!]!
}

input PaymentTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input PaymentTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type PaymentTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PaymentType!]!
}

type Persona implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime!
  applicationId: UUID!
  schema: JSON
  iconUrl: String
  coverUrl: String
  application: Application!
  personaOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PersonaOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [PersonaOnboardingOrderBy!]
  ): PersonaOnboardingConnection
  profileTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ProfileTypeFilter
    # Sort order to apply to the collection
    orderBy: [ProfileTypeOrderBy!]
  ): ProfileTypeConnection
  userPersonaCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserPersonaFilter
    # Sort order to apply to the collection
    orderBy: [UserPersonaOrderBy!]
  ): UserPersonaConnection
}

type PersonaConnection {
  edges: [PersonaEdge!]!
  pageInfo: PageInfo!
}

type PersonaDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Persona!]!
}

type PersonaEdge {
  cursor: String!
  node: Persona!
}

input PersonaFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  applicationId: UUIDFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PersonaFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PersonaFilter!]
  # Negates a filter
  not: PersonaFilter
}

input PersonaInsertInput {
  id: UUID
  name: String
  key: String
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime
  applicationId: UUID
  schema: JSON
  iconUrl: String
  coverUrl: String
}

type PersonaInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Persona!]!
}

type PersonaOnboarding implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  personaId: UUID!
  onboardingId: UUID!
  index: Int!
  isRequired: Boolean!
  createdAt: Datetime!
  persona: Persona!
  onboarding: Onboarding!
}

type PersonaOnboardingConnection {
  edges: [PersonaOnboardingEdge!]!
  pageInfo: PageInfo!
}

type PersonaOnboardingDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PersonaOnboarding!]!
}

type PersonaOnboardingEdge {
  cursor: String!
  node: PersonaOnboarding!
}

input PersonaOnboardingFilter {
  id: UUIDFilter
  personaId: UUIDFilter
  onboardingId: UUIDFilter
  index: IntFilter
  isRequired: BooleanFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PersonaOnboardingFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PersonaOnboardingFilter!]
  # Negates a filter
  not: PersonaOnboardingFilter
}

input PersonaOnboardingInsertInput {
  id: UUID
  personaId: UUID
  onboardingId: UUID
  index: Int
  isRequired: Boolean
  createdAt: Datetime
}

type PersonaOnboardingInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PersonaOnboarding!]!
}

input PersonaOnboardingOrderBy {
  id: OrderByDirection
  personaId: OrderByDirection
  onboardingId: OrderByDirection
  index: OrderByDirection
  isRequired: OrderByDirection
  createdAt: OrderByDirection
}

input PersonaOnboardingUpdateInput {
  id: UUID
  personaId: UUID
  onboardingId: UUID
  index: Int
  isRequired: Boolean
  createdAt: Datetime
}

type PersonaOnboardingUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PersonaOnboarding!]!
}

input PersonaOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
  applicationId: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
}

input PersonaUpdateInput {
  id: UUID
  name: String
  key: String
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime
  applicationId: UUID
  schema: JSON
  iconUrl: String
  coverUrl: String
}

type PersonaUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Persona!]!
}

type ProfileType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  personaId: UUID!
  name: String!
  key: String!
  shortDescription: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime!
  persona: Persona!
  userProfileCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserProfileFilter
    # Sort order to apply to the collection
    orderBy: [UserProfileOrderBy!]
  ): UserProfileConnection
}

type ProfileTypeConnection {
  edges: [ProfileTypeEdge!]!
  pageInfo: PageInfo!
}

type ProfileTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProfileType!]!
}

type ProfileTypeEdge {
  cursor: String!
  node: ProfileType!
}

input ProfileTypeFilter {
  id: UUIDFilter
  personaId: UUIDFilter
  name: StringFilter
  key: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ProfileTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ProfileTypeFilter!]
  # Negates a filter
  not: ProfileTypeFilter
}

input ProfileTypeInsertInput {
  id: UUID
  personaId: UUID
  name: String
  key: String
  shortDescription: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime
}

type ProfileTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProfileType!]!
}

input ProfileTypeOrderBy {
  id: OrderByDirection
  personaId: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
}

input ProfileTypeUpdateInput {
  id: UUID
  personaId: UUID
  name: String
  key: String
  shortDescription: String
  longDescriptionMarkdown: String
  schema: JSON
  createdAt: Datetime
}

type ProfileTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProfileType!]!
}

type Prompt implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  promptTemplateId: UUID
  createdAt: Datetime!
  content: String!
  updatedAt: Datetime
  ownerId: UUID
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
}

type PromptConnection {
  edges: [PromptEdge!]!
  pageInfo: PageInfo!
}

type PromptDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Prompt!]!
}

type PromptEdge {
  cursor: String!
  node: Prompt!
}

input PromptFilter {
  id: UUIDFilter
  promptTemplateId: UUIDFilter
  createdAt: DatetimeFilter
  content: StringFilter
  updatedAt: DatetimeFilter
  ownerId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PromptFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PromptFilter!]
  # Negates a filter
  not: PromptFilter
}

input PromptInsertInput {
  id: UUID
  promptTemplateId: UUID
  createdAt: Datetime
  content: String
  updatedAt: Datetime
  ownerId: UUID
}

type PromptInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Prompt!]!
}

input PromptOrderBy {
  id: OrderByDirection
  promptTemplateId: OrderByDirection
  createdAt: OrderByDirection
  content: OrderByDirection
  updatedAt: OrderByDirection
  ownerId: OrderByDirection
}

type PromptTemplate implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  roleId: UUID
  content: String!
  ownerId: UUID
  createdAt: Datetime!
  updatedAt: Datetime
}

type PromptTemplateConnection {
  edges: [PromptTemplateEdge!]!
  pageInfo: PageInfo!
}

type PromptTemplateDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplate!]!
}

type PromptTemplateEdge {
  cursor: String!
  node: PromptTemplate!
}

input PromptTemplateFilter {
  id: UUIDFilter
  roleId: UUIDFilter
  content: StringFilter
  ownerId: UUIDFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PromptTemplateFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PromptTemplateFilter!]
  # Negates a filter
  not: PromptTemplateFilter
}

input PromptTemplateInsertInput {
  id: UUID
  roleId: UUID
  content: String
  ownerId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

type PromptTemplateInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplate!]!
}

input PromptTemplateOrderBy {
  id: OrderByDirection
  roleId: OrderByDirection
  content: OrderByDirection
  ownerId: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input PromptTemplateUpdateInput {
  id: UUID
  roleId: UUID
  content: String
  ownerId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

type PromptTemplateUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplate!]!
}

type PromptTemplateVariable implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  templateVariableId: UUID!
  promptTemplateId: UUID!
  createdAt: Datetime!
}

type PromptTemplateVariableConnection {
  edges: [PromptTemplateVariableEdge!]!
  pageInfo: PageInfo!
}

type PromptTemplateVariableDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplateVariable!]!
}

type PromptTemplateVariableEdge {
  cursor: String!
  node: PromptTemplateVariable!
}

input PromptTemplateVariableFilter {
  id: UUIDFilter
  templateVariableId: UUIDFilter
  promptTemplateId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PromptTemplateVariableFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PromptTemplateVariableFilter!]
  # Negates a filter
  not: PromptTemplateVariableFilter
}

input PromptTemplateVariableInsertInput {
  id: UUID
  templateVariableId: UUID
  promptTemplateId: UUID
  createdAt: Datetime
}

type PromptTemplateVariableInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplateVariable!]!
}

input PromptTemplateVariableOrderBy {
  id: OrderByDirection
  templateVariableId: OrderByDirection
  promptTemplateId: OrderByDirection
  createdAt: OrderByDirection
}

input PromptTemplateVariableUpdateInput {
  id: UUID
  templateVariableId: UUID
  promptTemplateId: UUID
  createdAt: Datetime
}

type PromptTemplateVariableUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PromptTemplateVariable!]!
}

input PromptUpdateInput {
  id: UUID
  promptTemplateId: UUID
  createdAt: Datetime
  content: String
  updatedAt: Datetime
  ownerId: UUID
}

type PromptUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Prompt!]!
}

type Provider implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  providerTypeId: UUID!
  name: String!
  description: String
  longDescriptionMarkdown: String
  iconUrl: String
  coverUrl: String
  createdAt: Datetime!
  siteUrl: String
  updatedAt: Datetime
  data: JSON
  providerType: ProviderType!
  stationProviderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationProviderFilter
    # Sort order to apply to the collection
    orderBy: [StationProviderOrderBy!]
  ): StationProviderConnection
  menuCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuFilter
    # Sort order to apply to the collection
    orderBy: [MenuOrderBy!]
  ): MenuConnection
}

type ProviderConnection {
  edges: [ProviderEdge!]!
  pageInfo: PageInfo!
}

type ProviderDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Provider!]!
}

type ProviderEdge {
  cursor: String!
  node: Provider!
}

input ProviderFilter {
  id: UUIDFilter
  providerTypeId: UUIDFilter
  name: StringFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  createdAt: DatetimeFilter
  siteUrl: StringFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ProviderFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ProviderFilter!]
  # Negates a filter
  not: ProviderFilter
}

input ProviderInsertInput {
  id: UUID
  providerTypeId: UUID
  name: String
  description: String
  longDescriptionMarkdown: String
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
  siteUrl: String
  updatedAt: Datetime
  data: JSON
}

type ProviderInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Provider!]!
}

input ProviderOrderBy {
  id: OrderByDirection
  providerTypeId: OrderByDirection
  name: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
  createdAt: OrderByDirection
  siteUrl: OrderByDirection
  updatedAt: OrderByDirection
}

type ProviderType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  description: String
  schema: JSON
  iconUrl: String
  coverUrl: String
  createdAt: Datetime!
  providerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ProviderFilter
    # Sort order to apply to the collection
    orderBy: [ProviderOrderBy!]
  ): ProviderConnection
}

type ProviderTypeConnection {
  edges: [ProviderTypeEdge!]!
  pageInfo: PageInfo!
}

type ProviderTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProviderType!]!
}

type ProviderTypeEdge {
  cursor: String!
  node: ProviderType!
}

input ProviderTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  description: StringFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ProviderTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ProviderTypeFilter!]
  # Negates a filter
  not: ProviderTypeFilter
}

input ProviderTypeInsertInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
}

type ProviderTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProviderType!]!
}

input ProviderTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  description: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
  createdAt: OrderByDirection
}

input ProviderTypeUpdateInput {
  id: UUID
  name: String
  key: String
  description: String
  schema: JSON
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
}

type ProviderTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ProviderType!]!
}

input ProviderUpdateInput {
  id: UUID
  providerTypeId: UUID
  name: String
  description: String
  longDescriptionMarkdown: String
  iconUrl: String
  coverUrl: String
  createdAt: Datetime
  siteUrl: String
  updatedAt: Datetime
  data: JSON
}

type ProviderUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Provider!]!
}

type PublicationState implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  name: String!
  key: String!
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
}

type PublicationStateConnection {
  edges: [PublicationStateEdge!]!
  pageInfo: PageInfo!
}

type PublicationStateDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PublicationState!]!
}

type PublicationStateEdge {
  cursor: String!
  node: PublicationState!
}

input PublicationStateFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  key: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [PublicationStateFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [PublicationStateFilter!]
  # Negates a filter
  not: PublicationStateFilter
}

input PublicationStateInsertInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
}

type PublicationStateInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PublicationState!]!
}

input PublicationStateOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
}

input PublicationStateUpdateInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
}

type PublicationStateUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [PublicationState!]!
}

# The root type for querying data
type Query {
  # A pagable collection of type `Agent`
  agentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AgentFilter
    # Sort order to apply to the collection
    orderBy: [AgentOrderBy!]
  ): AgentConnection
  # A pagable collection of type `AgentTool`
  agentToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AgentToolFilter
    # Sort order to apply to the collection
    orderBy: [AgentToolOrderBy!]
  ): AgentToolConnection
  # A pagable collection of type `AiConfig`
  aiConfigCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AiConfigFilter
    # Sort order to apply to the collection
    orderBy: [AiConfigOrderBy!]
  ): AiConfigConnection
  # A pagable collection of type `AiConfigType`
  aiConfigTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AiConfigTypeFilter
    # Sort order to apply to the collection
    orderBy: [AiConfigTypeOrderBy!]
  ): AiConfigTypeConnection
  # A pagable collection of type `AnswerChoice`
  answerChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AnswerChoiceFilter
    # Sort order to apply to the collection
    orderBy: [AnswerChoiceOrderBy!]
  ): AnswerChoiceConnection
  # A pagable collection of type `ApiType`
  apiTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApiTypeFilter
    # Sort order to apply to the collection
    orderBy: [ApiTypeOrderBy!]
  ): ApiTypeConnection
  # A pagable collection of type `ApplicationAgent`
  applicationAgentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationAgentFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationAgentOrderBy!]
  ): ApplicationAgentConnection
  # A pagable collection of type `Application`
  applicationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationOrderBy!]
  ): ApplicationConnection
  # A pagable collection of type `ApplicationTable`
  applicationTableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationTableFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationTableOrderBy!]
  ): ApplicationTableConnection
  # A pagable collection of type `ApplicationTool`
  applicationToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationToolFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationToolOrderBy!]
  ): ApplicationToolConnection
  # A pagable collection of type `ApplicationType`
  applicationTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationTypeFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationTypeOrderBy!]
  ): ApplicationTypeConnection
  # A pagable collection of type `ApplicationUser`
  applicationUserCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserOrderBy!]
  ): ApplicationUserConnection
  # A pagable collection of type `ApplicationUserRole`
  applicationUserRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserRoleFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserRoleOrderBy!]
  ): ApplicationUserRoleConnection
  # A pagable collection of type `Asset`
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
  # A pagable collection of type `AssetStatus`
  assetStatusCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetStatusFilter
    # Sort order to apply to the collection
    orderBy: [AssetStatusOrderBy!]
  ): AssetStatusConnection
  # A pagable collection of type `AssetType`
  assetTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetTypeFilter
    # Sort order to apply to the collection
    orderBy: [AssetTypeOrderBy!]
  ): AssetTypeConnection
  # A pagable collection of type `AssetTypeMimeType`
  assetTypeMimeTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetTypeMimeTypeFilter
    # Sort order to apply to the collection
    orderBy: [AssetTypeMimeTypeOrderBy!]
  ): AssetTypeMimeTypeConnection
  # A pagable collection of type `ChatMessage`
  chatMessageCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatMessageFilter
    # Sort order to apply to the collection
    orderBy: [ChatMessageOrderBy!]
  ): ChatMessageConnection
  # A pagable collection of type `ChatRole`
  chatRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatRoleFilter
    # Sort order to apply to the collection
    orderBy: [ChatRoleOrderBy!]
  ): ChatRoleConnection
  # A pagable collection of type `ChatSession`
  chatSessionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatSessionFilter
    # Sort order to apply to the collection
    orderBy: [ChatSessionOrderBy!]
  ): ChatSessionConnection
  # A pagable collection of type `Content`
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
  # A pagable collection of type `ContentContentPart`
  contentContentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentContentPartOrderBy!]
  ): ContentContentPartConnection
  # A pagable collection of type `ContentPart`
  contentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentPartOrderBy!]
  ): ContentPartConnection
  # A pagable collection of type `ContentPartContentPart`
  contentPartContentPartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentPartContentPartFilter
    # Sort order to apply to the collection
    orderBy: [ContentPartContentPartOrderBy!]
  ): ContentPartContentPartConnection
  # A pagable collection of type `ContentTemplate`
  contentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateOrderBy!]
  ): ContentTemplateConnection
  # A pagable collection of type `ContentTemplateVariable`
  contentTemplateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableOrderBy!]
  ): ContentTemplateVariableConnection
  # A pagable collection of type `ContentTemplateVariableValue`
  contentTemplateVariableValueCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableValueFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableValueOrderBy!]
  ): ContentTemplateVariableValueConnection
  # A pagable collection of type `ContentType`
  contentTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTypeFilter
    # Sort order to apply to the collection
    orderBy: [ContentTypeOrderBy!]
  ): ContentTypeConnection
  # A pagable collection of type `CreationType`
  creationTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: CreationTypeFilter
    # Sort order to apply to the collection
    orderBy: [CreationTypeOrderBy!]
  ): CreationTypeConnection
  # A pagable collection of type `Document`
  documentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentFilter
    # Sort order to apply to the collection
    orderBy: [DocumentOrderBy!]
  ): DocumentConnection
  # A pagable collection of type `DocumentTemplate`
  documentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [DocumentTemplateOrderBy!]
  ): DocumentTemplateConnection
  # A pagable collection of type `DocumentType`
  documentTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentTypeFilter
    # Sort order to apply to the collection
    orderBy: [DocumentTypeOrderBy!]
  ): DocumentTypeConnection
  # A pagable collection of type `Feature`
  featureCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FeatureFilter
    # Sort order to apply to the collection
    orderBy: [FeatureOrderBy!]
  ): FeatureConnection
  # A pagable collection of type `FirefighterStatus`
  firefighterStatusCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirefighterStatusFilter
    # Sort order to apply to the collection
    orderBy: [FirefighterStatusOrderBy!]
  ): FirefighterStatusConnection
  # A pagable collection of type `FirstResponder`
  firstResponderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderOrderBy!]
  ): FirstResponderConnection
  # A pagable collection of type `FirstResponderStation`
  firstResponderStationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderStationFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderStationOrderBy!]
  ): FirstResponderStationConnection
  # A pagable collection of type `FirstResponderType`
  firstResponderTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderTypeFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderTypeOrderBy!]
  ): FirstResponderTypeConnection
  # A pagable collection of type `Form`
  formCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FormFilter
    # Sort order to apply to the collection
    orderBy: [FormOrderBy!]
  ): FormConnection
  # A pagable collection of type `FormQuestion`
  formQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FormQuestionFilter
    # Sort order to apply to the collection
    orderBy: [FormQuestionOrderBy!]
  ): FormQuestionConnection
  # A pagable collection of type `HeroItem`
  heroItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: HeroItemFilter
    # Sort order to apply to the collection
    orderBy: [HeroItemOrderBy!]
  ): HeroItemConnection
  # A pagable collection of type `Menu`
  menuCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuFilter
    # Sort order to apply to the collection
    orderBy: [MenuOrderBy!]
  ): MenuConnection
  # A pagable collection of type `MenuItem`
  menuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuItemFilter
    # Sort order to apply to the collection
    orderBy: [MenuItemOrderBy!]
  ): MenuItemConnection
  # A pagable collection of type `MenuType`
  menuTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MenuTypeFilter
    # Sort order to apply to the collection
    orderBy: [MenuTypeOrderBy!]
  ): MenuTypeConnection
  # A pagable collection of type `MimeType`
  mimeTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: MimeTypeFilter
    # Sort order to apply to the collection
    orderBy: [MimeTypeOrderBy!]
  ): MimeTypeConnection
  # Retrieve a record by its `ID`
  node(
    # The record's `ID`
    nodeId: ID!
  ): Node
  # A pagable collection of type `Notification`
  notificationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: NotificationFilter
    # Sort order to apply to the collection
    orderBy: [NotificationOrderBy!]
  ): NotificationConnection
  # A pagable collection of type `NotificationType`
  notificationTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: NotificationTypeFilter
    # Sort order to apply to the collection
    orderBy: [NotificationTypeOrderBy!]
  ): NotificationTypeConnection
  # A pagable collection of type `Onboarding`
  onboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingOrderBy!]
  ): OnboardingConnection
  # A pagable collection of type `OnboardingForm`
  onboardingFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingFormFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingFormOrderBy!]
  ): OnboardingFormConnection
  # A pagable collection of type `OnboardingStep`
  onboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingStepOrderBy!]
  ): OnboardingStepConnection
  # A pagable collection of type `OnboardingSurvey`
  onboardingSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingSurveyFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingSurveyOrderBy!]
  ): OnboardingSurveyConnection
  # A pagable collection of type `OnboardingType`
  onboardingTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingTypeFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingTypeOrderBy!]
  ): OnboardingTypeConnection
  # A pagable collection of type `Order`
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
  # A pagable collection of type `OrderItem`
  orderItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderItemFilter
    # Sort order to apply to the collection
    orderBy: [OrderItemOrderBy!]
  ): OrderItemConnection
  # A pagable collection of type `OrderItemMenuItem`
  orderItemMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderItemMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [OrderItemMenuItemOrderBy!]
  ): OrderItemMenuItemConnection
  # A pagable collection of type `OrderStatus`
  orderStatusCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderStatusFilter
    # Sort order to apply to the collection
    orderBy: [OrderStatusOrderBy!]
  ): OrderStatusConnection
  # A pagable collection of type `OrderTransaction`
  orderTransactionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderTransactionFilter
    # Sort order to apply to the collection
    orderBy: [OrderTransactionOrderBy!]
  ): OrderTransactionConnection
  # A pagable collection of type `OrderType`
  orderTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderTypeFilter
    # Sort order to apply to the collection
    orderBy: [OrderTypeOrderBy!]
  ): OrderTypeConnection
  # A pagable collection of type `Partner`
  partnerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PartnerFilter
    # Sort order to apply to the collection
    orderBy: [PartnerOrderBy!]
  ): PartnerConnection
  # A pagable collection of type `PartnerType`
  partnerTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PartnerTypeFilter
    # Sort order to apply to the collection
    orderBy: [PartnerTypeOrderBy!]
  ): PartnerTypeConnection
  # A pagable collection of type `PaymentInfo`
  paymentInfoCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PaymentInfoFilter
    # Sort order to apply to the collection
    orderBy: [PaymentInfoOrderBy!]
  ): PaymentInfoConnection
  # A pagable collection of type `PaymentType`
  paymentTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PaymentTypeFilter
    # Sort order to apply to the collection
    orderBy: [PaymentTypeOrderBy!]
  ): PaymentTypeConnection
  # A pagable collection of type `Persona`
  personaCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PersonaFilter
    # Sort order to apply to the collection
    orderBy: [PersonaOrderBy!]
  ): PersonaConnection
  # A pagable collection of type `PersonaOnboarding`
  personaOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PersonaOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [PersonaOnboardingOrderBy!]
  ): PersonaOnboardingConnection
  # A pagable collection of type `ProfileType`
  profileTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ProfileTypeFilter
    # Sort order to apply to the collection
    orderBy: [ProfileTypeOrderBy!]
  ): ProfileTypeConnection
  # A pagable collection of type `Prompt`
  promptCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PromptFilter
    # Sort order to apply to the collection
    orderBy: [PromptOrderBy!]
  ): PromptConnection
  # A pagable collection of type `PromptTemplate`
  promptTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PromptTemplateFilter
    # Sort order to apply to the collection
    orderBy: [PromptTemplateOrderBy!]
  ): PromptTemplateConnection
  # A pagable collection of type `PromptTemplateVariable`
  promptTemplateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PromptTemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [PromptTemplateVariableOrderBy!]
  ): PromptTemplateVariableConnection
  # A pagable collection of type `Provider`
  providerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ProviderFilter
    # Sort order to apply to the collection
    orderBy: [ProviderOrderBy!]
  ): ProviderConnection
  # A pagable collection of type `ProviderType`
  providerTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ProviderTypeFilter
    # Sort order to apply to the collection
    orderBy: [ProviderTypeOrderBy!]
  ): ProviderTypeConnection
  # A pagable collection of type `PublicationState`
  publicationStateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PublicationStateFilter
    # Sort order to apply to the collection
    orderBy: [PublicationStateOrderBy!]
  ): PublicationStateConnection
  # A pagable collection of type `QuestionAnwserChoice`
  questionAnwserChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionAnwserChoiceFilter
    # Sort order to apply to the collection
    orderBy: [QuestionAnwserChoiceOrderBy!]
  ): QuestionAnwserChoiceConnection
  # A pagable collection of type `Question`
  questionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionFilter
    # Sort order to apply to the collection
    orderBy: [QuestionOrderBy!]
  ): QuestionConnection
  # A pagable collection of type `QuestionType`
  questionTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionTypeFilter
    # Sort order to apply to the collection
    orderBy: [QuestionTypeOrderBy!]
  ): QuestionTypeConnection
  # A pagable collection of type `Role`
  roleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: RoleFilter
    # Sort order to apply to the collection
    orderBy: [RoleOrderBy!]
  ): RoleConnection
  # A pagable collection of type `SchemaMigrations`
  schemaMigrationsCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: SchemaMigrationsFilter
    # Sort order to apply to the collection
    orderBy: [SchemaMigrationsOrderBy!]
  ): SchemaMigrationsConnection
  # A pagable collection of type `Shift`
  shiftCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftFilter
    # Sort order to apply to the collection
    orderBy: [ShiftOrderBy!]
  ): ShiftConnection
  # A pagable collection of type `ShiftScheduleStatus`
  shiftScheduleStatusCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftScheduleStatusFilter
    # Sort order to apply to the collection
    orderBy: [ShiftScheduleStatusOrderBy!]
  ): ShiftScheduleStatusConnection
  # A pagable collection of type `ShiftType`
  shiftTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftTypeFilter
    # Sort order to apply to the collection
    orderBy: [ShiftTypeOrderBy!]
  ): ShiftTypeConnection
  # A pagable collection of type `ShoppingCart`
  shoppingCartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartOrderBy!]
  ): ShoppingCartConnection
  # A pagable collection of type `ShoppingCartMenuItem`
  shoppingCartMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartMenuItemOrderBy!]
  ): ShoppingCartMenuItemConnection
  # A pagable collection of type `Station`
  stationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationFilter
    # Sort order to apply to the collection
    orderBy: [StationOrderBy!]
  ): StationConnection
  # A pagable collection of type `StationPartner`
  stationPartnerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationPartnerFilter
    # Sort order to apply to the collection
    orderBy: [StationPartnerOrderBy!]
  ): StationPartnerConnection
  # A pagable collection of type `StationProvider`
  stationProviderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationProviderFilter
    # Sort order to apply to the collection
    orderBy: [StationProviderOrderBy!]
  ): StationProviderConnection
  # A pagable collection of type `Survey`
  surveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: SurveyFilter
    # Sort order to apply to the collection
    orderBy: [SurveyOrderBy!]
  ): SurveyConnection
  # A pagable collection of type `SurveyQuestion`
  surveyQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: SurveyQuestionFilter
    # Sort order to apply to the collection
    orderBy: [SurveyQuestionOrderBy!]
  ): SurveyQuestionConnection
  # A pagable collection of type `TeamUpdate`
  teamUpdateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateOrderBy!]
  ): TeamUpdateConnection
  # A pagable collection of type `TeamUpdateType`
  teamUpdateTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateTypeFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateTypeOrderBy!]
  ): TeamUpdateTypeConnection
  # A pagable collection of type `TemplateVariable`
  templateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [TemplateVariableOrderBy!]
  ): TemplateVariableConnection
  # A pagable collection of type `TemplateVariableType`
  templateVariableTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TemplateVariableTypeFilter
    # Sort order to apply to the collection
    orderBy: [TemplateVariableTypeOrderBy!]
  ): TemplateVariableTypeConnection
  # A pagable collection of type `Testimonial`
  testimonialCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TestimonialFilter
    # Sort order to apply to the collection
    orderBy: [TestimonialOrderBy!]
  ): TestimonialConnection
  # A pagable collection of type `Tool`
  toolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ToolFilter
    # Sort order to apply to the collection
    orderBy: [ToolOrderBy!]
  ): ToolConnection
  # A pagable collection of type `ToolType`
  toolTypeCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ToolTypeFilter
    # Sort order to apply to the collection
    orderBy: [ToolTypeOrderBy!]
  ): ToolTypeConnection
  # A pagable collection of type `UserAnswerChoice`
  userAnswerChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserAnswerChoiceFilter
    # Sort order to apply to the collection
    orderBy: [UserAnswerChoiceOrderBy!]
  ): UserAnswerChoiceConnection
  # A pagable collection of type `User`
  userCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFilter
    # Sort order to apply to the collection
    orderBy: [UserOrderBy!]
  ): UserConnection
  # A pagable collection of type `UserForm`
  userFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormFilter
    # Sort order to apply to the collection
    orderBy: [UserFormOrderBy!]
  ): UserFormConnection
  # A pagable collection of type `UserFormQuestionAnswer`
  userFormQuestionAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormQuestionAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserFormQuestionAnswerOrderBy!]
  ): UserFormQuestionAnswerConnection
  # A pagable collection of type `UserOnboarding`
  userOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingOrderBy!]
  ): UserOnboardingConnection
  # A pagable collection of type `UserOnboardingStep`
  userOnboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingStepOrderBy!]
  ): UserOnboardingStepConnection
  # A pagable collection of type `UserPersona`
  userPersonaCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserPersonaFilter
    # Sort order to apply to the collection
    orderBy: [UserPersonaOrderBy!]
  ): UserPersonaConnection
  # A pagable collection of type `UserProfile`
  userProfileCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserProfileFilter
    # Sort order to apply to the collection
    orderBy: [UserProfileOrderBy!]
  ): UserProfileConnection
  # A pagable collection of type `UserRole`
  userRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserRoleFilter
    # Sort order to apply to the collection
    orderBy: [UserRoleOrderBy!]
  ): UserRoleConnection
  # A pagable collection of type `UserSurveyAnswer`
  userSurveyAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyAnswerOrderBy!]
  ): UserSurveyAnswerConnection
  # A pagable collection of type `UserSurvey`
  userSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyOrderBy!]
  ): UserSurveyConnection
  # A pagable collection of type `VectorDatabase`
  vectorDatabaseCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: VectorDatabaseFilter
    # Sort order to apply to the collection
    orderBy: [VectorDatabaseOrderBy!]
  ): VectorDatabaseConnection
}

type Question implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  questionTypeId: UUID!
  questionText: String!
  data: JSON
  createdAt: Datetime!
  isUserAnswerChoice: Boolean!
  questionType: QuestionType
  answerChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AnswerChoiceFilter
    # Sort order to apply to the collection
    orderBy: [AnswerChoiceOrderBy!]
  ): AnswerChoiceConnection
  questionAnwserChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionAnwserChoiceFilter
    # Sort order to apply to the collection
    orderBy: [QuestionAnwserChoiceOrderBy!]
  ): QuestionAnwserChoiceConnection
  userFormQuestionAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormQuestionAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserFormQuestionAnswerOrderBy!]
  ): UserFormQuestionAnswerConnection
  userAnswerChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserAnswerChoiceFilter
    # Sort order to apply to the collection
    orderBy: [UserAnswerChoiceOrderBy!]
  ): UserAnswerChoiceConnection
  surveyQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: SurveyQuestionFilter
    # Sort order to apply to the collection
    orderBy: [SurveyQuestionOrderBy!]
  ): SurveyQuestionConnection
  formQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FormQuestionFilter
    # Sort order to apply to the collection
    orderBy: [FormQuestionOrderBy!]
  ): FormQuestionConnection
}

type QuestionAnwserChoice implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  questionId: UUID
  answerChoiceId: UUID!
  createdAt: Datetime!
  question: Question
  answerChoice: AnswerChoice!
}

type QuestionAnwserChoiceConnection {
  edges: [QuestionAnwserChoiceEdge!]!
  pageInfo: PageInfo!
}

type QuestionAnwserChoiceDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionAnwserChoice!]!
}

type QuestionAnwserChoiceEdge {
  cursor: String!
  node: QuestionAnwserChoice!
}

input QuestionAnwserChoiceFilter {
  id: UUIDFilter
  questionId: UUIDFilter
  answerChoiceId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [QuestionAnwserChoiceFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [QuestionAnwserChoiceFilter!]
  # Negates a filter
  not: QuestionAnwserChoiceFilter
}

input QuestionAnwserChoiceInsertInput {
  id: UUID
  questionId: UUID
  answerChoiceId: UUID
  createdAt: Datetime
}

type QuestionAnwserChoiceInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionAnwserChoice!]!
}

input QuestionAnwserChoiceOrderBy {
  id: OrderByDirection
  questionId: OrderByDirection
  answerChoiceId: OrderByDirection
  createdAt: OrderByDirection
}

input QuestionAnwserChoiceUpdateInput {
  id: UUID
  questionId: UUID
  answerChoiceId: UUID
  createdAt: Datetime
}

type QuestionAnwserChoiceUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionAnwserChoice!]!
}

type QuestionConnection {
  edges: [QuestionEdge!]!
  pageInfo: PageInfo!
}

type QuestionDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Question!]!
}

type QuestionEdge {
  cursor: String!
  node: Question!
}

input QuestionFilter {
  id: UUIDFilter
  questionTypeId: UUIDFilter
  questionText: StringFilter
  createdAt: DatetimeFilter
  isUserAnswerChoice: BooleanFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [QuestionFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [QuestionFilter!]
  # Negates a filter
  not: QuestionFilter
}

input QuestionInsertInput {
  id: UUID
  questionTypeId: UUID
  questionText: String
  data: JSON
  createdAt: Datetime
  isUserAnswerChoice: Boolean
}

type QuestionInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Question!]!
}

input QuestionOrderBy {
  id: OrderByDirection
  questionTypeId: OrderByDirection
  questionText: OrderByDirection
  createdAt: OrderByDirection
  isUserAnswerChoice: OrderByDirection
}

type QuestionType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  questionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: QuestionFilter
    # Sort order to apply to the collection
    orderBy: [QuestionOrderBy!]
  ): QuestionConnection
}

type QuestionTypeConnection {
  edges: [QuestionTypeEdge!]!
  pageInfo: PageInfo!
}

type QuestionTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionType!]!
}

type QuestionTypeEdge {
  cursor: String!
  node: QuestionType!
}

input QuestionTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [QuestionTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [QuestionTypeFilter!]
  # Negates a filter
  not: QuestionTypeFilter
}

input QuestionTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type QuestionTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionType!]!
}

input QuestionTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input QuestionTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type QuestionTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [QuestionType!]!
}

input QuestionUpdateInput {
  id: UUID
  questionTypeId: UUID
  questionText: String
  data: JSON
  createdAt: Datetime
  isUserAnswerChoice: Boolean
}

type QuestionUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Question!]!
}

type Role implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  name: String!
  key: String!
  schema: JSON
  applicationUserRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserRoleFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserRoleOrderBy!]
  ): ApplicationUserRoleConnection
  userRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserRoleFilter
    # Sort order to apply to the collection
    orderBy: [UserRoleOrderBy!]
  ): UserRoleConnection
}

type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
}

type RoleDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Role!]!
}

type RoleEdge {
  cursor: String!
  node: Role!
}

input RoleFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  key: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [RoleFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [RoleFilter!]
  # Negates a filter
  not: RoleFilter
}

input RoleInsertInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
  schema: JSON
}

type RoleInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Role!]!
}

input RoleOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
}

input RoleUpdateInput {
  id: UUID
  createdAt: Datetime
  name: String
  key: String
  schema: JSON
}

type RoleUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Role!]!
}

type SchemaMigrations implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  version: String!
  appliedAt: Datetime
}

type SchemaMigrationsConnection {
  edges: [SchemaMigrationsEdge!]!
  pageInfo: PageInfo!
}

type SchemaMigrationsDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SchemaMigrations!]!
}

type SchemaMigrationsEdge {
  cursor: String!
  node: SchemaMigrations!
}

input SchemaMigrationsFilter {
  version: StringFilter
  appliedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [SchemaMigrationsFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [SchemaMigrationsFilter!]
  # Negates a filter
  not: SchemaMigrationsFilter
}

input SchemaMigrationsInsertInput {
  version: String
  appliedAt: Datetime
}

type SchemaMigrationsInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SchemaMigrations!]!
}

input SchemaMigrationsOrderBy {
  version: OrderByDirection
  appliedAt: OrderByDirection
}

input SchemaMigrationsUpdateInput {
  version: String
  appliedAt: Datetime
}

type SchemaMigrationsUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SchemaMigrations!]!
}

type Shift implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String
  shiftTypeId: UUID!
  shiftScheduleStatusId: UUID!
  stationId: UUID
  createdAt: Datetime!
  startTime: Datetime
  endTime: Datetime
  station: Station
  shiftType: ShiftType!
  shiftScheduleStatus: ShiftScheduleStatus!
}

type ShiftConnection {
  edges: [ShiftEdge!]!
  pageInfo: PageInfo!
}

type ShiftDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Shift!]!
}

type ShiftEdge {
  cursor: String!
  node: Shift!
}

input ShiftFilter {
  id: UUIDFilter
  name: StringFilter
  shiftTypeId: UUIDFilter
  shiftScheduleStatusId: UUIDFilter
  stationId: UUIDFilter
  createdAt: DatetimeFilter
  startTime: DatetimeFilter
  endTime: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ShiftFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ShiftFilter!]
  # Negates a filter
  not: ShiftFilter
}

input ShiftInsertInput {
  id: UUID
  name: String
  shiftTypeId: UUID
  shiftScheduleStatusId: UUID
  stationId: UUID
  createdAt: Datetime
  startTime: Datetime
  endTime: Datetime
}

type ShiftInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Shift!]!
}

input ShiftOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  shiftTypeId: OrderByDirection
  shiftScheduleStatusId: OrderByDirection
  stationId: OrderByDirection
  createdAt: OrderByDirection
  startTime: OrderByDirection
  endTime: OrderByDirection
}

type ShiftScheduleStatus implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  shiftCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftFilter
    # Sort order to apply to the collection
    orderBy: [ShiftOrderBy!]
  ): ShiftConnection
}

type ShiftScheduleStatusConnection {
  edges: [ShiftScheduleStatusEdge!]!
  pageInfo: PageInfo!
}

type ShiftScheduleStatusDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftScheduleStatus!]!
}

type ShiftScheduleStatusEdge {
  cursor: String!
  node: ShiftScheduleStatus!
}

input ShiftScheduleStatusFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ShiftScheduleStatusFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ShiftScheduleStatusFilter!]
  # Negates a filter
  not: ShiftScheduleStatusFilter
}

input ShiftScheduleStatusInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type ShiftScheduleStatusInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftScheduleStatus!]!
}

input ShiftScheduleStatusOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input ShiftScheduleStatusUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type ShiftScheduleStatusUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftScheduleStatus!]!
}

type ShiftType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  shiftCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftFilter
    # Sort order to apply to the collection
    orderBy: [ShiftOrderBy!]
  ): ShiftConnection
}

type ShiftTypeConnection {
  edges: [ShiftTypeEdge!]!
  pageInfo: PageInfo!
}

type ShiftTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftType!]!
}

type ShiftTypeEdge {
  cursor: String!
  node: ShiftType!
}

input ShiftTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ShiftTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ShiftTypeFilter!]
  # Negates a filter
  not: ShiftTypeFilter
}

input ShiftTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type ShiftTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftType!]!
}

input ShiftTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input ShiftTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type ShiftTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShiftType!]!
}

input ShiftUpdateInput {
  id: UUID
  name: String
  shiftTypeId: UUID
  shiftScheduleStatusId: UUID
  stationId: UUID
  createdAt: Datetime
  startTime: Datetime
  endTime: Datetime
}

type ShiftUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Shift!]!
}

type ShoppingCart implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  createdAt: Datetime!
  orderId: UUID
  order: Order
  user: User
  shoppingCartMenuItemCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartMenuItemFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartMenuItemOrderBy!]
  ): ShoppingCartMenuItemConnection
}

type ShoppingCartConnection {
  edges: [ShoppingCartEdge!]!
  pageInfo: PageInfo!
}

type ShoppingCartDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCart!]!
}

type ShoppingCartEdge {
  cursor: String!
  node: ShoppingCart!
}

input ShoppingCartFilter {
  id: UUIDFilter
  userId: UUIDFilter
  createdAt: DatetimeFilter
  orderId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ShoppingCartFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ShoppingCartFilter!]
  # Negates a filter
  not: ShoppingCartFilter
}

input ShoppingCartInsertInput {
  id: UUID
  userId: UUID
  createdAt: Datetime
  orderId: UUID
}

type ShoppingCartInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCart!]!
}

type ShoppingCartMenuItem implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  shoppingCartId: UUID!
  menuItemId: UUID!
  count: Int!
  createdAt: Datetime!
  menuItem: MenuItem!
  shoppingCart: ShoppingCart!
}

type ShoppingCartMenuItemConnection {
  edges: [ShoppingCartMenuItemEdge!]!
  pageInfo: PageInfo!
}

type ShoppingCartMenuItemDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCartMenuItem!]!
}

type ShoppingCartMenuItemEdge {
  cursor: String!
  node: ShoppingCartMenuItem!
}

input ShoppingCartMenuItemFilter {
  id: UUIDFilter
  shoppingCartId: UUIDFilter
  menuItemId: UUIDFilter
  count: IntFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ShoppingCartMenuItemFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ShoppingCartMenuItemFilter!]
  # Negates a filter
  not: ShoppingCartMenuItemFilter
}

input ShoppingCartMenuItemInsertInput {
  id: UUID
  shoppingCartId: UUID
  menuItemId: UUID
  count: Int
  createdAt: Datetime
}

type ShoppingCartMenuItemInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCartMenuItem!]!
}

input ShoppingCartMenuItemOrderBy {
  id: OrderByDirection
  shoppingCartId: OrderByDirection
  menuItemId: OrderByDirection
  count: OrderByDirection
  createdAt: OrderByDirection
}

input ShoppingCartMenuItemUpdateInput {
  id: UUID
  shoppingCartId: UUID
  menuItemId: UUID
  count: Int
  createdAt: Datetime
}

type ShoppingCartMenuItemUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCartMenuItem!]!
}

input ShoppingCartOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  createdAt: OrderByDirection
  orderId: OrderByDirection
}

input ShoppingCartUpdateInput {
  id: UUID
  userId: UUID
  createdAt: Datetime
  orderId: UUID
}

type ShoppingCartUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ShoppingCart!]!
}

type Station implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  address: String
  address1: String
  city: String
  state: String
  zip: String
  createdAt: Datetime!
  latitude: Float
  longitude: Float
  description: String
  longDescriptionMarkdown: String
  updatedAt: Datetime
  startedAt: Datetime
  number: Int
  iconUrl: String
  coverUrl: String
  stationProviderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationProviderFilter
    # Sort order to apply to the collection
    orderBy: [StationProviderOrderBy!]
  ): StationProviderConnection
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
  shiftCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShiftFilter
    # Sort order to apply to the collection
    orderBy: [ShiftOrderBy!]
  ): ShiftConnection
  stationPartnerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: StationPartnerFilter
    # Sort order to apply to the collection
    orderBy: [StationPartnerOrderBy!]
  ): StationPartnerConnection
  teamUpdateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateOrderBy!]
  ): TeamUpdateConnection
  firstResponderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderOrderBy!]
  ): FirstResponderConnection
  firstResponderStationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderStationFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderStationOrderBy!]
  ): FirstResponderStationConnection
}

type StationConnection {
  edges: [StationEdge!]!
  pageInfo: PageInfo!
}

type StationDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Station!]!
}

type StationEdge {
  cursor: String!
  node: Station!
}

input StationFilter {
  id: UUIDFilter
  name: StringFilter
  address: StringFilter
  address1: StringFilter
  city: StringFilter
  state: StringFilter
  zip: StringFilter
  createdAt: DatetimeFilter
  latitude: FloatFilter
  longitude: FloatFilter
  description: StringFilter
  longDescriptionMarkdown: StringFilter
  updatedAt: DatetimeFilter
  startedAt: DatetimeFilter
  number: IntFilter
  iconUrl: StringFilter
  coverUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [StationFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [StationFilter!]
  # Negates a filter
  not: StationFilter
}

input StationInsertInput {
  id: UUID
  name: String
  address: String
  address1: String
  city: String
  state: String
  zip: String
  createdAt: Datetime
  latitude: Float
  longitude: Float
  description: String
  longDescriptionMarkdown: String
  updatedAt: Datetime
  startedAt: Datetime
  number: Int
  iconUrl: String
  coverUrl: String
}

type StationInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Station!]!
}

input StationOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  address: OrderByDirection
  address1: OrderByDirection
  city: OrderByDirection
  state: OrderByDirection
  zip: OrderByDirection
  createdAt: OrderByDirection
  latitude: OrderByDirection
  longitude: OrderByDirection
  description: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  updatedAt: OrderByDirection
  startedAt: OrderByDirection
  number: OrderByDirection
  iconUrl: OrderByDirection
  coverUrl: OrderByDirection
}

type StationPartner implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  stationId: UUID!
  partnerId: UUID!
  partner: Partner
  station: Station!
}

type StationPartnerConnection {
  edges: [StationPartnerEdge!]!
  pageInfo: PageInfo!
}

type StationPartnerDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationPartner!]!
}

type StationPartnerEdge {
  cursor: String!
  node: StationPartner!
}

input StationPartnerFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  stationId: UUIDFilter
  partnerId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [StationPartnerFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [StationPartnerFilter!]
  # Negates a filter
  not: StationPartnerFilter
}

input StationPartnerInsertInput {
  id: UUID
  createdAt: Datetime
  stationId: UUID
  partnerId: UUID
}

type StationPartnerInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationPartner!]!
}

input StationPartnerOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  stationId: OrderByDirection
  partnerId: OrderByDirection
}

input StationPartnerUpdateInput {
  id: UUID
  createdAt: Datetime
  stationId: UUID
  partnerId: UUID
}

type StationPartnerUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationPartner!]!
}

type StationProvider implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  stationId: UUID!
  createdAt: Datetime!
  providerId: UUID!
  station: Station!
  provider: Provider!
}

type StationProviderConnection {
  edges: [StationProviderEdge!]!
  pageInfo: PageInfo!
}

type StationProviderDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationProvider!]!
}

type StationProviderEdge {
  cursor: String!
  node: StationProvider!
}

input StationProviderFilter {
  id: UUIDFilter
  stationId: UUIDFilter
  createdAt: DatetimeFilter
  providerId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [StationProviderFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [StationProviderFilter!]
  # Negates a filter
  not: StationProviderFilter
}

input StationProviderInsertInput {
  id: UUID
  stationId: UUID
  createdAt: Datetime
  providerId: UUID
}

type StationProviderInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationProvider!]!
}

input StationProviderOrderBy {
  id: OrderByDirection
  stationId: OrderByDirection
  createdAt: OrderByDirection
  providerId: OrderByDirection
}

input StationProviderUpdateInput {
  id: UUID
  stationId: UUID
  createdAt: Datetime
  providerId: UUID
}

type StationProviderUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [StationProvider!]!
}

input StationUpdateInput {
  id: UUID
  name: String
  address: String
  address1: String
  city: String
  state: String
  zip: String
  createdAt: Datetime
  latitude: Float
  longitude: Float
  description: String
  longDescriptionMarkdown: String
  updatedAt: Datetime
  startedAt: Datetime
  number: Int
  iconUrl: String
  coverUrl: String
}

type StationUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Station!]!
}

# Boolean expression comparing fields on type "String"
input StringFilter {
  eq: String
  gt: String
  gte: String
  ilike: String
  in: [String!]
  iregex: String
  is: FilterIs
  like: String
  lt: String
  lte: String
  neq: String
  regex: String
  startsWith: String
}

# Boolean expression comparing fields on type "StringList"
input StringListFilter {
  containedBy: [String!]
  contains: [String!]
  eq: [String!]
  is: FilterIs
  overlaps: [String!]
}

type Survey implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  description: String
  key: String!
  schema: JSON
  createdAt: Datetime!
  onboardingSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingSurveyFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingSurveyOrderBy!]
  ): OnboardingSurveyConnection
  onboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [OnboardingStepOrderBy!]
  ): OnboardingStepConnection
  surveyQuestionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: SurveyQuestionFilter
    # Sort order to apply to the collection
    orderBy: [SurveyQuestionOrderBy!]
  ): SurveyQuestionConnection
  userSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyOrderBy!]
  ): UserSurveyConnection
}

type SurveyConnection {
  edges: [SurveyEdge!]!
  pageInfo: PageInfo!
}

type SurveyDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Survey!]!
}

type SurveyEdge {
  cursor: String!
  node: Survey!
}

input SurveyFilter {
  id: UUIDFilter
  name: StringFilter
  description: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [SurveyFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [SurveyFilter!]
  # Negates a filter
  not: SurveyFilter
}

input SurveyInsertInput {
  id: UUID
  name: String
  description: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type SurveyInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Survey!]!
}

input SurveyOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  description: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

type SurveyQuestion implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  surveyId: UUID!
  questionId: UUID!
  index: Int!
  isRequired: Boolean!
  createdAt: Datetime!
  survey: Survey
  question: Question!
  userSurveyAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyAnswerOrderBy!]
  ): UserSurveyAnswerConnection
}

type SurveyQuestionConnection {
  edges: [SurveyQuestionEdge!]!
  pageInfo: PageInfo!
}

type SurveyQuestionDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SurveyQuestion!]!
}

type SurveyQuestionEdge {
  cursor: String!
  node: SurveyQuestion!
}

input SurveyQuestionFilter {
  id: UUIDFilter
  surveyId: UUIDFilter
  questionId: UUIDFilter
  index: IntFilter
  isRequired: BooleanFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [SurveyQuestionFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [SurveyQuestionFilter!]
  # Negates a filter
  not: SurveyQuestionFilter
}

input SurveyQuestionInsertInput {
  id: UUID
  surveyId: UUID
  questionId: UUID
  index: Int
  isRequired: Boolean
  createdAt: Datetime
}

type SurveyQuestionInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SurveyQuestion!]!
}

input SurveyQuestionOrderBy {
  id: OrderByDirection
  surveyId: OrderByDirection
  questionId: OrderByDirection
  index: OrderByDirection
  isRequired: OrderByDirection
  createdAt: OrderByDirection
}

input SurveyQuestionUpdateInput {
  id: UUID
  surveyId: UUID
  questionId: UUID
  index: Int
  isRequired: Boolean
  createdAt: Datetime
}

type SurveyQuestionUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [SurveyQuestion!]!
}

input SurveyUpdateInput {
  id: UUID
  name: String
  description: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type SurveyUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Survey!]!
}

type TeamUpdate implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  stationId: UUID
  contentId: UUID!
  authorId: UUID
  metadata: JSON
  createdAt: Datetime!
  isUrgent: Boolean!
  teamUpdateTypeId: UUID!
  teamUpdateType: TeamUpdateType!
  station: Station
  content: Content!
  author: User
}

type TeamUpdateConnection {
  edges: [TeamUpdateEdge!]!
  pageInfo: PageInfo!
}

type TeamUpdateDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdate!]!
}

type TeamUpdateEdge {
  cursor: String!
  node: TeamUpdate!
}

input TeamUpdateFilter {
  id: UUIDFilter
  stationId: UUIDFilter
  contentId: UUIDFilter
  authorId: UUIDFilter
  createdAt: DatetimeFilter
  isUrgent: BooleanFilter
  teamUpdateTypeId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [TeamUpdateFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [TeamUpdateFilter!]
  # Negates a filter
  not: TeamUpdateFilter
}

input TeamUpdateInsertInput {
  id: UUID
  stationId: UUID
  contentId: UUID
  authorId: UUID
  metadata: JSON
  createdAt: Datetime
  isUrgent: Boolean
  teamUpdateTypeId: UUID
}

type TeamUpdateInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdate!]!
}

input TeamUpdateOrderBy {
  id: OrderByDirection
  stationId: OrderByDirection
  contentId: OrderByDirection
  authorId: OrderByDirection
  createdAt: OrderByDirection
  isUrgent: OrderByDirection
  teamUpdateTypeId: OrderByDirection
}

type TeamUpdateType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  teamUpdateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateOrderBy!]
  ): TeamUpdateConnection
}

type TeamUpdateTypeConnection {
  edges: [TeamUpdateTypeEdge!]!
  pageInfo: PageInfo!
}

type TeamUpdateTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdateType!]!
}

type TeamUpdateTypeEdge {
  cursor: String!
  node: TeamUpdateType!
}

input TeamUpdateTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [TeamUpdateTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [TeamUpdateTypeFilter!]
  # Negates a filter
  not: TeamUpdateTypeFilter
}

input TeamUpdateTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type TeamUpdateTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdateType!]!
}

input TeamUpdateTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
}

input TeamUpdateTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
}

type TeamUpdateTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdateType!]!
}

input TeamUpdateUpdateInput {
  id: UUID
  stationId: UUID
  contentId: UUID
  authorId: UUID
  metadata: JSON
  createdAt: Datetime
  isUrgent: Boolean
  teamUpdateTypeId: UUID
}

type TeamUpdateUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TeamUpdate!]!
}

type TemplateVariable implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String
  stringValue: String
  createdAt: Datetime!
  data: JSON
  templateVariableTypeId: UUID
  usage: String
  templateVariableType: TemplateVariableType
  contentTemplateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableOrderBy!]
  ): ContentTemplateVariableConnection
}

type TemplateVariableConnection {
  edges: [TemplateVariableEdge!]!
  pageInfo: PageInfo!
}

type TemplateVariableDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariable!]!
}

type TemplateVariableEdge {
  cursor: String!
  node: TemplateVariable!
}

input TemplateVariableFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  stringValue: StringFilter
  createdAt: DatetimeFilter
  templateVariableTypeId: UUIDFilter
  usage: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [TemplateVariableFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [TemplateVariableFilter!]
  # Negates a filter
  not: TemplateVariableFilter
}

input TemplateVariableInsertInput {
  id: UUID
  name: String
  key: String
  stringValue: String
  createdAt: Datetime
  data: JSON
  templateVariableTypeId: UUID
  usage: String
}

type TemplateVariableInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariable!]!
}

input TemplateVariableOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  stringValue: OrderByDirection
  createdAt: OrderByDirection
  templateVariableTypeId: OrderByDirection
  usage: OrderByDirection
}

type TemplateVariableType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  createdAt: Datetime!
  description: String
  isPrimitive: Boolean!
  isString: Boolean!
  isNumeric: Boolean!
  isDate: Boolean!
  isBool: Boolean!
  isObject: Boolean!
  isArray: Boolean!
  contentTemplateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateVariableOrderBy!]
  ): ContentTemplateVariableConnection
  templateVariableCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TemplateVariableFilter
    # Sort order to apply to the collection
    orderBy: [TemplateVariableOrderBy!]
  ): TemplateVariableConnection
}

type TemplateVariableTypeConnection {
  edges: [TemplateVariableTypeEdge!]!
  pageInfo: PageInfo!
}

type TemplateVariableTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariableType!]!
}

type TemplateVariableTypeEdge {
  cursor: String!
  node: TemplateVariableType!
}

input TemplateVariableTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  createdAt: DatetimeFilter
  description: StringFilter
  isPrimitive: BooleanFilter
  isString: BooleanFilter
  isNumeric: BooleanFilter
  isDate: BooleanFilter
  isBool: BooleanFilter
  isObject: BooleanFilter
  isArray: BooleanFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [TemplateVariableTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [TemplateVariableTypeFilter!]
  # Negates a filter
  not: TemplateVariableTypeFilter
}

input TemplateVariableTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
  description: String
  isPrimitive: Boolean
  isString: Boolean
  isNumeric: Boolean
  isDate: Boolean
  isBool: Boolean
  isObject: Boolean
  isArray: Boolean
}

type TemplateVariableTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariableType!]!
}

input TemplateVariableTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  createdAt: OrderByDirection
  description: OrderByDirection
  isPrimitive: OrderByDirection
  isString: OrderByDirection
  isNumeric: OrderByDirection
  isDate: OrderByDirection
  isBool: OrderByDirection
  isObject: OrderByDirection
  isArray: OrderByDirection
}

input TemplateVariableTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  createdAt: Datetime
  description: String
  isPrimitive: Boolean
  isString: Boolean
  isNumeric: Boolean
  isDate: Boolean
  isBool: Boolean
  isObject: Boolean
  isArray: Boolean
}

type TemplateVariableTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariableType!]!
}

input TemplateVariableUpdateInput {
  id: UUID
  name: String
  key: String
  stringValue: String
  createdAt: Datetime
  data: JSON
  templateVariableTypeId: UUID
  usage: String
}

type TemplateVariableUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [TemplateVariable!]!
}

type Testimonial implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  name: String!
  role: String!
  contentMarkdown: String!
  avatar: String
  summary: String!
}

type TestimonialConnection {
  edges: [TestimonialEdge!]!
  pageInfo: PageInfo!
}

type TestimonialDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Testimonial!]!
}

type TestimonialEdge {
  cursor: String!
  node: Testimonial!
}

input TestimonialFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  name: StringFilter
  role: StringFilter
  contentMarkdown: StringFilter
  avatar: StringFilter
  summary: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [TestimonialFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [TestimonialFilter!]
  # Negates a filter
  not: TestimonialFilter
}

input TestimonialInsertInput {
  id: UUID
  createdAt: Datetime
  name: String
  role: String
  contentMarkdown: String
  avatar: String
  summary: String
}

type TestimonialInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Testimonial!]!
}

input TestimonialOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  name: OrderByDirection
  role: OrderByDirection
  contentMarkdown: OrderByDirection
  avatar: OrderByDirection
  summary: OrderByDirection
}

input TestimonialUpdateInput {
  id: UUID
  createdAt: Datetime
  name: String
  role: String
  contentMarkdown: String
  avatar: String
  summary: String
}

type TestimonialUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Testimonial!]!
}

# A time without date information
scalar Time

# Boolean expression comparing fields on type "Time"
input TimeFilter {
  eq: Time
  gt: Time
  gte: Time
  in: [Time!]
  is: FilterIs
  lt: Time
  lte: Time
  neq: Time
}

# Boolean expression comparing fields on type "TimeList"
input TimeListFilter {
  containedBy: [Time!]
  contains: [Time!]
  eq: [Time!]
  is: FilterIs
  overlaps: [Time!]
}

type Tool implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  toolTypeId: UUID!
  name: String!
  key: String!
  data: JSON!
  shortDescription: String
  longDescriptionMarkdown: String
  ownerId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  toolType: ToolType!
  owner: User
  applicationToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationToolFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationToolOrderBy!]
  ): ApplicationToolConnection
  agentToolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AgentToolFilter
    # Sort order to apply to the collection
    orderBy: [AgentToolOrderBy!]
  ): AgentToolConnection
}

type ToolConnection {
  edges: [ToolEdge!]!
  pageInfo: PageInfo!
}

type ToolDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Tool!]!
}

type ToolEdge {
  cursor: String!
  node: Tool!
}

input ToolFilter {
  id: UUIDFilter
  toolTypeId: UUIDFilter
  name: StringFilter
  key: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  ownerId: UUIDFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ToolFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ToolFilter!]
  # Negates a filter
  not: ToolFilter
}

input ToolInsertInput {
  id: UUID
  toolTypeId: UUID
  name: String
  key: String
  data: JSON
  shortDescription: String
  longDescriptionMarkdown: String
  ownerId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

type ToolInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Tool!]!
}

input ToolOrderBy {
  id: OrderByDirection
  toolTypeId: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  ownerId: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

type ToolType implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  schema: JSON
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime!
  toolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ToolFilter
    # Sort order to apply to the collection
    orderBy: [ToolOrderBy!]
  ): ToolConnection
}

type ToolTypeConnection {
  edges: [ToolTypeEdge!]!
  pageInfo: PageInfo!
}

type ToolTypeDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ToolType!]!
}

type ToolTypeEdge {
  cursor: String!
  node: ToolType!
}

input ToolTypeFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  shortDescription: StringFilter
  longDescriptionMarkdown: StringFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [ToolTypeFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [ToolTypeFilter!]
  # Negates a filter
  not: ToolTypeFilter
}

input ToolTypeInsertInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime
}

type ToolTypeInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ToolType!]!
}

input ToolTypeOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  shortDescription: OrderByDirection
  longDescriptionMarkdown: OrderByDirection
  createdAt: OrderByDirection
}

input ToolTypeUpdateInput {
  id: UUID
  name: String
  key: String
  schema: JSON
  shortDescription: String
  longDescriptionMarkdown: String
  createdAt: Datetime
}

type ToolTypeUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [ToolType!]!
}

input ToolUpdateInput {
  id: UUID
  toolTypeId: UUID
  name: String
  key: String
  data: JSON
  shortDescription: String
  longDescriptionMarkdown: String
  ownerId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

type ToolUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [Tool!]!
}

type User implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  email: String!
  data: JSON
  lastName: String
  firstName: String
  avatarUrl: String
  displayName: String
  updatedAt: Datetime
  kratosId: UUID
  supabaseUserId: UUID
  shoppingCartCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ShoppingCartFilter
    # Sort order to apply to the collection
    orderBy: [ShoppingCartOrderBy!]
  ): ShoppingCartConnection
  applicationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationOrderBy!]
  ): ApplicationConnection
  chatSessionCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ChatSessionFilter
    # Sort order to apply to the collection
    orderBy: [ChatSessionOrderBy!]
  ): ChatSessionConnection
  contentTemplateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentTemplateFilter
    # Sort order to apply to the collection
    orderBy: [ContentTemplateOrderBy!]
  ): ContentTemplateConnection
  assetCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: AssetFilter
    # Sort order to apply to the collection
    orderBy: [AssetOrderBy!]
  ): AssetConnection
  contentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ContentFilter
    # Sort order to apply to the collection
    orderBy: [ContentOrderBy!]
  ): ContentConnection
  applicationUserCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserOrderBy!]
  ): ApplicationUserConnection
  notificationCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: NotificationFilter
    # Sort order to apply to the collection
    orderBy: [NotificationOrderBy!]
  ): NotificationConnection
  userAnswerChoiceCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserAnswerChoiceFilter
    # Sort order to apply to the collection
    orderBy: [UserAnswerChoiceOrderBy!]
  ): UserAnswerChoiceConnection
  toolCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ToolFilter
    # Sort order to apply to the collection
    orderBy: [ToolOrderBy!]
  ): ToolConnection
  userFormCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormFilter
    # Sort order to apply to the collection
    orderBy: [UserFormOrderBy!]
  ): UserFormConnection
  userOnboardingCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingOrderBy!]
  ): UserOnboardingConnection
  orderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: OrderFilter
    # Sort order to apply to the collection
    orderBy: [OrderOrderBy!]
  ): OrderConnection
  teamUpdateCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: TeamUpdateFilter
    # Sort order to apply to the collection
    orderBy: [TeamUpdateOrderBy!]
  ): TeamUpdateConnection
  applicationUserRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: ApplicationUserRoleFilter
    # Sort order to apply to the collection
    orderBy: [ApplicationUserRoleOrderBy!]
  ): ApplicationUserRoleConnection
  documentCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: DocumentFilter
    # Sort order to apply to the collection
    orderBy: [DocumentOrderBy!]
  ): DocumentConnection
  userSurveyCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyOrderBy!]
  ): UserSurveyConnection
  userPersonaCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserPersonaFilter
    # Sort order to apply to the collection
    orderBy: [UserPersonaOrderBy!]
  ): UserPersonaConnection
  userProfileCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserProfileFilter
    # Sort order to apply to the collection
    orderBy: [UserProfileOrderBy!]
  ): UserProfileConnection
  userRoleCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserRoleFilter
    # Sort order to apply to the collection
    orderBy: [UserRoleOrderBy!]
  ): UserRoleConnection
  firstResponderCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: FirstResponderFilter
    # Sort order to apply to the collection
    orderBy: [FirstResponderOrderBy!]
  ): FirstResponderConnection
  paymentInfoCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: PaymentInfoFilter
    # Sort order to apply to the collection
    orderBy: [PaymentInfoOrderBy!]
  ): PaymentInfoConnection
}

type UserAnswerChoice implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  questionId: UUID!
  createdAt: Datetime!
  choiceText: String!
  metadata: JSON
  user: User
  question: Question!
}

type UserAnswerChoiceConnection {
  edges: [UserAnswerChoiceEdge!]!
  pageInfo: PageInfo!
}

type UserAnswerChoiceDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserAnswerChoice!]!
}

type UserAnswerChoiceEdge {
  cursor: String!
  node: UserAnswerChoice!
}

input UserAnswerChoiceFilter {
  id: UUIDFilter
  userId: UUIDFilter
  questionId: UUIDFilter
  createdAt: DatetimeFilter
  choiceText: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserAnswerChoiceFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserAnswerChoiceFilter!]
  # Negates a filter
  not: UserAnswerChoiceFilter
}

input UserAnswerChoiceInsertInput {
  id: UUID
  userId: UUID
  questionId: UUID
  createdAt: Datetime
  choiceText: String
  metadata: JSON
}

type UserAnswerChoiceInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserAnswerChoice!]!
}

input UserAnswerChoiceOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  questionId: OrderByDirection
  createdAt: OrderByDirection
  choiceText: OrderByDirection
}

input UserAnswerChoiceUpdateInput {
  id: UUID
  userId: UUID
  questionId: UUID
  createdAt: Datetime
  choiceText: String
  metadata: JSON
}

type UserAnswerChoiceUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserAnswerChoice!]!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [User!]!
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  email: StringFilter
  lastName: StringFilter
  firstName: StringFilter
  avatarUrl: StringFilter
  displayName: StringFilter
  updatedAt: DatetimeFilter
  kratosId: UUIDFilter
  supabaseUserId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserFilter!]
  # Negates a filter
  not: UserFilter
}

type UserForm implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  formId: UUID!
  createdAt: Datetime!
  user: User
  form: Form!
  userFormQuestionAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserFormQuestionAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserFormQuestionAnswerOrderBy!]
  ): UserFormQuestionAnswerConnection
  userOnboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingStepOrderBy!]
  ): UserOnboardingStepConnection
}

type UserFormConnection {
  edges: [UserFormEdge!]!
  pageInfo: PageInfo!
}

type UserFormDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserForm!]!
}

type UserFormEdge {
  cursor: String!
  node: UserForm!
}

input UserFormFilter {
  id: UUIDFilter
  userId: UUIDFilter
  formId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserFormFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserFormFilter!]
  # Negates a filter
  not: UserFormFilter
}

input UserFormInsertInput {
  id: UUID
  userId: UUID
  formId: UUID
  createdAt: Datetime
}

type UserFormInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserForm!]!
}

input UserFormOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  formId: OrderByDirection
  createdAt: OrderByDirection
}

type UserFormQuestionAnswer implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userFormId: UUID!
  questionId: UUID!
  answerChoiceId: UUID!
  createdAt: Datetime!
  answerText: String
  data: JSON
  userForm: UserForm
  question: Question!
  answerChoice: AnswerChoice!
}

type UserFormQuestionAnswerConnection {
  edges: [UserFormQuestionAnswerEdge!]!
  pageInfo: PageInfo!
}

type UserFormQuestionAnswerDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserFormQuestionAnswer!]!
}

type UserFormQuestionAnswerEdge {
  cursor: String!
  node: UserFormQuestionAnswer!
}

input UserFormQuestionAnswerFilter {
  id: UUIDFilter
  userFormId: UUIDFilter
  questionId: UUIDFilter
  answerChoiceId: UUIDFilter
  createdAt: DatetimeFilter
  answerText: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserFormQuestionAnswerFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserFormQuestionAnswerFilter!]
  # Negates a filter
  not: UserFormQuestionAnswerFilter
}

input UserFormQuestionAnswerInsertInput {
  id: UUID
  userFormId: UUID
  questionId: UUID
  answerChoiceId: UUID
  createdAt: Datetime
  answerText: String
  data: JSON
}

type UserFormQuestionAnswerInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserFormQuestionAnswer!]!
}

input UserFormQuestionAnswerOrderBy {
  id: OrderByDirection
  userFormId: OrderByDirection
  questionId: OrderByDirection
  answerChoiceId: OrderByDirection
  createdAt: OrderByDirection
  answerText: OrderByDirection
}

input UserFormQuestionAnswerUpdateInput {
  id: UUID
  userFormId: UUID
  questionId: UUID
  answerChoiceId: UUID
  createdAt: Datetime
  answerText: String
  data: JSON
}

type UserFormQuestionAnswerUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserFormQuestionAnswer!]!
}

input UserFormUpdateInput {
  id: UUID
  userId: UUID
  formId: UUID
  createdAt: Datetime
}

type UserFormUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserForm!]!
}

input UserInsertInput {
  id: UUID
  createdAt: Datetime
  email: String
  data: JSON
  lastName: String
  firstName: String
  avatarUrl: String
  displayName: String
  updatedAt: Datetime
  kratosId: UUID
  supabaseUserId: UUID
}

type UserInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [User!]!
}

type UserOnboarding implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  onboardingId: UUID!
  createdAt: Datetime!
  isStarted: Boolean!
  startedAt: Datetime
  isCompleted: Boolean!
  completedAt: Datetime
  data: JSON
  user: User
  onboarding: Onboarding!
  userOnboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingStepOrderBy!]
  ): UserOnboardingStepConnection
}

type UserOnboardingConnection {
  edges: [UserOnboardingEdge!]!
  pageInfo: PageInfo!
}

type UserOnboardingDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboarding!]!
}

type UserOnboardingEdge {
  cursor: String!
  node: UserOnboarding!
}

input UserOnboardingFilter {
  id: UUIDFilter
  userId: UUIDFilter
  onboardingId: UUIDFilter
  createdAt: DatetimeFilter
  isStarted: BooleanFilter
  startedAt: DatetimeFilter
  isCompleted: BooleanFilter
  completedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserOnboardingFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserOnboardingFilter!]
  # Negates a filter
  not: UserOnboardingFilter
}

input UserOnboardingInsertInput {
  id: UUID
  userId: UUID
  onboardingId: UUID
  createdAt: Datetime
  isStarted: Boolean
  startedAt: Datetime
  isCompleted: Boolean
  completedAt: Datetime
  data: JSON
}

type UserOnboardingInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboarding!]!
}

input UserOnboardingOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  onboardingId: OrderByDirection
  createdAt: OrderByDirection
  isStarted: OrderByDirection
  startedAt: OrderByDirection
  isCompleted: OrderByDirection
  completedAt: OrderByDirection
}

type UserOnboardingStep implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userOnboardingId: UUID
  onboardingStepId: UUID!
  createdAt: Datetime!
  userSurveyId: UUID
  isCompleted: Boolean!
  isStarted: Boolean!
  startedAt: Datetime
  userFormId: UUID
  completedAt: Datetime
  userSurvey: UserSurvey
  userOnboarding: UserOnboarding
  userForm: UserForm
  onboardingStep: OnboardingStep!
}

type UserOnboardingStepConnection {
  edges: [UserOnboardingStepEdge!]!
  pageInfo: PageInfo!
}

type UserOnboardingStepDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboardingStep!]!
}

type UserOnboardingStepEdge {
  cursor: String!
  node: UserOnboardingStep!
}

input UserOnboardingStepFilter {
  id: UUIDFilter
  userOnboardingId: UUIDFilter
  onboardingStepId: UUIDFilter
  createdAt: DatetimeFilter
  userSurveyId: UUIDFilter
  isCompleted: BooleanFilter
  isStarted: BooleanFilter
  startedAt: DatetimeFilter
  userFormId: UUIDFilter
  completedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserOnboardingStepFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserOnboardingStepFilter!]
  # Negates a filter
  not: UserOnboardingStepFilter
}

input UserOnboardingStepInsertInput {
  id: UUID
  userOnboardingId: UUID
  onboardingStepId: UUID
  createdAt: Datetime
  userSurveyId: UUID
  isCompleted: Boolean
  isStarted: Boolean
  startedAt: Datetime
  userFormId: UUID
  completedAt: Datetime
}

type UserOnboardingStepInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboardingStep!]!
}

input UserOnboardingStepOrderBy {
  id: OrderByDirection
  userOnboardingId: OrderByDirection
  onboardingStepId: OrderByDirection
  createdAt: OrderByDirection
  userSurveyId: OrderByDirection
  isCompleted: OrderByDirection
  isStarted: OrderByDirection
  startedAt: OrderByDirection
  userFormId: OrderByDirection
  completedAt: OrderByDirection
}

input UserOnboardingStepUpdateInput {
  id: UUID
  userOnboardingId: UUID
  onboardingStepId: UUID
  createdAt: Datetime
  userSurveyId: UUID
  isCompleted: Boolean
  isStarted: Boolean
  startedAt: Datetime
  userFormId: UUID
  completedAt: Datetime
}

type UserOnboardingStepUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboardingStep!]!
}

input UserOnboardingUpdateInput {
  id: UUID
  userId: UUID
  onboardingId: UUID
  createdAt: Datetime
  isStarted: Boolean
  startedAt: Datetime
  isCompleted: Boolean
  completedAt: Datetime
  data: JSON
}

type UserOnboardingUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserOnboarding!]!
}

input UserOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  email: OrderByDirection
  lastName: OrderByDirection
  firstName: OrderByDirection
  avatarUrl: OrderByDirection
  displayName: OrderByDirection
  updatedAt: OrderByDirection
  kratosId: OrderByDirection
  supabaseUserId: OrderByDirection
}

type UserPersona implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  personaId: UUID!
  createdAt: Datetime!
  data: JSON
  user: User
  persona: Persona!
}

type UserPersonaConnection {
  edges: [UserPersonaEdge!]!
  pageInfo: PageInfo!
}

type UserPersonaDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserPersona!]!
}

type UserPersonaEdge {
  cursor: String!
  node: UserPersona!
}

input UserPersonaFilter {
  id: UUIDFilter
  userId: UUIDFilter
  personaId: UUIDFilter
  createdAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserPersonaFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserPersonaFilter!]
  # Negates a filter
  not: UserPersonaFilter
}

input UserPersonaInsertInput {
  id: UUID
  userId: UUID
  personaId: UUID
  createdAt: Datetime
  data: JSON
}

type UserPersonaInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserPersona!]!
}

input UserPersonaOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  personaId: OrderByDirection
  createdAt: OrderByDirection
}

input UserPersonaUpdateInput {
  id: UUID
  userId: UUID
  personaId: UUID
  createdAt: Datetime
  data: JSON
}

type UserPersonaUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserPersona!]!
}

type UserProfile implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  profileTypeId: UUID!
  data: JSON
  createdAt: Datetime!
  updatedAt: Datetime
  user: User
  profileType: ProfileType!
}

type UserProfileConnection {
  edges: [UserProfileEdge!]!
  pageInfo: PageInfo!
}

type UserProfileDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserProfile!]!
}

type UserProfileEdge {
  cursor: String!
  node: UserProfile!
}

input UserProfileFilter {
  id: UUIDFilter
  userId: UUIDFilter
  profileTypeId: UUIDFilter
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserProfileFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserProfileFilter!]
  # Negates a filter
  not: UserProfileFilter
}

input UserProfileInsertInput {
  id: UUID
  userId: UUID
  profileTypeId: UUID
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
}

type UserProfileInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserProfile!]!
}

input UserProfileOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  profileTypeId: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input UserProfileUpdateInput {
  id: UUID
  userId: UUID
  profileTypeId: UUID
  data: JSON
  createdAt: Datetime
  updatedAt: Datetime
}

type UserProfileUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserProfile!]!
}

type UserRole implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  userId: UUID!
  roleId: UUID!
  data: JSON
  user: User
  role: Role!
}

type UserRoleConnection {
  edges: [UserRoleEdge!]!
  pageInfo: PageInfo!
}

type UserRoleDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserRole!]!
}

type UserRoleEdge {
  cursor: String!
  node: UserRole!
}

input UserRoleFilter {
  id: UUIDFilter
  createdAt: DatetimeFilter
  userId: UUIDFilter
  roleId: UUIDFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserRoleFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserRoleFilter!]
  # Negates a filter
  not: UserRoleFilter
}

input UserRoleInsertInput {
  id: UUID
  createdAt: Datetime
  userId: UUID
  roleId: UUID
  data: JSON
}

type UserRoleInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserRole!]!
}

input UserRoleOrderBy {
  id: OrderByDirection
  createdAt: OrderByDirection
  userId: OrderByDirection
  roleId: OrderByDirection
}

input UserRoleUpdateInput {
  id: UUID
  createdAt: Datetime
  userId: UUID
  roleId: UUID
  data: JSON
}

type UserRoleUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserRole!]!
}

type UserSurvey implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userId: UUID!
  surveyId: UUID!
  isStarted: Boolean!
  createdAt: Datetime!
  startedAt: Datetime
  isComplete: Boolean!
  completedAt: Datetime
  isAbandoned: Boolean!
  abandonedAt: Datetime
  updatedAt: Datetime
  data: JSON
  user: User
  survey: Survey
  userOnboardingStepCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserOnboardingStepFilter
    # Sort order to apply to the collection
    orderBy: [UserOnboardingStepOrderBy!]
  ): UserOnboardingStepConnection
  userSurveyAnswerCollection(
    # Query the first `n` records in the collection
    first: Int
    # Query the last `n` records in the collection
    last: Int
    # Query values in the collection before the provided cursor
    before: Cursor
    # Query values in the collection after the provided cursor
    after: Cursor
    # Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    offset: Int
    # Filters to apply to the results set when querying from the collection
    filter: UserSurveyAnswerFilter
    # Sort order to apply to the collection
    orderBy: [UserSurveyAnswerOrderBy!]
  ): UserSurveyAnswerConnection
}

type UserSurveyAnswer implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  userSurveyId: UUID
  createdAt: Datetime!
  surveyQuestionId: UUID!
  answerChoiceId: UUID
  data: JSON
  answerText: String
  updatedAt: Datetime
  userSurvey: UserSurvey
  surveyQuestion: SurveyQuestion
  answerChoice: AnswerChoice
}

type UserSurveyAnswerConnection {
  edges: [UserSurveyAnswerEdge!]!
  pageInfo: PageInfo!
}

type UserSurveyAnswerDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurveyAnswer!]!
}

type UserSurveyAnswerEdge {
  cursor: String!
  node: UserSurveyAnswer!
}

input UserSurveyAnswerFilter {
  id: UUIDFilter
  userSurveyId: UUIDFilter
  createdAt: DatetimeFilter
  surveyQuestionId: UUIDFilter
  answerChoiceId: UUIDFilter
  answerText: StringFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserSurveyAnswerFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserSurveyAnswerFilter!]
  # Negates a filter
  not: UserSurveyAnswerFilter
}

input UserSurveyAnswerInsertInput {
  id: UUID
  userSurveyId: UUID
  createdAt: Datetime
  surveyQuestionId: UUID
  answerChoiceId: UUID
  data: JSON
  answerText: String
  updatedAt: Datetime
}

type UserSurveyAnswerInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurveyAnswer!]!
}

input UserSurveyAnswerOrderBy {
  id: OrderByDirection
  userSurveyId: OrderByDirection
  createdAt: OrderByDirection
  surveyQuestionId: OrderByDirection
  answerChoiceId: OrderByDirection
  answerText: OrderByDirection
  updatedAt: OrderByDirection
}

input UserSurveyAnswerUpdateInput {
  id: UUID
  userSurveyId: UUID
  createdAt: Datetime
  surveyQuestionId: UUID
  answerChoiceId: UUID
  data: JSON
  answerText: String
  updatedAt: Datetime
}

type UserSurveyAnswerUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurveyAnswer!]!
}

type UserSurveyConnection {
  edges: [UserSurveyEdge!]!
  pageInfo: PageInfo!
}

type UserSurveyDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurvey!]!
}

type UserSurveyEdge {
  cursor: String!
  node: UserSurvey!
}

input UserSurveyFilter {
  id: UUIDFilter
  userId: UUIDFilter
  surveyId: UUIDFilter
  isStarted: BooleanFilter
  createdAt: DatetimeFilter
  startedAt: DatetimeFilter
  isComplete: BooleanFilter
  completedAt: DatetimeFilter
  isAbandoned: BooleanFilter
  abandonedAt: DatetimeFilter
  updatedAt: DatetimeFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [UserSurveyFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [UserSurveyFilter!]
  # Negates a filter
  not: UserSurveyFilter
}

input UserSurveyInsertInput {
  id: UUID
  userId: UUID
  surveyId: UUID
  isStarted: Boolean
  createdAt: Datetime
  startedAt: Datetime
  isComplete: Boolean
  completedAt: Datetime
  isAbandoned: Boolean
  abandonedAt: Datetime
  updatedAt: Datetime
  data: JSON
}

type UserSurveyInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurvey!]!
}

input UserSurveyOrderBy {
  id: OrderByDirection
  userId: OrderByDirection
  surveyId: OrderByDirection
  isStarted: OrderByDirection
  createdAt: OrderByDirection
  startedAt: OrderByDirection
  isComplete: OrderByDirection
  completedAt: OrderByDirection
  isAbandoned: OrderByDirection
  abandonedAt: OrderByDirection
  updatedAt: OrderByDirection
}

input UserSurveyUpdateInput {
  id: UUID
  userId: UUID
  surveyId: UUID
  isStarted: Boolean
  createdAt: Datetime
  startedAt: Datetime
  isComplete: Boolean
  completedAt: Datetime
  isAbandoned: Boolean
  abandonedAt: Datetime
  updatedAt: Datetime
  data: JSON
}

type UserSurveyUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [UserSurvey!]!
}

input UserUpdateInput {
  id: UUID
  createdAt: Datetime
  email: String
  data: JSON
  lastName: String
  firstName: String
  avatarUrl: String
  displayName: String
  updatedAt: Datetime
  kratosId: UUID
  supabaseUserId: UUID
}

type UserUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [User!]!
}

# A universally unique identifier
scalar UUID

# Boolean expression comparing fields on type "UUID"
input UUIDFilter {
  eq: UUID
  in: [UUID!]
  is: FilterIs
  neq: UUID
}

# Boolean expression comparing fields on type "UUIDList"
input UUIDListFilter {
  containedBy: [UUID!]
  contains: [UUID!]
  eq: [UUID!]
  is: FilterIs
  overlaps: [UUID!]
}

type VectorDatabase implements Node {
  # Globally Unique Record Identifier
  nodeId: ID!
  id: UUID!
  name: String!
  key: String!
  url: String!
  data: JSON
  createdAt: Datetime!
  iconUrl: String
}

type VectorDatabaseConnection {
  edges: [VectorDatabaseEdge!]!
  pageInfo: PageInfo!
}

type VectorDatabaseDeleteResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [VectorDatabase!]!
}

type VectorDatabaseEdge {
  cursor: String!
  node: VectorDatabase!
}

input VectorDatabaseFilter {
  id: UUIDFilter
  name: StringFilter
  key: StringFilter
  url: StringFilter
  createdAt: DatetimeFilter
  iconUrl: StringFilter
  nodeId: IDFilter
  # Returns true only if all its inner filters are true, otherwise returns false
  and: [VectorDatabaseFilter!]
  # Returns true if at least one of its inner filters is true, otherwise returns false
  or: [VectorDatabaseFilter!]
  # Negates a filter
  not: VectorDatabaseFilter
}

input VectorDatabaseInsertInput {
  id: UUID
  name: String
  key: String
  url: String
  data: JSON
  createdAt: Datetime
  iconUrl: String
}

type VectorDatabaseInsertResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [VectorDatabase!]!
}

input VectorDatabaseOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  key: OrderByDirection
  url: OrderByDirection
  createdAt: OrderByDirection
  iconUrl: OrderByDirection
}

input VectorDatabaseUpdateInput {
  id: UUID
  name: String
  key: String
  url: String
  data: JSON
  createdAt: Datetime
  iconUrl: String
}

type VectorDatabaseUpdateResponse {
  # Count of the records impacted by the mutation
  affectedCount: Int!
  # Array of records impacted by the mutation
  records: [VectorDatabase!]!
}

