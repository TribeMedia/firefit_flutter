import 'package:core/scalars.dart';

class Input$AgentFilter {
  factory Input$AgentFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$IDFilter? nodeId,
    List<Input$AgentFilter>? and,
    List<Input$AgentFilter>? or,
    Input$AgentFilter? not,
  }) =>
      Input$AgentFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AgentFilter._(this._$data);

  factory Input$AgentFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$AgentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$AgentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AgentFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AgentFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AgentFilter>? get and =>
      (_$data['and'] as List<Input$AgentFilter>?);

  List<Input$AgentFilter>? get or => (_$data['or'] as List<Input$AgentFilter>?);

  Input$AgentFilter? get not => (_$data['not'] as Input$AgentFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AgentFilter<Input$AgentFilter> get copyWith =>
      CopyWith$Input$AgentFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentFilter<TRes> {
  factory CopyWith$Input$AgentFilter(
    Input$AgentFilter instance,
    TRes Function(Input$AgentFilter) then,
  ) = _CopyWithImpl$Input$AgentFilter;

  factory CopyWith$Input$AgentFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$IDFilter? nodeId,
    List<Input$AgentFilter>? and,
    List<Input$AgentFilter>? or,
    Input$AgentFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AgentFilter>? Function(
              Iterable<CopyWith$Input$AgentFilter<Input$AgentFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AgentFilter>? Function(
              Iterable<CopyWith$Input$AgentFilter<Input$AgentFilter>>?)
          _fn);
  CopyWith$Input$AgentFilter<TRes> get not;
}

class _CopyWithImpl$Input$AgentFilter<TRes>
    implements CopyWith$Input$AgentFilter<TRes> {
  _CopyWithImpl$Input$AgentFilter(
    this._instance,
    this._then,
  );

  final Input$AgentFilter _instance;

  final TRes Function(Input$AgentFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AgentFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AgentFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AgentFilter>?),
        if (not != _undefined) 'not': (not as Input$AgentFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AgentFilter>? Function(
                  Iterable<CopyWith$Input$AgentFilter<Input$AgentFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AgentFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AgentFilter>? Function(
                  Iterable<CopyWith$Input$AgentFilter<Input$AgentFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AgentFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AgentFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AgentFilter.stub(_then(_instance))
        : CopyWith$Input$AgentFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AgentFilter<TRes>
    implements CopyWith$Input$AgentFilter<TRes> {
  _CopyWithStubImpl$Input$AgentFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$IDFilter? nodeId,
    List<Input$AgentFilter>? and,
    List<Input$AgentFilter>? or,
    Input$AgentFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AgentFilter<TRes> get not =>
      CopyWith$Input$AgentFilter.stub(_res);
}

class Input$AgentInsertInput {
  factory Input$AgentInsertInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  }) =>
      Input$AgentInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (metadata != null) r'metadata': metadata,
      });

  Input$AgentInsertInput._(this._$data);

  factory Input$AgentInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    return Input$AgentInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    return result$data;
  }

  CopyWith$Input$AgentInsertInput<Input$AgentInsertInput> get copyWith =>
      CopyWith$Input$AgentInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentInsertInput<TRes> {
  factory CopyWith$Input$AgentInsertInput(
    Input$AgentInsertInput instance,
    TRes Function(Input$AgentInsertInput) then,
  ) = _CopyWithImpl$Input$AgentInsertInput;

  factory CopyWith$Input$AgentInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  });
}

class _CopyWithImpl$Input$AgentInsertInput<TRes>
    implements CopyWith$Input$AgentInsertInput<TRes> {
  _CopyWithImpl$Input$AgentInsertInput(
    this._instance,
    this._then,
  );

  final Input$AgentInsertInput _instance;

  final TRes Function(Input$AgentInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$AgentInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$AgentInsertInput<TRes>
    implements CopyWith$Input$AgentInsertInput<TRes> {
  _CopyWithStubImpl$Input$AgentInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  }) =>
      _res;
}

class Input$AgentOrderBy {
  factory Input$AgentOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
  }) =>
      Input$AgentOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
      });

  Input$AgentOrderBy._(this._$data);

  factory Input$AgentOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    return Input$AgentOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    return result$data;
  }

  CopyWith$Input$AgentOrderBy<Input$AgentOrderBy> get copyWith =>
      CopyWith$Input$AgentOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentOrderBy<TRes> {
  factory CopyWith$Input$AgentOrderBy(
    Input$AgentOrderBy instance,
    TRes Function(Input$AgentOrderBy) then,
  ) = _CopyWithImpl$Input$AgentOrderBy;

  factory CopyWith$Input$AgentOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
  });
}

class _CopyWithImpl$Input$AgentOrderBy<TRes>
    implements CopyWith$Input$AgentOrderBy<TRes> {
  _CopyWithImpl$Input$AgentOrderBy(
    this._instance,
    this._then,
  );

  final Input$AgentOrderBy _instance;

  final TRes Function(Input$AgentOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
  }) =>
      _then(Input$AgentOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AgentOrderBy<TRes>
    implements CopyWith$Input$AgentOrderBy<TRes> {
  _CopyWithStubImpl$Input$AgentOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
  }) =>
      _res;
}

class Input$AgentToolFilter {
  factory Input$AgentToolFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? agentId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$AgentToolFilter>? and,
    List<Input$AgentToolFilter>? or,
    Input$AgentToolFilter? not,
  }) =>
      Input$AgentToolFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (agentId != null) r'agentId': agentId,
        if (toolId != null) r'toolId': toolId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AgentToolFilter._(this._$data);

  factory Input$AgentToolFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = l$agentId == null
          ? null
          : Input$UUIDFilter.fromJson((l$agentId as Map<String, dynamic>));
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = l$toolId == null
          ? null
          : Input$UUIDFilter.fromJson((l$toolId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AgentToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AgentToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AgentToolFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AgentToolFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get agentId => (_$data['agentId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get toolId => (_$data['toolId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AgentToolFilter>? get and =>
      (_$data['and'] as List<Input$AgentToolFilter>?);

  List<Input$AgentToolFilter>? get or =>
      (_$data['or'] as List<Input$AgentToolFilter>?);

  Input$AgentToolFilter? get not => (_$data['not'] as Input$AgentToolFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId?.toJson();
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AgentToolFilter<Input$AgentToolFilter> get copyWith =>
      CopyWith$Input$AgentToolFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentToolFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$agentId = agentId;
    final l$toolId = toolId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentToolFilter<TRes> {
  factory CopyWith$Input$AgentToolFilter(
    Input$AgentToolFilter instance,
    TRes Function(Input$AgentToolFilter) then,
  ) = _CopyWithImpl$Input$AgentToolFilter;

  factory CopyWith$Input$AgentToolFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentToolFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? agentId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$AgentToolFilter>? and,
    List<Input$AgentToolFilter>? or,
    Input$AgentToolFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get agentId;
  CopyWith$Input$UUIDFilter<TRes> get toolId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AgentToolFilter>? Function(
              Iterable<CopyWith$Input$AgentToolFilter<Input$AgentToolFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AgentToolFilter>? Function(
              Iterable<CopyWith$Input$AgentToolFilter<Input$AgentToolFilter>>?)
          _fn);
  CopyWith$Input$AgentToolFilter<TRes> get not;
}

class _CopyWithImpl$Input$AgentToolFilter<TRes>
    implements CopyWith$Input$AgentToolFilter<TRes> {
  _CopyWithImpl$Input$AgentToolFilter(
    this._instance,
    this._then,
  );

  final Input$AgentToolFilter _instance;

  final TRes Function(Input$AgentToolFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? agentId = _undefined,
    Object? toolId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AgentToolFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (agentId != _undefined) 'agentId': (agentId as Input$UUIDFilter?),
        if (toolId != _undefined) 'toolId': (toolId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AgentToolFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AgentToolFilter>?),
        if (not != _undefined) 'not': (not as Input$AgentToolFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get agentId {
    final local$agentId = _instance.agentId;
    return local$agentId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$agentId, (e) => call(agentId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get toolId {
    final local$toolId = _instance.toolId;
    return local$toolId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$toolId, (e) => call(toolId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AgentToolFilter>? Function(
                  Iterable<
                      CopyWith$Input$AgentToolFilter<Input$AgentToolFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AgentToolFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AgentToolFilter>? Function(
                  Iterable<
                      CopyWith$Input$AgentToolFilter<Input$AgentToolFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AgentToolFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AgentToolFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AgentToolFilter.stub(_then(_instance))
        : CopyWith$Input$AgentToolFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AgentToolFilter<TRes>
    implements CopyWith$Input$AgentToolFilter<TRes> {
  _CopyWithStubImpl$Input$AgentToolFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? agentId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$AgentToolFilter>? and,
    List<Input$AgentToolFilter>? or,
    Input$AgentToolFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get agentId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get toolId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AgentToolFilter<TRes> get not =>
      CopyWith$Input$AgentToolFilter.stub(_res);
}

class Input$AgentToolInsertInput {
  factory Input$AgentToolInsertInput({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  }) =>
      Input$AgentToolInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (agentId != null) r'agentId': agentId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$AgentToolInsertInput._(this._$data);

  factory Input$AgentToolInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = (l$agentId as String?);
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = (l$toolId as String?);
    }
    return Input$AgentToolInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get agentId => (_$data['agentId'] as String?);

  String? get toolId => (_$data['toolId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId;
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId;
    }
    return result$data;
  }

  CopyWith$Input$AgentToolInsertInput<Input$AgentToolInsertInput>
      get copyWith => CopyWith$Input$AgentToolInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentToolInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$agentId = agentId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentToolInsertInput<TRes> {
  factory CopyWith$Input$AgentToolInsertInput(
    Input$AgentToolInsertInput instance,
    TRes Function(Input$AgentToolInsertInput) then,
  ) = _CopyWithImpl$Input$AgentToolInsertInput;

  factory CopyWith$Input$AgentToolInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentToolInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  });
}

class _CopyWithImpl$Input$AgentToolInsertInput<TRes>
    implements CopyWith$Input$AgentToolInsertInput<TRes> {
  _CopyWithImpl$Input$AgentToolInsertInput(
    this._instance,
    this._then,
  );

  final Input$AgentToolInsertInput _instance;

  final TRes Function(Input$AgentToolInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? agentId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$AgentToolInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (agentId != _undefined) 'agentId': (agentId as String?),
        if (toolId != _undefined) 'toolId': (toolId as String?),
      }));
}

class _CopyWithStubImpl$Input$AgentToolInsertInput<TRes>
    implements CopyWith$Input$AgentToolInsertInput<TRes> {
  _CopyWithStubImpl$Input$AgentToolInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  }) =>
      _res;
}

class Input$AgentToolOrderBy {
  factory Input$AgentToolOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? agentId,
    Enum$OrderByDirection? toolId,
  }) =>
      Input$AgentToolOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (agentId != null) r'agentId': agentId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$AgentToolOrderBy._(this._$data);

  factory Input$AgentToolOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = l$agentId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$agentId as String));
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = l$toolId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$toolId as String));
    }
    return Input$AgentToolOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get agentId =>
      (_$data['agentId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get toolId =>
      (_$data['toolId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] =
          l$agentId == null ? null : toJson$Enum$OrderByDirection(l$agentId);
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] =
          l$toolId == null ? null : toJson$Enum$OrderByDirection(l$toolId);
    }
    return result$data;
  }

  CopyWith$Input$AgentToolOrderBy<Input$AgentToolOrderBy> get copyWith =>
      CopyWith$Input$AgentToolOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentToolOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$agentId = agentId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentToolOrderBy<TRes> {
  factory CopyWith$Input$AgentToolOrderBy(
    Input$AgentToolOrderBy instance,
    TRes Function(Input$AgentToolOrderBy) then,
  ) = _CopyWithImpl$Input$AgentToolOrderBy;

  factory CopyWith$Input$AgentToolOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentToolOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? agentId,
    Enum$OrderByDirection? toolId,
  });
}

class _CopyWithImpl$Input$AgentToolOrderBy<TRes>
    implements CopyWith$Input$AgentToolOrderBy<TRes> {
  _CopyWithImpl$Input$AgentToolOrderBy(
    this._instance,
    this._then,
  );

  final Input$AgentToolOrderBy _instance;

  final TRes Function(Input$AgentToolOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? agentId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$AgentToolOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (agentId != _undefined)
          'agentId': (agentId as Enum$OrderByDirection?),
        if (toolId != _undefined) 'toolId': (toolId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AgentToolOrderBy<TRes>
    implements CopyWith$Input$AgentToolOrderBy<TRes> {
  _CopyWithStubImpl$Input$AgentToolOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? agentId,
    Enum$OrderByDirection? toolId,
  }) =>
      _res;
}

class Input$AgentToolUpdateInput {
  factory Input$AgentToolUpdateInput({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  }) =>
      Input$AgentToolUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (agentId != null) r'agentId': agentId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$AgentToolUpdateInput._(this._$data);

  factory Input$AgentToolUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = (l$agentId as String?);
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = (l$toolId as String?);
    }
    return Input$AgentToolUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get agentId => (_$data['agentId'] as String?);

  String? get toolId => (_$data['toolId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId;
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId;
    }
    return result$data;
  }

  CopyWith$Input$AgentToolUpdateInput<Input$AgentToolUpdateInput>
      get copyWith => CopyWith$Input$AgentToolUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentToolUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$agentId = agentId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentToolUpdateInput<TRes> {
  factory CopyWith$Input$AgentToolUpdateInput(
    Input$AgentToolUpdateInput instance,
    TRes Function(Input$AgentToolUpdateInput) then,
  ) = _CopyWithImpl$Input$AgentToolUpdateInput;

  factory CopyWith$Input$AgentToolUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentToolUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  });
}

class _CopyWithImpl$Input$AgentToolUpdateInput<TRes>
    implements CopyWith$Input$AgentToolUpdateInput<TRes> {
  _CopyWithImpl$Input$AgentToolUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AgentToolUpdateInput _instance;

  final TRes Function(Input$AgentToolUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? agentId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$AgentToolUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (agentId != _undefined) 'agentId': (agentId as String?),
        if (toolId != _undefined) 'toolId': (toolId as String?),
      }));
}

class _CopyWithStubImpl$Input$AgentToolUpdateInput<TRes>
    implements CopyWith$Input$AgentToolUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AgentToolUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? agentId,
    String? toolId,
  }) =>
      _res;
}

class Input$AgentUpdateInput {
  factory Input$AgentUpdateInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  }) =>
      Input$AgentUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (metadata != null) r'metadata': metadata,
      });

  Input$AgentUpdateInput._(this._$data);

  factory Input$AgentUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    return Input$AgentUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    return result$data;
  }

  CopyWith$Input$AgentUpdateInput<Input$AgentUpdateInput> get copyWith =>
      CopyWith$Input$AgentUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AgentUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
    ]);
  }
}

abstract class CopyWith$Input$AgentUpdateInput<TRes> {
  factory CopyWith$Input$AgentUpdateInput(
    Input$AgentUpdateInput instance,
    TRes Function(Input$AgentUpdateInput) then,
  ) = _CopyWithImpl$Input$AgentUpdateInput;

  factory CopyWith$Input$AgentUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AgentUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  });
}

class _CopyWithImpl$Input$AgentUpdateInput<TRes>
    implements CopyWith$Input$AgentUpdateInput<TRes> {
  _CopyWithImpl$Input$AgentUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AgentUpdateInput _instance;

  final TRes Function(Input$AgentUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$AgentUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$AgentUpdateInput<TRes>
    implements CopyWith$Input$AgentUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AgentUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? metadata,
  }) =>
      _res;
}

class Input$AiConfigFilter {
  factory Input$AiConfigFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? aiConfigTypeId,
    Input$StringFilter? baseUrl,
    Input$StringFilter? apiKey,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$AiConfigFilter>? and,
    List<Input$AiConfigFilter>? or,
    Input$AiConfigFilter? not,
  }) =>
      Input$AiConfigFilter._({
        if (id != null) r'id': id,
        if (aiConfigTypeId != null) r'aiConfigTypeId': aiConfigTypeId,
        if (baseUrl != null) r'baseUrl': baseUrl,
        if (apiKey != null) r'apiKey': apiKey,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (applicationId != null) r'applicationId': applicationId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AiConfigFilter._(this._$data);

  factory Input$AiConfigFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = data['aiConfigTypeId'];
      result$data['aiConfigTypeId'] = l$aiConfigTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$aiConfigTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('baseUrl')) {
      final l$baseUrl = data['baseUrl'];
      result$data['baseUrl'] = l$baseUrl == null
          ? null
          : Input$StringFilter.fromJson((l$baseUrl as Map<String, dynamic>));
    }
    if (data.containsKey('apiKey')) {
      final l$apiKey = data['apiKey'];
      result$data['apiKey'] = l$apiKey == null
          ? null
          : Input$StringFilter.fromJson((l$apiKey as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$AiConfigFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$AiConfigFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AiConfigFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AiConfigFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get aiConfigTypeId =>
      (_$data['aiConfigTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get baseUrl => (_$data['baseUrl'] as Input$StringFilter?);

  Input$StringFilter? get apiKey => (_$data['apiKey'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AiConfigFilter>? get and =>
      (_$data['and'] as List<Input$AiConfigFilter>?);

  List<Input$AiConfigFilter>? get or =>
      (_$data['or'] as List<Input$AiConfigFilter>?);

  Input$AiConfigFilter? get not => (_$data['not'] as Input$AiConfigFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = aiConfigTypeId;
      result$data['aiConfigTypeId'] = l$aiConfigTypeId?.toJson();
    }
    if (_$data.containsKey('baseUrl')) {
      final l$baseUrl = baseUrl;
      result$data['baseUrl'] = l$baseUrl?.toJson();
    }
    if (_$data.containsKey('apiKey')) {
      final l$apiKey = apiKey;
      result$data['apiKey'] = l$apiKey?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AiConfigFilter<Input$AiConfigFilter> get copyWith =>
      CopyWith$Input$AiConfigFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$aiConfigTypeId = aiConfigTypeId;
    final lOther$aiConfigTypeId = other.aiConfigTypeId;
    if (_$data.containsKey('aiConfigTypeId') !=
        other._$data.containsKey('aiConfigTypeId')) {
      return false;
    }
    if (l$aiConfigTypeId != lOther$aiConfigTypeId) {
      return false;
    }
    final l$baseUrl = baseUrl;
    final lOther$baseUrl = other.baseUrl;
    if (_$data.containsKey('baseUrl') != other._$data.containsKey('baseUrl')) {
      return false;
    }
    if (l$baseUrl != lOther$baseUrl) {
      return false;
    }
    final l$apiKey = apiKey;
    final lOther$apiKey = other.apiKey;
    if (_$data.containsKey('apiKey') != other._$data.containsKey('apiKey')) {
      return false;
    }
    if (l$apiKey != lOther$apiKey) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$aiConfigTypeId = aiConfigTypeId;
    final l$baseUrl = baseUrl;
    final l$apiKey = apiKey;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$name = name;
    final l$key = key;
    final l$applicationId = applicationId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('aiConfigTypeId') ? l$aiConfigTypeId : const {},
      _$data.containsKey('baseUrl') ? l$baseUrl : const {},
      _$data.containsKey('apiKey') ? l$apiKey : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigFilter<TRes> {
  factory CopyWith$Input$AiConfigFilter(
    Input$AiConfigFilter instance,
    TRes Function(Input$AiConfigFilter) then,
  ) = _CopyWithImpl$Input$AiConfigFilter;

  factory CopyWith$Input$AiConfigFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? aiConfigTypeId,
    Input$StringFilter? baseUrl,
    Input$StringFilter? apiKey,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$AiConfigFilter>? and,
    List<Input$AiConfigFilter>? or,
    Input$AiConfigFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get aiConfigTypeId;
  CopyWith$Input$StringFilter<TRes> get baseUrl;
  CopyWith$Input$StringFilter<TRes> get apiKey;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AiConfigFilter>? Function(
              Iterable<CopyWith$Input$AiConfigFilter<Input$AiConfigFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AiConfigFilter>? Function(
              Iterable<CopyWith$Input$AiConfigFilter<Input$AiConfigFilter>>?)
          _fn);
  CopyWith$Input$AiConfigFilter<TRes> get not;
}

class _CopyWithImpl$Input$AiConfigFilter<TRes>
    implements CopyWith$Input$AiConfigFilter<TRes> {
  _CopyWithImpl$Input$AiConfigFilter(
    this._instance,
    this._then,
  );

  final Input$AiConfigFilter _instance;

  final TRes Function(Input$AiConfigFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? aiConfigTypeId = _undefined,
    Object? baseUrl = _undefined,
    Object? apiKey = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? applicationId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AiConfigFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (aiConfigTypeId != _undefined)
          'aiConfigTypeId': (aiConfigTypeId as Input$UUIDFilter?),
        if (baseUrl != _undefined) 'baseUrl': (baseUrl as Input$StringFilter?),
        if (apiKey != _undefined) 'apiKey': (apiKey as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AiConfigFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AiConfigFilter>?),
        if (not != _undefined) 'not': (not as Input$AiConfigFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get aiConfigTypeId {
    final local$aiConfigTypeId = _instance.aiConfigTypeId;
    return local$aiConfigTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$aiConfigTypeId, (e) => call(aiConfigTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get baseUrl {
    final local$baseUrl = _instance.baseUrl;
    return local$baseUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$baseUrl, (e) => call(baseUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get apiKey {
    final local$apiKey = _instance.apiKey;
    return local$apiKey == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$apiKey, (e) => call(apiKey: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AiConfigFilter>? Function(
                  Iterable<
                      CopyWith$Input$AiConfigFilter<Input$AiConfigFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AiConfigFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AiConfigFilter>? Function(
                  Iterable<
                      CopyWith$Input$AiConfigFilter<Input$AiConfigFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AiConfigFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AiConfigFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AiConfigFilter.stub(_then(_instance))
        : CopyWith$Input$AiConfigFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AiConfigFilter<TRes>
    implements CopyWith$Input$AiConfigFilter<TRes> {
  _CopyWithStubImpl$Input$AiConfigFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? aiConfigTypeId,
    Input$StringFilter? baseUrl,
    Input$StringFilter? apiKey,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$AiConfigFilter>? and,
    List<Input$AiConfigFilter>? or,
    Input$AiConfigFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get aiConfigTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get baseUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get apiKey =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AiConfigFilter<TRes> get not =>
      CopyWith$Input$AiConfigFilter.stub(_res);
}

class Input$AiConfigInsertInput {
  factory Input$AiConfigInsertInput({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  }) =>
      Input$AiConfigInsertInput._({
        if (id != null) r'id': id,
        if (aiConfigTypeId != null) r'aiConfigTypeId': aiConfigTypeId,
        if (baseUrl != null) r'baseUrl': baseUrl,
        if (apiKey != null) r'apiKey': apiKey,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$AiConfigInsertInput._(this._$data);

  factory Input$AiConfigInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = data['aiConfigTypeId'];
      result$data['aiConfigTypeId'] = (l$aiConfigTypeId as String?);
    }
    if (data.containsKey('baseUrl')) {
      final l$baseUrl = data['baseUrl'];
      result$data['baseUrl'] = (l$baseUrl as String?);
    }
    if (data.containsKey('apiKey')) {
      final l$apiKey = data['apiKey'];
      result$data['apiKey'] = (l$apiKey as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$AiConfigInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get aiConfigTypeId => (_$data['aiConfigTypeId'] as String?);

  String? get baseUrl => (_$data['baseUrl'] as String?);

  String? get apiKey => (_$data['apiKey'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = aiConfigTypeId;
      result$data['aiConfigTypeId'] = l$aiConfigTypeId;
    }
    if (_$data.containsKey('baseUrl')) {
      final l$baseUrl = baseUrl;
      result$data['baseUrl'] = l$baseUrl;
    }
    if (_$data.containsKey('apiKey')) {
      final l$apiKey = apiKey;
      result$data['apiKey'] = l$apiKey;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$AiConfigInsertInput<Input$AiConfigInsertInput> get copyWith =>
      CopyWith$Input$AiConfigInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$aiConfigTypeId = aiConfigTypeId;
    final lOther$aiConfigTypeId = other.aiConfigTypeId;
    if (_$data.containsKey('aiConfigTypeId') !=
        other._$data.containsKey('aiConfigTypeId')) {
      return false;
    }
    if (l$aiConfigTypeId != lOther$aiConfigTypeId) {
      return false;
    }
    final l$baseUrl = baseUrl;
    final lOther$baseUrl = other.baseUrl;
    if (_$data.containsKey('baseUrl') != other._$data.containsKey('baseUrl')) {
      return false;
    }
    if (l$baseUrl != lOther$baseUrl) {
      return false;
    }
    final l$apiKey = apiKey;
    final lOther$apiKey = other.apiKey;
    if (_$data.containsKey('apiKey') != other._$data.containsKey('apiKey')) {
      return false;
    }
    if (l$apiKey != lOther$apiKey) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$aiConfigTypeId = aiConfigTypeId;
    final l$baseUrl = baseUrl;
    final l$apiKey = apiKey;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$name = name;
    final l$key = key;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('aiConfigTypeId') ? l$aiConfigTypeId : const {},
      _$data.containsKey('baseUrl') ? l$baseUrl : const {},
      _$data.containsKey('apiKey') ? l$apiKey : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigInsertInput<TRes> {
  factory CopyWith$Input$AiConfigInsertInput(
    Input$AiConfigInsertInput instance,
    TRes Function(Input$AiConfigInsertInput) then,
  ) = _CopyWithImpl$Input$AiConfigInsertInput;

  factory CopyWith$Input$AiConfigInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigInsertInput;

  TRes call({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$AiConfigInsertInput<TRes>
    implements CopyWith$Input$AiConfigInsertInput<TRes> {
  _CopyWithImpl$Input$AiConfigInsertInput(
    this._instance,
    this._then,
  );

  final Input$AiConfigInsertInput _instance;

  final TRes Function(Input$AiConfigInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? aiConfigTypeId = _undefined,
    Object? baseUrl = _undefined,
    Object? apiKey = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$AiConfigInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (aiConfigTypeId != _undefined)
          'aiConfigTypeId': (aiConfigTypeId as String?),
        if (baseUrl != _undefined) 'baseUrl': (baseUrl as String?),
        if (apiKey != _undefined) 'apiKey': (apiKey as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigInsertInput<TRes>
    implements CopyWith$Input$AiConfigInsertInput<TRes> {
  _CopyWithStubImpl$Input$AiConfigInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  }) =>
      _res;
}

class Input$AiConfigOrderBy {
  factory Input$AiConfigOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? aiConfigTypeId,
    Enum$OrderByDirection? baseUrl,
    Enum$OrderByDirection? apiKey,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? applicationId,
  }) =>
      Input$AiConfigOrderBy._({
        if (id != null) r'id': id,
        if (aiConfigTypeId != null) r'aiConfigTypeId': aiConfigTypeId,
        if (baseUrl != null) r'baseUrl': baseUrl,
        if (apiKey != null) r'apiKey': apiKey,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$AiConfigOrderBy._(this._$data);

  factory Input$AiConfigOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = data['aiConfigTypeId'];
      result$data['aiConfigTypeId'] = l$aiConfigTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$aiConfigTypeId as String));
    }
    if (data.containsKey('baseUrl')) {
      final l$baseUrl = data['baseUrl'];
      result$data['baseUrl'] = l$baseUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$baseUrl as String));
    }
    if (data.containsKey('apiKey')) {
      final l$apiKey = data['apiKey'];
      result$data['apiKey'] = l$apiKey == null
          ? null
          : fromJson$Enum$OrderByDirection((l$apiKey as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    return Input$AiConfigOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get aiConfigTypeId =>
      (_$data['aiConfigTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get baseUrl =>
      (_$data['baseUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get apiKey =>
      (_$data['apiKey'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = aiConfigTypeId;
      result$data['aiConfigTypeId'] = l$aiConfigTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$aiConfigTypeId);
    }
    if (_$data.containsKey('baseUrl')) {
      final l$baseUrl = baseUrl;
      result$data['baseUrl'] =
          l$baseUrl == null ? null : toJson$Enum$OrderByDirection(l$baseUrl);
    }
    if (_$data.containsKey('apiKey')) {
      final l$apiKey = apiKey;
      result$data['apiKey'] =
          l$apiKey == null ? null : toJson$Enum$OrderByDirection(l$apiKey);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    return result$data;
  }

  CopyWith$Input$AiConfigOrderBy<Input$AiConfigOrderBy> get copyWith =>
      CopyWith$Input$AiConfigOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$aiConfigTypeId = aiConfigTypeId;
    final lOther$aiConfigTypeId = other.aiConfigTypeId;
    if (_$data.containsKey('aiConfigTypeId') !=
        other._$data.containsKey('aiConfigTypeId')) {
      return false;
    }
    if (l$aiConfigTypeId != lOther$aiConfigTypeId) {
      return false;
    }
    final l$baseUrl = baseUrl;
    final lOther$baseUrl = other.baseUrl;
    if (_$data.containsKey('baseUrl') != other._$data.containsKey('baseUrl')) {
      return false;
    }
    if (l$baseUrl != lOther$baseUrl) {
      return false;
    }
    final l$apiKey = apiKey;
    final lOther$apiKey = other.apiKey;
    if (_$data.containsKey('apiKey') != other._$data.containsKey('apiKey')) {
      return false;
    }
    if (l$apiKey != lOther$apiKey) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$aiConfigTypeId = aiConfigTypeId;
    final l$baseUrl = baseUrl;
    final l$apiKey = apiKey;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$name = name;
    final l$key = key;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('aiConfigTypeId') ? l$aiConfigTypeId : const {},
      _$data.containsKey('baseUrl') ? l$baseUrl : const {},
      _$data.containsKey('apiKey') ? l$apiKey : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigOrderBy<TRes> {
  factory CopyWith$Input$AiConfigOrderBy(
    Input$AiConfigOrderBy instance,
    TRes Function(Input$AiConfigOrderBy) then,
  ) = _CopyWithImpl$Input$AiConfigOrderBy;

  factory CopyWith$Input$AiConfigOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? aiConfigTypeId,
    Enum$OrderByDirection? baseUrl,
    Enum$OrderByDirection? apiKey,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? applicationId,
  });
}

class _CopyWithImpl$Input$AiConfigOrderBy<TRes>
    implements CopyWith$Input$AiConfigOrderBy<TRes> {
  _CopyWithImpl$Input$AiConfigOrderBy(
    this._instance,
    this._then,
  );

  final Input$AiConfigOrderBy _instance;

  final TRes Function(Input$AiConfigOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? aiConfigTypeId = _undefined,
    Object? baseUrl = _undefined,
    Object? apiKey = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$AiConfigOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (aiConfigTypeId != _undefined)
          'aiConfigTypeId': (aiConfigTypeId as Enum$OrderByDirection?),
        if (baseUrl != _undefined)
          'baseUrl': (baseUrl as Enum$OrderByDirection?),
        if (apiKey != _undefined) 'apiKey': (apiKey as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigOrderBy<TRes>
    implements CopyWith$Input$AiConfigOrderBy<TRes> {
  _CopyWithStubImpl$Input$AiConfigOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? aiConfigTypeId,
    Enum$OrderByDirection? baseUrl,
    Enum$OrderByDirection? apiKey,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? applicationId,
  }) =>
      _res;
}

class Input$AiConfigTypeFilter {
  factory Input$AiConfigTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AiConfigTypeFilter>? and,
    List<Input$AiConfigTypeFilter>? or,
    Input$AiConfigTypeFilter? not,
  }) =>
      Input$AiConfigTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AiConfigTypeFilter._(this._$data);

  factory Input$AiConfigTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AiConfigTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AiConfigTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AiConfigTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AiConfigTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AiConfigTypeFilter>? get and =>
      (_$data['and'] as List<Input$AiConfigTypeFilter>?);

  List<Input$AiConfigTypeFilter>? get or =>
      (_$data['or'] as List<Input$AiConfigTypeFilter>?);

  Input$AiConfigTypeFilter? get not =>
      (_$data['not'] as Input$AiConfigTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AiConfigTypeFilter<Input$AiConfigTypeFilter> get copyWith =>
      CopyWith$Input$AiConfigTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigTypeFilter<TRes> {
  factory CopyWith$Input$AiConfigTypeFilter(
    Input$AiConfigTypeFilter instance,
    TRes Function(Input$AiConfigTypeFilter) then,
  ) = _CopyWithImpl$Input$AiConfigTypeFilter;

  factory CopyWith$Input$AiConfigTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AiConfigTypeFilter>? and,
    List<Input$AiConfigTypeFilter>? or,
    Input$AiConfigTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AiConfigTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$AiConfigTypeFilter<Input$AiConfigTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AiConfigTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$AiConfigTypeFilter<Input$AiConfigTypeFilter>>?)
          _fn);
  CopyWith$Input$AiConfigTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$AiConfigTypeFilter<TRes>
    implements CopyWith$Input$AiConfigTypeFilter<TRes> {
  _CopyWithImpl$Input$AiConfigTypeFilter(
    this._instance,
    this._then,
  );

  final Input$AiConfigTypeFilter _instance;

  final TRes Function(Input$AiConfigTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AiConfigTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AiConfigTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AiConfigTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$AiConfigTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AiConfigTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AiConfigTypeFilter<
                          Input$AiConfigTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AiConfigTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AiConfigTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AiConfigTypeFilter<
                          Input$AiConfigTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AiConfigTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AiConfigTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AiConfigTypeFilter.stub(_then(_instance))
        : CopyWith$Input$AiConfigTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AiConfigTypeFilter<TRes>
    implements CopyWith$Input$AiConfigTypeFilter<TRes> {
  _CopyWithStubImpl$Input$AiConfigTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AiConfigTypeFilter>? and,
    List<Input$AiConfigTypeFilter>? or,
    Input$AiConfigTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AiConfigTypeFilter<TRes> get not =>
      CopyWith$Input$AiConfigTypeFilter.stub(_res);
}

class Input$AiConfigTypeInsertInput {
  factory Input$AiConfigTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$AiConfigTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AiConfigTypeInsertInput._(this._$data);

  factory Input$AiConfigTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AiConfigTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AiConfigTypeInsertInput<Input$AiConfigTypeInsertInput>
      get copyWith => CopyWith$Input$AiConfigTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigTypeInsertInput<TRes> {
  factory CopyWith$Input$AiConfigTypeInsertInput(
    Input$AiConfigTypeInsertInput instance,
    TRes Function(Input$AiConfigTypeInsertInput) then,
  ) = _CopyWithImpl$Input$AiConfigTypeInsertInput;

  factory CopyWith$Input$AiConfigTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AiConfigTypeInsertInput<TRes>
    implements CopyWith$Input$AiConfigTypeInsertInput<TRes> {
  _CopyWithImpl$Input$AiConfigTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$AiConfigTypeInsertInput _instance;

  final TRes Function(Input$AiConfigTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AiConfigTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigTypeInsertInput<TRes>
    implements CopyWith$Input$AiConfigTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$AiConfigTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AiConfigTypeOrderBy {
  factory Input$AiConfigTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$AiConfigTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AiConfigTypeOrderBy._(this._$data);

  factory Input$AiConfigTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$AiConfigTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$AiConfigTypeOrderBy<Input$AiConfigTypeOrderBy> get copyWith =>
      CopyWith$Input$AiConfigTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigTypeOrderBy<TRes> {
  factory CopyWith$Input$AiConfigTypeOrderBy(
    Input$AiConfigTypeOrderBy instance,
    TRes Function(Input$AiConfigTypeOrderBy) then,
  ) = _CopyWithImpl$Input$AiConfigTypeOrderBy;

  factory CopyWith$Input$AiConfigTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$AiConfigTypeOrderBy<TRes>
    implements CopyWith$Input$AiConfigTypeOrderBy<TRes> {
  _CopyWithImpl$Input$AiConfigTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$AiConfigTypeOrderBy _instance;

  final TRes Function(Input$AiConfigTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AiConfigTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigTypeOrderBy<TRes>
    implements CopyWith$Input$AiConfigTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$AiConfigTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$AiConfigTypeUpdateInput {
  factory Input$AiConfigTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$AiConfigTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AiConfigTypeUpdateInput._(this._$data);

  factory Input$AiConfigTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AiConfigTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AiConfigTypeUpdateInput<Input$AiConfigTypeUpdateInput>
      get copyWith => CopyWith$Input$AiConfigTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigTypeUpdateInput<TRes> {
  factory CopyWith$Input$AiConfigTypeUpdateInput(
    Input$AiConfigTypeUpdateInput instance,
    TRes Function(Input$AiConfigTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$AiConfigTypeUpdateInput;

  factory CopyWith$Input$AiConfigTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AiConfigTypeUpdateInput<TRes>
    implements CopyWith$Input$AiConfigTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$AiConfigTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AiConfigTypeUpdateInput _instance;

  final TRes Function(Input$AiConfigTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AiConfigTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigTypeUpdateInput<TRes>
    implements CopyWith$Input$AiConfigTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AiConfigTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AiConfigUpdateInput {
  factory Input$AiConfigUpdateInput({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  }) =>
      Input$AiConfigUpdateInput._({
        if (id != null) r'id': id,
        if (aiConfigTypeId != null) r'aiConfigTypeId': aiConfigTypeId,
        if (baseUrl != null) r'baseUrl': baseUrl,
        if (apiKey != null) r'apiKey': apiKey,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$AiConfigUpdateInput._(this._$data);

  factory Input$AiConfigUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = data['aiConfigTypeId'];
      result$data['aiConfigTypeId'] = (l$aiConfigTypeId as String?);
    }
    if (data.containsKey('baseUrl')) {
      final l$baseUrl = data['baseUrl'];
      result$data['baseUrl'] = (l$baseUrl as String?);
    }
    if (data.containsKey('apiKey')) {
      final l$apiKey = data['apiKey'];
      result$data['apiKey'] = (l$apiKey as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$AiConfigUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get aiConfigTypeId => (_$data['aiConfigTypeId'] as String?);

  String? get baseUrl => (_$data['baseUrl'] as String?);

  String? get apiKey => (_$data['apiKey'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('aiConfigTypeId')) {
      final l$aiConfigTypeId = aiConfigTypeId;
      result$data['aiConfigTypeId'] = l$aiConfigTypeId;
    }
    if (_$data.containsKey('baseUrl')) {
      final l$baseUrl = baseUrl;
      result$data['baseUrl'] = l$baseUrl;
    }
    if (_$data.containsKey('apiKey')) {
      final l$apiKey = apiKey;
      result$data['apiKey'] = l$apiKey;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$AiConfigUpdateInput<Input$AiConfigUpdateInput> get copyWith =>
      CopyWith$Input$AiConfigUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AiConfigUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$aiConfigTypeId = aiConfigTypeId;
    final lOther$aiConfigTypeId = other.aiConfigTypeId;
    if (_$data.containsKey('aiConfigTypeId') !=
        other._$data.containsKey('aiConfigTypeId')) {
      return false;
    }
    if (l$aiConfigTypeId != lOther$aiConfigTypeId) {
      return false;
    }
    final l$baseUrl = baseUrl;
    final lOther$baseUrl = other.baseUrl;
    if (_$data.containsKey('baseUrl') != other._$data.containsKey('baseUrl')) {
      return false;
    }
    if (l$baseUrl != lOther$baseUrl) {
      return false;
    }
    final l$apiKey = apiKey;
    final lOther$apiKey = other.apiKey;
    if (_$data.containsKey('apiKey') != other._$data.containsKey('apiKey')) {
      return false;
    }
    if (l$apiKey != lOther$apiKey) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$aiConfigTypeId = aiConfigTypeId;
    final l$baseUrl = baseUrl;
    final l$apiKey = apiKey;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$name = name;
    final l$key = key;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('aiConfigTypeId') ? l$aiConfigTypeId : const {},
      _$data.containsKey('baseUrl') ? l$baseUrl : const {},
      _$data.containsKey('apiKey') ? l$apiKey : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AiConfigUpdateInput<TRes> {
  factory CopyWith$Input$AiConfigUpdateInput(
    Input$AiConfigUpdateInput instance,
    TRes Function(Input$AiConfigUpdateInput) then,
  ) = _CopyWithImpl$Input$AiConfigUpdateInput;

  factory CopyWith$Input$AiConfigUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AiConfigUpdateInput;

  TRes call({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$AiConfigUpdateInput<TRes>
    implements CopyWith$Input$AiConfigUpdateInput<TRes> {
  _CopyWithImpl$Input$AiConfigUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AiConfigUpdateInput _instance;

  final TRes Function(Input$AiConfigUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? aiConfigTypeId = _undefined,
    Object? baseUrl = _undefined,
    Object? apiKey = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$AiConfigUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (aiConfigTypeId != _undefined)
          'aiConfigTypeId': (aiConfigTypeId as String?),
        if (baseUrl != _undefined) 'baseUrl': (baseUrl as String?),
        if (apiKey != _undefined) 'apiKey': (apiKey as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AiConfigUpdateInput<TRes>
    implements CopyWith$Input$AiConfigUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AiConfigUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? aiConfigTypeId,
    String? baseUrl,
    String? apiKey,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? name,
    String? key,
    String? applicationId,
  }) =>
      _res;
}

class Input$AnswerChoiceFilter {
  factory Input$AnswerChoiceFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$StringFilter? choiceText,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AnswerChoiceFilter>? and,
    List<Input$AnswerChoiceFilter>? or,
    Input$AnswerChoiceFilter? not,
  }) =>
      Input$AnswerChoiceFilter._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (choiceText != null) r'choiceText': choiceText,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AnswerChoiceFilter._(this._$data);

  factory Input$AnswerChoiceFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = l$choiceText == null
          ? null
          : Input$StringFilter.fromJson((l$choiceText as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AnswerChoiceFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AnswerChoiceFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AnswerChoiceFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AnswerChoiceFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$StringFilter? get choiceText =>
      (_$data['choiceText'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AnswerChoiceFilter>? get and =>
      (_$data['and'] as List<Input$AnswerChoiceFilter>?);

  List<Input$AnswerChoiceFilter>? get or =>
      (_$data['or'] as List<Input$AnswerChoiceFilter>?);

  Input$AnswerChoiceFilter? get not =>
      (_$data['not'] as Input$AnswerChoiceFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AnswerChoiceFilter<Input$AnswerChoiceFilter> get copyWith =>
      CopyWith$Input$AnswerChoiceFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AnswerChoiceFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$index = index;
    final l$choiceText = choiceText;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AnswerChoiceFilter<TRes> {
  factory CopyWith$Input$AnswerChoiceFilter(
    Input$AnswerChoiceFilter instance,
    TRes Function(Input$AnswerChoiceFilter) then,
  ) = _CopyWithImpl$Input$AnswerChoiceFilter;

  factory CopyWith$Input$AnswerChoiceFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AnswerChoiceFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$StringFilter? choiceText,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AnswerChoiceFilter>? and,
    List<Input$AnswerChoiceFilter>? or,
    Input$AnswerChoiceFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$StringFilter<TRes> get choiceText;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AnswerChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$AnswerChoiceFilter<Input$AnswerChoiceFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AnswerChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$AnswerChoiceFilter<Input$AnswerChoiceFilter>>?)
          _fn);
  CopyWith$Input$AnswerChoiceFilter<TRes> get not;
}

class _CopyWithImpl$Input$AnswerChoiceFilter<TRes>
    implements CopyWith$Input$AnswerChoiceFilter<TRes> {
  _CopyWithImpl$Input$AnswerChoiceFilter(
    this._instance,
    this._then,
  );

  final Input$AnswerChoiceFilter _instance;

  final TRes Function(Input$AnswerChoiceFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? choiceText = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AnswerChoiceFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (choiceText != _undefined)
          'choiceText': (choiceText as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AnswerChoiceFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AnswerChoiceFilter>?),
        if (not != _undefined) 'not': (not as Input$AnswerChoiceFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$StringFilter<TRes> get choiceText {
    final local$choiceText = _instance.choiceText;
    return local$choiceText == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$choiceText, (e) => call(choiceText: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AnswerChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$AnswerChoiceFilter<
                          Input$AnswerChoiceFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AnswerChoiceFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AnswerChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$AnswerChoiceFilter<
                          Input$AnswerChoiceFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AnswerChoiceFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AnswerChoiceFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AnswerChoiceFilter.stub(_then(_instance))
        : CopyWith$Input$AnswerChoiceFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AnswerChoiceFilter<TRes>
    implements CopyWith$Input$AnswerChoiceFilter<TRes> {
  _CopyWithStubImpl$Input$AnswerChoiceFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$StringFilter? choiceText,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AnswerChoiceFilter>? and,
    List<Input$AnswerChoiceFilter>? or,
    Input$AnswerChoiceFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get choiceText =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AnswerChoiceFilter<TRes> get not =>
      CopyWith$Input$AnswerChoiceFilter.stub(_res);
}

class Input$AnswerChoiceInsertInput {
  factory Input$AnswerChoiceInsertInput({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) =>
      Input$AnswerChoiceInsertInput._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (choiceText != null) r'choiceText': choiceText,
        if (metadata != null) r'metadata': metadata,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AnswerChoiceInsertInput._(this._$data);

  factory Input$AnswerChoiceInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = (l$choiceText as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AnswerChoiceInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  String? get choiceText => (_$data['choiceText'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AnswerChoiceInsertInput<Input$AnswerChoiceInsertInput>
      get copyWith => CopyWith$Input$AnswerChoiceInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AnswerChoiceInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$index = index;
    final l$choiceText = choiceText;
    final l$metadata = metadata;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AnswerChoiceInsertInput<TRes> {
  factory CopyWith$Input$AnswerChoiceInsertInput(
    Input$AnswerChoiceInsertInput instance,
    TRes Function(Input$AnswerChoiceInsertInput) then,
  ) = _CopyWithImpl$Input$AnswerChoiceInsertInput;

  factory CopyWith$Input$AnswerChoiceInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AnswerChoiceInsertInput;

  TRes call({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AnswerChoiceInsertInput<TRes>
    implements CopyWith$Input$AnswerChoiceInsertInput<TRes> {
  _CopyWithImpl$Input$AnswerChoiceInsertInput(
    this._instance,
    this._then,
  );

  final Input$AnswerChoiceInsertInput _instance;

  final TRes Function(Input$AnswerChoiceInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? choiceText = _undefined,
    Object? metadata = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AnswerChoiceInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (choiceText != _undefined) 'choiceText': (choiceText as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AnswerChoiceInsertInput<TRes>
    implements CopyWith$Input$AnswerChoiceInsertInput<TRes> {
  _CopyWithStubImpl$Input$AnswerChoiceInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AnswerChoiceOrderBy {
  factory Input$AnswerChoiceOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? choiceText,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$AnswerChoiceOrderBy._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (choiceText != null) r'choiceText': choiceText,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AnswerChoiceOrderBy._(this._$data);

  factory Input$AnswerChoiceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = l$choiceText == null
          ? null
          : fromJson$Enum$OrderByDirection((l$choiceText as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$AnswerChoiceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get choiceText =>
      (_$data['choiceText'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText == null
          ? null
          : toJson$Enum$OrderByDirection(l$choiceText);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$AnswerChoiceOrderBy<Input$AnswerChoiceOrderBy> get copyWith =>
      CopyWith$Input$AnswerChoiceOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AnswerChoiceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$index = index;
    final l$choiceText = choiceText;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AnswerChoiceOrderBy<TRes> {
  factory CopyWith$Input$AnswerChoiceOrderBy(
    Input$AnswerChoiceOrderBy instance,
    TRes Function(Input$AnswerChoiceOrderBy) then,
  ) = _CopyWithImpl$Input$AnswerChoiceOrderBy;

  factory CopyWith$Input$AnswerChoiceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AnswerChoiceOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? choiceText,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$AnswerChoiceOrderBy<TRes>
    implements CopyWith$Input$AnswerChoiceOrderBy<TRes> {
  _CopyWithImpl$Input$AnswerChoiceOrderBy(
    this._instance,
    this._then,
  );

  final Input$AnswerChoiceOrderBy _instance;

  final TRes Function(Input$AnswerChoiceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? choiceText = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AnswerChoiceOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (choiceText != _undefined)
          'choiceText': (choiceText as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AnswerChoiceOrderBy<TRes>
    implements CopyWith$Input$AnswerChoiceOrderBy<TRes> {
  _CopyWithStubImpl$Input$AnswerChoiceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? choiceText,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$AnswerChoiceUpdateInput {
  factory Input$AnswerChoiceUpdateInput({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) =>
      Input$AnswerChoiceUpdateInput._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (choiceText != null) r'choiceText': choiceText,
        if (metadata != null) r'metadata': metadata,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AnswerChoiceUpdateInput._(this._$data);

  factory Input$AnswerChoiceUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = (l$choiceText as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AnswerChoiceUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  String? get choiceText => (_$data['choiceText'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AnswerChoiceUpdateInput<Input$AnswerChoiceUpdateInput>
      get copyWith => CopyWith$Input$AnswerChoiceUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AnswerChoiceUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$index = index;
    final l$choiceText = choiceText;
    final l$metadata = metadata;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AnswerChoiceUpdateInput<TRes> {
  factory CopyWith$Input$AnswerChoiceUpdateInput(
    Input$AnswerChoiceUpdateInput instance,
    TRes Function(Input$AnswerChoiceUpdateInput) then,
  ) = _CopyWithImpl$Input$AnswerChoiceUpdateInput;

  factory CopyWith$Input$AnswerChoiceUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AnswerChoiceUpdateInput;

  TRes call({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AnswerChoiceUpdateInput<TRes>
    implements CopyWith$Input$AnswerChoiceUpdateInput<TRes> {
  _CopyWithImpl$Input$AnswerChoiceUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AnswerChoiceUpdateInput _instance;

  final TRes Function(Input$AnswerChoiceUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? choiceText = _undefined,
    Object? metadata = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AnswerChoiceUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (choiceText != _undefined) 'choiceText': (choiceText as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AnswerChoiceUpdateInput<TRes>
    implements CopyWith$Input$AnswerChoiceUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AnswerChoiceUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionId,
    int? index,
    String? choiceText,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ApiTypeFilter {
  factory Input$ApiTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApiTypeFilter>? and,
    List<Input$ApiTypeFilter>? or,
    Input$ApiTypeFilter? not,
  }) =>
      Input$ApiTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApiTypeFilter._(this._$data);

  factory Input$ApiTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$ApiTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$ApiTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApiTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ApiTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApiTypeFilter>? get and =>
      (_$data['and'] as List<Input$ApiTypeFilter>?);

  List<Input$ApiTypeFilter>? get or =>
      (_$data['or'] as List<Input$ApiTypeFilter>?);

  Input$ApiTypeFilter? get not => (_$data['not'] as Input$ApiTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApiTypeFilter<Input$ApiTypeFilter> get copyWith =>
      CopyWith$Input$ApiTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApiTypeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApiTypeFilter<TRes> {
  factory CopyWith$Input$ApiTypeFilter(
    Input$ApiTypeFilter instance,
    TRes Function(Input$ApiTypeFilter) then,
  ) = _CopyWithImpl$Input$ApiTypeFilter;

  factory CopyWith$Input$ApiTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApiTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApiTypeFilter>? and,
    List<Input$ApiTypeFilter>? or,
    Input$ApiTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApiTypeFilter>? Function(
              Iterable<CopyWith$Input$ApiTypeFilter<Input$ApiTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApiTypeFilter>? Function(
              Iterable<CopyWith$Input$ApiTypeFilter<Input$ApiTypeFilter>>?)
          _fn);
  CopyWith$Input$ApiTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApiTypeFilter<TRes>
    implements CopyWith$Input$ApiTypeFilter<TRes> {
  _CopyWithImpl$Input$ApiTypeFilter(
    this._instance,
    this._then,
  );

  final Input$ApiTypeFilter _instance;

  final TRes Function(Input$ApiTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApiTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ApiTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApiTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$ApiTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApiTypeFilter>? Function(
                  Iterable<CopyWith$Input$ApiTypeFilter<Input$ApiTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ApiTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ApiTypeFilter>? Function(
                  Iterable<CopyWith$Input$ApiTypeFilter<Input$ApiTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ApiTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ApiTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApiTypeFilter.stub(_then(_instance))
        : CopyWith$Input$ApiTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApiTypeFilter<TRes>
    implements CopyWith$Input$ApiTypeFilter<TRes> {
  _CopyWithStubImpl$Input$ApiTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApiTypeFilter>? and,
    List<Input$ApiTypeFilter>? or,
    Input$ApiTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApiTypeFilter<TRes> get not =>
      CopyWith$Input$ApiTypeFilter.stub(_res);
}

class Input$ApiTypeInsertInput {
  factory Input$ApiTypeInsertInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ApiTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApiTypeInsertInput._(this._$data);

  factory Input$ApiTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ApiTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ApiTypeInsertInput<Input$ApiTypeInsertInput> get copyWith =>
      CopyWith$Input$ApiTypeInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApiTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApiTypeInsertInput<TRes> {
  factory CopyWith$Input$ApiTypeInsertInput(
    Input$ApiTypeInsertInput instance,
    TRes Function(Input$ApiTypeInsertInput) then,
  ) = _CopyWithImpl$Input$ApiTypeInsertInput;

  factory CopyWith$Input$ApiTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApiTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ApiTypeInsertInput<TRes>
    implements CopyWith$Input$ApiTypeInsertInput<TRes> {
  _CopyWithImpl$Input$ApiTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApiTypeInsertInput _instance;

  final TRes Function(Input$ApiTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApiTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ApiTypeInsertInput<TRes>
    implements CopyWith$Input$ApiTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApiTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ApiTypeOrderBy {
  factory Input$ApiTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ApiTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApiTypeOrderBy._(this._$data);

  factory Input$ApiTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ApiTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ApiTypeOrderBy<Input$ApiTypeOrderBy> get copyWith =>
      CopyWith$Input$ApiTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApiTypeOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApiTypeOrderBy<TRes> {
  factory CopyWith$Input$ApiTypeOrderBy(
    Input$ApiTypeOrderBy instance,
    TRes Function(Input$ApiTypeOrderBy) then,
  ) = _CopyWithImpl$Input$ApiTypeOrderBy;

  factory CopyWith$Input$ApiTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApiTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ApiTypeOrderBy<TRes>
    implements CopyWith$Input$ApiTypeOrderBy<TRes> {
  _CopyWithImpl$Input$ApiTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApiTypeOrderBy _instance;

  final TRes Function(Input$ApiTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApiTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApiTypeOrderBy<TRes>
    implements CopyWith$Input$ApiTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApiTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ApiTypeUpdateInput {
  factory Input$ApiTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ApiTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApiTypeUpdateInput._(this._$data);

  factory Input$ApiTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ApiTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ApiTypeUpdateInput<Input$ApiTypeUpdateInput> get copyWith =>
      CopyWith$Input$ApiTypeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApiTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApiTypeUpdateInput<TRes> {
  factory CopyWith$Input$ApiTypeUpdateInput(
    Input$ApiTypeUpdateInput instance,
    TRes Function(Input$ApiTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$ApiTypeUpdateInput;

  factory CopyWith$Input$ApiTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApiTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ApiTypeUpdateInput<TRes>
    implements CopyWith$Input$ApiTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$ApiTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApiTypeUpdateInput _instance;

  final TRes Function(Input$ApiTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApiTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ApiTypeUpdateInput<TRes>
    implements CopyWith$Input$ApiTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApiTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ApplicationAgentFilter {
  factory Input$ApplicationAgentFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? agentId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationAgentFilter>? and,
    List<Input$ApplicationAgentFilter>? or,
    Input$ApplicationAgentFilter? not,
  }) =>
      Input$ApplicationAgentFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (agentId != null) r'agentId': agentId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationAgentFilter._(this._$data);

  factory Input$ApplicationAgentFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = l$agentId == null
          ? null
          : Input$UUIDFilter.fromJson((l$agentId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationAgentFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationAgentFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationAgentFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationAgentFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get agentId => (_$data['agentId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationAgentFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationAgentFilter>?);

  List<Input$ApplicationAgentFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationAgentFilter>?);

  Input$ApplicationAgentFilter? get not =>
      (_$data['not'] as Input$ApplicationAgentFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationAgentFilter<Input$ApplicationAgentFilter>
      get copyWith => CopyWith$Input$ApplicationAgentFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationAgentFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$agentId = agentId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationAgentFilter<TRes> {
  factory CopyWith$Input$ApplicationAgentFilter(
    Input$ApplicationAgentFilter instance,
    TRes Function(Input$ApplicationAgentFilter) then,
  ) = _CopyWithImpl$Input$ApplicationAgentFilter;

  factory CopyWith$Input$ApplicationAgentFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationAgentFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? agentId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationAgentFilter>? and,
    List<Input$ApplicationAgentFilter>? or,
    Input$ApplicationAgentFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$UUIDFilter<TRes> get agentId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationAgentFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationAgentFilter<
                      Input$ApplicationAgentFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationAgentFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationAgentFilter<
                      Input$ApplicationAgentFilter>>?)
          _fn);
  CopyWith$Input$ApplicationAgentFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationAgentFilter<TRes>
    implements CopyWith$Input$ApplicationAgentFilter<TRes> {
  _CopyWithImpl$Input$ApplicationAgentFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationAgentFilter _instance;

  final TRes Function(Input$ApplicationAgentFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? agentId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationAgentFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (agentId != _undefined) 'agentId': (agentId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationAgentFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationAgentFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationAgentFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get agentId {
    final local$agentId = _instance.agentId;
    return local$agentId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$agentId, (e) => call(agentId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationAgentFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationAgentFilter<
                          Input$ApplicationAgentFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationAgentFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationAgentFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationAgentFilter<
                          Input$ApplicationAgentFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$ApplicationAgentFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ApplicationAgentFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationAgentFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationAgentFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationAgentFilter<TRes>
    implements CopyWith$Input$ApplicationAgentFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationAgentFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? agentId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationAgentFilter>? and,
    List<Input$ApplicationAgentFilter>? or,
    Input$ApplicationAgentFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get agentId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationAgentFilter<TRes> get not =>
      CopyWith$Input$ApplicationAgentFilter.stub(_res);
}

class Input$ApplicationAgentInsertInput {
  factory Input$ApplicationAgentInsertInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  }) =>
      Input$ApplicationAgentInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (agentId != null) r'agentId': agentId,
      });

  Input$ApplicationAgentInsertInput._(this._$data);

  factory Input$ApplicationAgentInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = (l$agentId as String?);
    }
    return Input$ApplicationAgentInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get agentId => (_$data['agentId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationAgentInsertInput<Input$ApplicationAgentInsertInput>
      get copyWith => CopyWith$Input$ApplicationAgentInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationAgentInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$agentId = agentId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationAgentInsertInput<TRes> {
  factory CopyWith$Input$ApplicationAgentInsertInput(
    Input$ApplicationAgentInsertInput instance,
    TRes Function(Input$ApplicationAgentInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationAgentInsertInput;

  factory CopyWith$Input$ApplicationAgentInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationAgentInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  });
}

class _CopyWithImpl$Input$ApplicationAgentInsertInput<TRes>
    implements CopyWith$Input$ApplicationAgentInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationAgentInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationAgentInsertInput _instance;

  final TRes Function(Input$ApplicationAgentInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? agentId = _undefined,
  }) =>
      _then(Input$ApplicationAgentInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (agentId != _undefined) 'agentId': (agentId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationAgentInsertInput<TRes>
    implements CopyWith$Input$ApplicationAgentInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationAgentInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  }) =>
      _res;
}

class Input$ApplicationAgentOrderBy {
  factory Input$ApplicationAgentOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? agentId,
  }) =>
      Input$ApplicationAgentOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (agentId != null) r'agentId': agentId,
      });

  Input$ApplicationAgentOrderBy._(this._$data);

  factory Input$ApplicationAgentOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = l$agentId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$agentId as String));
    }
    return Input$ApplicationAgentOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get agentId =>
      (_$data['agentId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] =
          l$agentId == null ? null : toJson$Enum$OrderByDirection(l$agentId);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationAgentOrderBy<Input$ApplicationAgentOrderBy>
      get copyWith => CopyWith$Input$ApplicationAgentOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationAgentOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$agentId = agentId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationAgentOrderBy<TRes> {
  factory CopyWith$Input$ApplicationAgentOrderBy(
    Input$ApplicationAgentOrderBy instance,
    TRes Function(Input$ApplicationAgentOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationAgentOrderBy;

  factory CopyWith$Input$ApplicationAgentOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationAgentOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? agentId,
  });
}

class _CopyWithImpl$Input$ApplicationAgentOrderBy<TRes>
    implements CopyWith$Input$ApplicationAgentOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationAgentOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationAgentOrderBy _instance;

  final TRes Function(Input$ApplicationAgentOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? agentId = _undefined,
  }) =>
      _then(Input$ApplicationAgentOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (agentId != _undefined)
          'agentId': (agentId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationAgentOrderBy<TRes>
    implements CopyWith$Input$ApplicationAgentOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationAgentOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? agentId,
  }) =>
      _res;
}

class Input$ApplicationAgentUpdateInput {
  factory Input$ApplicationAgentUpdateInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  }) =>
      Input$ApplicationAgentUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (agentId != null) r'agentId': agentId,
      });

  Input$ApplicationAgentUpdateInput._(this._$data);

  factory Input$ApplicationAgentUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('agentId')) {
      final l$agentId = data['agentId'];
      result$data['agentId'] = (l$agentId as String?);
    }
    return Input$ApplicationAgentUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get agentId => (_$data['agentId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('agentId')) {
      final l$agentId = agentId;
      result$data['agentId'] = l$agentId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationAgentUpdateInput<Input$ApplicationAgentUpdateInput>
      get copyWith => CopyWith$Input$ApplicationAgentUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationAgentUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$agentId = agentId;
    final lOther$agentId = other.agentId;
    if (_$data.containsKey('agentId') != other._$data.containsKey('agentId')) {
      return false;
    }
    if (l$agentId != lOther$agentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$agentId = agentId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('agentId') ? l$agentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationAgentUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationAgentUpdateInput(
    Input$ApplicationAgentUpdateInput instance,
    TRes Function(Input$ApplicationAgentUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationAgentUpdateInput;

  factory CopyWith$Input$ApplicationAgentUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationAgentUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  });
}

class _CopyWithImpl$Input$ApplicationAgentUpdateInput<TRes>
    implements CopyWith$Input$ApplicationAgentUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationAgentUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationAgentUpdateInput _instance;

  final TRes Function(Input$ApplicationAgentUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? agentId = _undefined,
  }) =>
      _then(Input$ApplicationAgentUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (agentId != _undefined) 'agentId': (agentId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationAgentUpdateInput<TRes>
    implements CopyWith$Input$ApplicationAgentUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationAgentUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? agentId,
  }) =>
      _res;
}

class Input$ApplicationFilter {
  factory Input$ApplicationFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? ownerId,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? applicationTypeId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$ApplicationFilter>? and,
    List<Input$ApplicationFilter>? or,
    Input$ApplicationFilter? not,
  }) =>
      Input$ApplicationFilter._({
        if (id != null) r'id': id,
        if (ownerId != null) r'ownerId': ownerId,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (applicationTypeId != null) r'applicationTypeId': applicationTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationFilter._(this._$data);

  factory Input$ApplicationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = data['applicationTypeId'];
      result$data['applicationTypeId'] = l$applicationTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ApplicationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$UUIDFilter? get applicationTypeId =>
      (_$data['applicationTypeId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationFilter>?);

  List<Input$ApplicationFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationFilter>?);

  Input$ApplicationFilter? get not =>
      (_$data['not'] as Input$ApplicationFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = applicationTypeId;
      result$data['applicationTypeId'] = l$applicationTypeId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationFilter<Input$ApplicationFilter> get copyWith =>
      CopyWith$Input$ApplicationFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$applicationTypeId = applicationTypeId;
    final lOther$applicationTypeId = other.applicationTypeId;
    if (_$data.containsKey('applicationTypeId') !=
        other._$data.containsKey('applicationTypeId')) {
      return false;
    }
    if (l$applicationTypeId != lOther$applicationTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$ownerId = ownerId;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$applicationTypeId = applicationTypeId;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('applicationTypeId') ? l$applicationTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationFilter<TRes> {
  factory CopyWith$Input$ApplicationFilter(
    Input$ApplicationFilter instance,
    TRes Function(Input$ApplicationFilter) then,
  ) = _CopyWithImpl$Input$ApplicationFilter;

  factory CopyWith$Input$ApplicationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? ownerId,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? applicationTypeId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$ApplicationFilter>? and,
    List<Input$ApplicationFilter>? or,
    Input$ApplicationFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$UUIDFilter<TRes> get applicationTypeId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationFilter<Input$ApplicationFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationFilter<Input$ApplicationFilter>>?)
          _fn);
  CopyWith$Input$ApplicationFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationFilter<TRes>
    implements CopyWith$Input$ApplicationFilter<TRes> {
  _CopyWithImpl$Input$ApplicationFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationFilter _instance;

  final TRes Function(Input$ApplicationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? applicationTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (applicationTypeId != _undefined)
          'applicationTypeId': (applicationTypeId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ApplicationFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationTypeId {
    final local$applicationTypeId = _instance.applicationTypeId;
    return local$applicationTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationTypeId, (e) => call(applicationTypeId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationFilter<
                          Input$ApplicationFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ApplicationFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ApplicationFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationFilter<
                          Input$ApplicationFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ApplicationFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ApplicationFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationFilter<TRes>
    implements CopyWith$Input$ApplicationFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? ownerId,
    Input$StringFilter? name,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? applicationTypeId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$ApplicationFilter>? and,
    List<Input$ApplicationFilter>? or,
    Input$ApplicationFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationFilter<TRes> get not =>
      CopyWith$Input$ApplicationFilter.stub(_res);
}

class Input$ApplicationInsertInput {
  factory Input$ApplicationInsertInput({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  }) =>
      Input$ApplicationInsertInput._({
        if (id != null) r'id': id,
        if (ownerId != null) r'ownerId': ownerId,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (applicationTypeId != null) r'applicationTypeId': applicationTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$ApplicationInsertInput._(this._$data);

  factory Input$ApplicationInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = data['applicationTypeId'];
      result$data['applicationTypeId'] = (l$applicationTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    return Input$ApplicationInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  String? get applicationTypeId => (_$data['applicationTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = applicationTypeId;
      result$data['applicationTypeId'] = l$applicationTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationInsertInput<Input$ApplicationInsertInput>
      get copyWith => CopyWith$Input$ApplicationInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$applicationTypeId = applicationTypeId;
    final lOther$applicationTypeId = other.applicationTypeId;
    if (_$data.containsKey('applicationTypeId') !=
        other._$data.containsKey('applicationTypeId')) {
      return false;
    }
    if (l$applicationTypeId != lOther$applicationTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$ownerId = ownerId;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$applicationTypeId = applicationTypeId;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('applicationTypeId') ? l$applicationTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationInsertInput<TRes> {
  factory CopyWith$Input$ApplicationInsertInput(
    Input$ApplicationInsertInput instance,
    TRes Function(Input$ApplicationInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationInsertInput;

  factory CopyWith$Input$ApplicationInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationInsertInput;

  TRes call({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  });
}

class _CopyWithImpl$Input$ApplicationInsertInput<TRes>
    implements CopyWith$Input$ApplicationInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationInsertInput _instance;

  final TRes Function(Input$ApplicationInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? applicationTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$ApplicationInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (applicationTypeId != _undefined)
          'applicationTypeId': (applicationTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationInsertInput<TRes>
    implements CopyWith$Input$ApplicationInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  }) =>
      _res;
}

class Input$ApplicationOrderBy {
  factory Input$ApplicationOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? applicationTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  }) =>
      Input$ApplicationOrderBy._({
        if (id != null) r'id': id,
        if (ownerId != null) r'ownerId': ownerId,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (applicationTypeId != null) r'applicationTypeId': applicationTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$ApplicationOrderBy._(this._$data);

  factory Input$ApplicationOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = data['applicationTypeId'];
      result$data['applicationTypeId'] = l$applicationTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationTypeId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    return Input$ApplicationOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationTypeId =>
      (_$data['applicationTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = applicationTypeId;
      result$data['applicationTypeId'] = l$applicationTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationTypeId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationOrderBy<Input$ApplicationOrderBy> get copyWith =>
      CopyWith$Input$ApplicationOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$applicationTypeId = applicationTypeId;
    final lOther$applicationTypeId = other.applicationTypeId;
    if (_$data.containsKey('applicationTypeId') !=
        other._$data.containsKey('applicationTypeId')) {
      return false;
    }
    if (l$applicationTypeId != lOther$applicationTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$ownerId = ownerId;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$applicationTypeId = applicationTypeId;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('applicationTypeId') ? l$applicationTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationOrderBy<TRes> {
  factory CopyWith$Input$ApplicationOrderBy(
    Input$ApplicationOrderBy instance,
    TRes Function(Input$ApplicationOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationOrderBy;

  factory CopyWith$Input$ApplicationOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? applicationTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  });
}

class _CopyWithImpl$Input$ApplicationOrderBy<TRes>
    implements CopyWith$Input$ApplicationOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationOrderBy _instance;

  final TRes Function(Input$ApplicationOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? applicationTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$ApplicationOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (applicationTypeId != _undefined)
          'applicationTypeId': (applicationTypeId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationOrderBy<TRes>
    implements CopyWith$Input$ApplicationOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? applicationTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  }) =>
      _res;
}

class Input$ApplicationTableFilter {
  factory Input$ApplicationTableFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? tableName,
    Input$StringFilter? schemaName,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTableFilter>? and,
    List<Input$ApplicationTableFilter>? or,
    Input$ApplicationTableFilter? not,
  }) =>
      Input$ApplicationTableFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (tableName != null) r'tableName': tableName,
        if (schemaName != null) r'schemaName': schemaName,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationTableFilter._(this._$data);

  factory Input$ApplicationTableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('tableName')) {
      final l$tableName = data['tableName'];
      result$data['tableName'] = l$tableName == null
          ? null
          : Input$StringFilter.fromJson((l$tableName as Map<String, dynamic>));
    }
    if (data.containsKey('schemaName')) {
      final l$schemaName = data['schemaName'];
      result$data['schemaName'] = l$schemaName == null
          ? null
          : Input$StringFilter.fromJson((l$schemaName as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationTableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationTableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationTableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationTableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$StringFilter? get tableName =>
      (_$data['tableName'] as Input$StringFilter?);

  Input$StringFilter? get schemaName =>
      (_$data['schemaName'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationTableFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationTableFilter>?);

  List<Input$ApplicationTableFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationTableFilter>?);

  Input$ApplicationTableFilter? get not =>
      (_$data['not'] as Input$ApplicationTableFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('tableName')) {
      final l$tableName = tableName;
      result$data['tableName'] = l$tableName?.toJson();
    }
    if (_$data.containsKey('schemaName')) {
      final l$schemaName = schemaName;
      result$data['schemaName'] = l$schemaName?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTableFilter<Input$ApplicationTableFilter>
      get copyWith => CopyWith$Input$ApplicationTableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$tableName = tableName;
    final lOther$tableName = other.tableName;
    if (_$data.containsKey('tableName') !=
        other._$data.containsKey('tableName')) {
      return false;
    }
    if (l$tableName != lOther$tableName) {
      return false;
    }
    final l$schemaName = schemaName;
    final lOther$schemaName = other.schemaName;
    if (_$data.containsKey('schemaName') !=
        other._$data.containsKey('schemaName')) {
      return false;
    }
    if (l$schemaName != lOther$schemaName) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$tableName = tableName;
    final l$schemaName = schemaName;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('tableName') ? l$tableName : const {},
      _$data.containsKey('schemaName') ? l$schemaName : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTableFilter<TRes> {
  factory CopyWith$Input$ApplicationTableFilter(
    Input$ApplicationTableFilter instance,
    TRes Function(Input$ApplicationTableFilter) then,
  ) = _CopyWithImpl$Input$ApplicationTableFilter;

  factory CopyWith$Input$ApplicationTableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTableFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? tableName,
    Input$StringFilter? schemaName,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTableFilter>? and,
    List<Input$ApplicationTableFilter>? or,
    Input$ApplicationTableFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$StringFilter<TRes> get tableName;
  CopyWith$Input$StringFilter<TRes> get schemaName;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationTableFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationTableFilter<
                      Input$ApplicationTableFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationTableFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationTableFilter<
                      Input$ApplicationTableFilter>>?)
          _fn);
  CopyWith$Input$ApplicationTableFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationTableFilter<TRes>
    implements CopyWith$Input$ApplicationTableFilter<TRes> {
  _CopyWithImpl$Input$ApplicationTableFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationTableFilter _instance;

  final TRes Function(Input$ApplicationTableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? tableName = _undefined,
    Object? schemaName = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationTableFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (tableName != _undefined)
          'tableName': (tableName as Input$StringFilter?),
        if (schemaName != _undefined)
          'schemaName': (schemaName as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationTableFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationTableFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationTableFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$StringFilter<TRes> get tableName {
    final local$tableName = _instance.tableName;
    return local$tableName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$tableName, (e) => call(tableName: e));
  }

  CopyWith$Input$StringFilter<TRes> get schemaName {
    final local$schemaName = _instance.schemaName;
    return local$schemaName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$schemaName, (e) => call(schemaName: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationTableFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationTableFilter<
                          Input$ApplicationTableFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationTableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationTableFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationTableFilter<
                          Input$ApplicationTableFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$ApplicationTableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ApplicationTableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationTableFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationTableFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationTableFilter<TRes>
    implements CopyWith$Input$ApplicationTableFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationTableFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? tableName,
    Input$StringFilter? schemaName,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTableFilter>? and,
    List<Input$ApplicationTableFilter>? or,
    Input$ApplicationTableFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get tableName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get schemaName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationTableFilter<TRes> get not =>
      CopyWith$Input$ApplicationTableFilter.stub(_res);
}

class Input$ApplicationTableInsertInput {
  factory Input$ApplicationTableInsertInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  }) =>
      Input$ApplicationTableInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (tableName != null) r'tableName': tableName,
        if (schemaName != null) r'schemaName': schemaName,
      });

  Input$ApplicationTableInsertInput._(this._$data);

  factory Input$ApplicationTableInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('tableName')) {
      final l$tableName = data['tableName'];
      result$data['tableName'] = (l$tableName as String?);
    }
    if (data.containsKey('schemaName')) {
      final l$schemaName = data['schemaName'];
      result$data['schemaName'] = (l$schemaName as String?);
    }
    return Input$ApplicationTableInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get tableName => (_$data['tableName'] as String?);

  String? get schemaName => (_$data['schemaName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('tableName')) {
      final l$tableName = tableName;
      result$data['tableName'] = l$tableName;
    }
    if (_$data.containsKey('schemaName')) {
      final l$schemaName = schemaName;
      result$data['schemaName'] = l$schemaName;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTableInsertInput<Input$ApplicationTableInsertInput>
      get copyWith => CopyWith$Input$ApplicationTableInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTableInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$tableName = tableName;
    final lOther$tableName = other.tableName;
    if (_$data.containsKey('tableName') !=
        other._$data.containsKey('tableName')) {
      return false;
    }
    if (l$tableName != lOther$tableName) {
      return false;
    }
    final l$schemaName = schemaName;
    final lOther$schemaName = other.schemaName;
    if (_$data.containsKey('schemaName') !=
        other._$data.containsKey('schemaName')) {
      return false;
    }
    if (l$schemaName != lOther$schemaName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$tableName = tableName;
    final l$schemaName = schemaName;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('tableName') ? l$tableName : const {},
      _$data.containsKey('schemaName') ? l$schemaName : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTableInsertInput<TRes> {
  factory CopyWith$Input$ApplicationTableInsertInput(
    Input$ApplicationTableInsertInput instance,
    TRes Function(Input$ApplicationTableInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationTableInsertInput;

  factory CopyWith$Input$ApplicationTableInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTableInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  });
}

class _CopyWithImpl$Input$ApplicationTableInsertInput<TRes>
    implements CopyWith$Input$ApplicationTableInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationTableInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationTableInsertInput _instance;

  final TRes Function(Input$ApplicationTableInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? tableName = _undefined,
    Object? schemaName = _undefined,
  }) =>
      _then(Input$ApplicationTableInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (tableName != _undefined) 'tableName': (tableName as String?),
        if (schemaName != _undefined) 'schemaName': (schemaName as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTableInsertInput<TRes>
    implements CopyWith$Input$ApplicationTableInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationTableInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  }) =>
      _res;
}

class Input$ApplicationTableOrderBy {
  factory Input$ApplicationTableOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? tableName,
    Enum$OrderByDirection? schemaName,
  }) =>
      Input$ApplicationTableOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (tableName != null) r'tableName': tableName,
        if (schemaName != null) r'schemaName': schemaName,
      });

  Input$ApplicationTableOrderBy._(this._$data);

  factory Input$ApplicationTableOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('tableName')) {
      final l$tableName = data['tableName'];
      result$data['tableName'] = l$tableName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$tableName as String));
    }
    if (data.containsKey('schemaName')) {
      final l$schemaName = data['schemaName'];
      result$data['schemaName'] = l$schemaName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$schemaName as String));
    }
    return Input$ApplicationTableOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get tableName =>
      (_$data['tableName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get schemaName =>
      (_$data['schemaName'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('tableName')) {
      final l$tableName = tableName;
      result$data['tableName'] = l$tableName == null
          ? null
          : toJson$Enum$OrderByDirection(l$tableName);
    }
    if (_$data.containsKey('schemaName')) {
      final l$schemaName = schemaName;
      result$data['schemaName'] = l$schemaName == null
          ? null
          : toJson$Enum$OrderByDirection(l$schemaName);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTableOrderBy<Input$ApplicationTableOrderBy>
      get copyWith => CopyWith$Input$ApplicationTableOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTableOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$tableName = tableName;
    final lOther$tableName = other.tableName;
    if (_$data.containsKey('tableName') !=
        other._$data.containsKey('tableName')) {
      return false;
    }
    if (l$tableName != lOther$tableName) {
      return false;
    }
    final l$schemaName = schemaName;
    final lOther$schemaName = other.schemaName;
    if (_$data.containsKey('schemaName') !=
        other._$data.containsKey('schemaName')) {
      return false;
    }
    if (l$schemaName != lOther$schemaName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$tableName = tableName;
    final l$schemaName = schemaName;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('tableName') ? l$tableName : const {},
      _$data.containsKey('schemaName') ? l$schemaName : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTableOrderBy<TRes> {
  factory CopyWith$Input$ApplicationTableOrderBy(
    Input$ApplicationTableOrderBy instance,
    TRes Function(Input$ApplicationTableOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationTableOrderBy;

  factory CopyWith$Input$ApplicationTableOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTableOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? tableName,
    Enum$OrderByDirection? schemaName,
  });
}

class _CopyWithImpl$Input$ApplicationTableOrderBy<TRes>
    implements CopyWith$Input$ApplicationTableOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationTableOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationTableOrderBy _instance;

  final TRes Function(Input$ApplicationTableOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? tableName = _undefined,
    Object? schemaName = _undefined,
  }) =>
      _then(Input$ApplicationTableOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (tableName != _undefined)
          'tableName': (tableName as Enum$OrderByDirection?),
        if (schemaName != _undefined)
          'schemaName': (schemaName as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTableOrderBy<TRes>
    implements CopyWith$Input$ApplicationTableOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationTableOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? tableName,
    Enum$OrderByDirection? schemaName,
  }) =>
      _res;
}

class Input$ApplicationTableUpdateInput {
  factory Input$ApplicationTableUpdateInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  }) =>
      Input$ApplicationTableUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (tableName != null) r'tableName': tableName,
        if (schemaName != null) r'schemaName': schemaName,
      });

  Input$ApplicationTableUpdateInput._(this._$data);

  factory Input$ApplicationTableUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('tableName')) {
      final l$tableName = data['tableName'];
      result$data['tableName'] = (l$tableName as String?);
    }
    if (data.containsKey('schemaName')) {
      final l$schemaName = data['schemaName'];
      result$data['schemaName'] = (l$schemaName as String?);
    }
    return Input$ApplicationTableUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get tableName => (_$data['tableName'] as String?);

  String? get schemaName => (_$data['schemaName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('tableName')) {
      final l$tableName = tableName;
      result$data['tableName'] = l$tableName;
    }
    if (_$data.containsKey('schemaName')) {
      final l$schemaName = schemaName;
      result$data['schemaName'] = l$schemaName;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTableUpdateInput<Input$ApplicationTableUpdateInput>
      get copyWith => CopyWith$Input$ApplicationTableUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTableUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$tableName = tableName;
    final lOther$tableName = other.tableName;
    if (_$data.containsKey('tableName') !=
        other._$data.containsKey('tableName')) {
      return false;
    }
    if (l$tableName != lOther$tableName) {
      return false;
    }
    final l$schemaName = schemaName;
    final lOther$schemaName = other.schemaName;
    if (_$data.containsKey('schemaName') !=
        other._$data.containsKey('schemaName')) {
      return false;
    }
    if (l$schemaName != lOther$schemaName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$tableName = tableName;
    final l$schemaName = schemaName;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('tableName') ? l$tableName : const {},
      _$data.containsKey('schemaName') ? l$schemaName : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTableUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationTableUpdateInput(
    Input$ApplicationTableUpdateInput instance,
    TRes Function(Input$ApplicationTableUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationTableUpdateInput;

  factory CopyWith$Input$ApplicationTableUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTableUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  });
}

class _CopyWithImpl$Input$ApplicationTableUpdateInput<TRes>
    implements CopyWith$Input$ApplicationTableUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationTableUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationTableUpdateInput _instance;

  final TRes Function(Input$ApplicationTableUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? tableName = _undefined,
    Object? schemaName = _undefined,
  }) =>
      _then(Input$ApplicationTableUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (tableName != _undefined) 'tableName': (tableName as String?),
        if (schemaName != _undefined) 'schemaName': (schemaName as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTableUpdateInput<TRes>
    implements CopyWith$Input$ApplicationTableUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationTableUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? tableName,
    String? schemaName,
  }) =>
      _res;
}

class Input$ApplicationToolFilter {
  factory Input$ApplicationToolFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationToolFilter>? and,
    List<Input$ApplicationToolFilter>? or,
    Input$ApplicationToolFilter? not,
  }) =>
      Input$ApplicationToolFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (toolId != null) r'toolId': toolId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationToolFilter._(this._$data);

  factory Input$ApplicationToolFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = l$toolId == null
          ? null
          : Input$UUIDFilter.fromJson((l$toolId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationToolFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationToolFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get toolId => (_$data['toolId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationToolFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationToolFilter>?);

  List<Input$ApplicationToolFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationToolFilter>?);

  Input$ApplicationToolFilter? get not =>
      (_$data['not'] as Input$ApplicationToolFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationToolFilter<Input$ApplicationToolFilter>
      get copyWith => CopyWith$Input$ApplicationToolFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationToolFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$toolId = toolId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationToolFilter<TRes> {
  factory CopyWith$Input$ApplicationToolFilter(
    Input$ApplicationToolFilter instance,
    TRes Function(Input$ApplicationToolFilter) then,
  ) = _CopyWithImpl$Input$ApplicationToolFilter;

  factory CopyWith$Input$ApplicationToolFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationToolFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationToolFilter>? and,
    List<Input$ApplicationToolFilter>? or,
    Input$ApplicationToolFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$UUIDFilter<TRes> get toolId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationToolFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationToolFilter<
                      Input$ApplicationToolFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationToolFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationToolFilter<
                      Input$ApplicationToolFilter>>?)
          _fn);
  CopyWith$Input$ApplicationToolFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationToolFilter<TRes>
    implements CopyWith$Input$ApplicationToolFilter<TRes> {
  _CopyWithImpl$Input$ApplicationToolFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationToolFilter _instance;

  final TRes Function(Input$ApplicationToolFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? toolId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationToolFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (toolId != _undefined) 'toolId': (toolId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationToolFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationToolFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationToolFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get toolId {
    final local$toolId = _instance.toolId;
    return local$toolId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$toolId, (e) => call(toolId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationToolFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationToolFilter<
                          Input$ApplicationToolFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationToolFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationToolFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationToolFilter<
                          Input$ApplicationToolFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ApplicationToolFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ApplicationToolFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationToolFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationToolFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationToolFilter<TRes>
    implements CopyWith$Input$ApplicationToolFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationToolFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? toolId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationToolFilter>? and,
    List<Input$ApplicationToolFilter>? or,
    Input$ApplicationToolFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get toolId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationToolFilter<TRes> get not =>
      CopyWith$Input$ApplicationToolFilter.stub(_res);
}

class Input$ApplicationToolInsertInput {
  factory Input$ApplicationToolInsertInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  }) =>
      Input$ApplicationToolInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$ApplicationToolInsertInput._(this._$data);

  factory Input$ApplicationToolInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = (l$toolId as String?);
    }
    return Input$ApplicationToolInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get toolId => (_$data['toolId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationToolInsertInput<Input$ApplicationToolInsertInput>
      get copyWith => CopyWith$Input$ApplicationToolInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationToolInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationToolInsertInput<TRes> {
  factory CopyWith$Input$ApplicationToolInsertInput(
    Input$ApplicationToolInsertInput instance,
    TRes Function(Input$ApplicationToolInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationToolInsertInput;

  factory CopyWith$Input$ApplicationToolInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationToolInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  });
}

class _CopyWithImpl$Input$ApplicationToolInsertInput<TRes>
    implements CopyWith$Input$ApplicationToolInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationToolInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationToolInsertInput _instance;

  final TRes Function(Input$ApplicationToolInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$ApplicationToolInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (toolId != _undefined) 'toolId': (toolId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationToolInsertInput<TRes>
    implements CopyWith$Input$ApplicationToolInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationToolInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  }) =>
      _res;
}

class Input$ApplicationToolOrderBy {
  factory Input$ApplicationToolOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? toolId,
  }) =>
      Input$ApplicationToolOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$ApplicationToolOrderBy._(this._$data);

  factory Input$ApplicationToolOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = l$toolId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$toolId as String));
    }
    return Input$ApplicationToolOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get toolId =>
      (_$data['toolId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] =
          l$toolId == null ? null : toJson$Enum$OrderByDirection(l$toolId);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationToolOrderBy<Input$ApplicationToolOrderBy>
      get copyWith => CopyWith$Input$ApplicationToolOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationToolOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationToolOrderBy<TRes> {
  factory CopyWith$Input$ApplicationToolOrderBy(
    Input$ApplicationToolOrderBy instance,
    TRes Function(Input$ApplicationToolOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationToolOrderBy;

  factory CopyWith$Input$ApplicationToolOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationToolOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? toolId,
  });
}

class _CopyWithImpl$Input$ApplicationToolOrderBy<TRes>
    implements CopyWith$Input$ApplicationToolOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationToolOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationToolOrderBy _instance;

  final TRes Function(Input$ApplicationToolOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$ApplicationToolOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (toolId != _undefined) 'toolId': (toolId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationToolOrderBy<TRes>
    implements CopyWith$Input$ApplicationToolOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationToolOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? toolId,
  }) =>
      _res;
}

class Input$ApplicationToolUpdateInput {
  factory Input$ApplicationToolUpdateInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  }) =>
      Input$ApplicationToolUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (toolId != null) r'toolId': toolId,
      });

  Input$ApplicationToolUpdateInput._(this._$data);

  factory Input$ApplicationToolUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('toolId')) {
      final l$toolId = data['toolId'];
      result$data['toolId'] = (l$toolId as String?);
    }
    return Input$ApplicationToolUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get toolId => (_$data['toolId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('toolId')) {
      final l$toolId = toolId;
      result$data['toolId'] = l$toolId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationToolUpdateInput<Input$ApplicationToolUpdateInput>
      get copyWith => CopyWith$Input$ApplicationToolUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationToolUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$toolId = toolId;
    final lOther$toolId = other.toolId;
    if (_$data.containsKey('toolId') != other._$data.containsKey('toolId')) {
      return false;
    }
    if (l$toolId != lOther$toolId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$toolId = toolId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('toolId') ? l$toolId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationToolUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationToolUpdateInput(
    Input$ApplicationToolUpdateInput instance,
    TRes Function(Input$ApplicationToolUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationToolUpdateInput;

  factory CopyWith$Input$ApplicationToolUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationToolUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  });
}

class _CopyWithImpl$Input$ApplicationToolUpdateInput<TRes>
    implements CopyWith$Input$ApplicationToolUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationToolUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationToolUpdateInput _instance;

  final TRes Function(Input$ApplicationToolUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? toolId = _undefined,
  }) =>
      _then(Input$ApplicationToolUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (toolId != _undefined) 'toolId': (toolId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationToolUpdateInput<TRes>
    implements CopyWith$Input$ApplicationToolUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationToolUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? toolId,
  }) =>
      _res;
}

class Input$ApplicationTypeFilter {
  factory Input$ApplicationTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? key,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTypeFilter>? and,
    List<Input$ApplicationTypeFilter>? or,
    Input$ApplicationTypeFilter? not,
  }) =>
      Input$ApplicationTypeFilter._({
        if (id != null) r'id': id,
        if (key != null) r'key': key,
        if (name != null) r'name': name,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationTypeFilter._(this._$data);

  factory Input$ApplicationTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationTypeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationTypeFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationTypeFilter>?);

  List<Input$ApplicationTypeFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationTypeFilter>?);

  Input$ApplicationTypeFilter? get not =>
      (_$data['not'] as Input$ApplicationTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTypeFilter<Input$ApplicationTypeFilter>
      get copyWith => CopyWith$Input$ApplicationTypeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$key = key;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTypeFilter<TRes> {
  factory CopyWith$Input$ApplicationTypeFilter(
    Input$ApplicationTypeFilter instance,
    TRes Function(Input$ApplicationTypeFilter) then,
  ) = _CopyWithImpl$Input$ApplicationTypeFilter;

  factory CopyWith$Input$ApplicationTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? key,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTypeFilter>? and,
    List<Input$ApplicationTypeFilter>? or,
    Input$ApplicationTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationTypeFilter<
                      Input$ApplicationTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationTypeFilter<
                      Input$ApplicationTypeFilter>>?)
          _fn);
  CopyWith$Input$ApplicationTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationTypeFilter<TRes>
    implements CopyWith$Input$ApplicationTypeFilter<TRes> {
  _CopyWithImpl$Input$ApplicationTypeFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationTypeFilter _instance;

  final TRes Function(Input$ApplicationTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? key = _undefined,
    Object? name = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationTypeFilter<
                          Input$ApplicationTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationTypeFilter<
                          Input$ApplicationTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ApplicationTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ApplicationTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationTypeFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationTypeFilter<TRes>
    implements CopyWith$Input$ApplicationTypeFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? key,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ApplicationTypeFilter>? and,
    List<Input$ApplicationTypeFilter>? or,
    Input$ApplicationTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationTypeFilter<TRes> get not =>
      CopyWith$Input$ApplicationTypeFilter.stub(_res);
}

class Input$ApplicationTypeInsertInput {
  factory Input$ApplicationTypeInsertInput({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ApplicationTypeInsertInput._({
        if (id != null) r'id': id,
        if (key != null) r'key': key,
        if (name != null) r'name': name,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApplicationTypeInsertInput._(this._$data);

  factory Input$ApplicationTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ApplicationTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTypeInsertInput<Input$ApplicationTypeInsertInput>
      get copyWith => CopyWith$Input$ApplicationTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$key = key;
    final l$name = name;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTypeInsertInput<TRes> {
  factory CopyWith$Input$ApplicationTypeInsertInput(
    Input$ApplicationTypeInsertInput instance,
    TRes Function(Input$ApplicationTypeInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationTypeInsertInput;

  factory CopyWith$Input$ApplicationTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTypeInsertInput;

  TRes call({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ApplicationTypeInsertInput<TRes>
    implements CopyWith$Input$ApplicationTypeInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationTypeInsertInput _instance;

  final TRes Function(Input$ApplicationTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? key = _undefined,
    Object? name = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApplicationTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (key != _undefined) 'key': (key as String?),
        if (name != _undefined) 'name': (name as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTypeInsertInput<TRes>
    implements CopyWith$Input$ApplicationTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ApplicationTypeOrderBy {
  factory Input$ApplicationTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ApplicationTypeOrderBy._({
        if (id != null) r'id': id,
        if (key != null) r'key': key,
        if (name != null) r'name': name,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApplicationTypeOrderBy._(this._$data);

  factory Input$ApplicationTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ApplicationTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTypeOrderBy<Input$ApplicationTypeOrderBy>
      get copyWith => CopyWith$Input$ApplicationTypeOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$key = key;
    final l$name = name;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTypeOrderBy<TRes> {
  factory CopyWith$Input$ApplicationTypeOrderBy(
    Input$ApplicationTypeOrderBy instance,
    TRes Function(Input$ApplicationTypeOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationTypeOrderBy;

  factory CopyWith$Input$ApplicationTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ApplicationTypeOrderBy<TRes>
    implements CopyWith$Input$ApplicationTypeOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationTypeOrderBy _instance;

  final TRes Function(Input$ApplicationTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? key = _undefined,
    Object? name = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApplicationTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTypeOrderBy<TRes>
    implements CopyWith$Input$ApplicationTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ApplicationTypeUpdateInput {
  factory Input$ApplicationTypeUpdateInput({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ApplicationTypeUpdateInput._({
        if (id != null) r'id': id,
        if (key != null) r'key': key,
        if (name != null) r'name': name,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ApplicationTypeUpdateInput._(this._$data);

  factory Input$ApplicationTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ApplicationTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationTypeUpdateInput<Input$ApplicationTypeUpdateInput>
      get copyWith => CopyWith$Input$ApplicationTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$key = key;
    final l$name = name;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationTypeUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationTypeUpdateInput(
    Input$ApplicationTypeUpdateInput instance,
    TRes Function(Input$ApplicationTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationTypeUpdateInput;

  factory CopyWith$Input$ApplicationTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationTypeUpdateInput;

  TRes call({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ApplicationTypeUpdateInput<TRes>
    implements CopyWith$Input$ApplicationTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationTypeUpdateInput _instance;

  final TRes Function(Input$ApplicationTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? key = _undefined,
    Object? name = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ApplicationTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (key != _undefined) 'key': (key as String?),
        if (name != _undefined) 'name': (name as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationTypeUpdateInput<TRes>
    implements CopyWith$Input$ApplicationTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? key,
    String? name,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ApplicationUpdateInput {
  factory Input$ApplicationUpdateInput({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  }) =>
      Input$ApplicationUpdateInput._({
        if (id != null) r'id': id,
        if (ownerId != null) r'ownerId': ownerId,
        if (name != null) r'name': name,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (applicationTypeId != null) r'applicationTypeId': applicationTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$ApplicationUpdateInput._(this._$data);

  factory Input$ApplicationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = data['applicationTypeId'];
      result$data['applicationTypeId'] = (l$applicationTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    return Input$ApplicationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  String? get applicationTypeId => (_$data['applicationTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('applicationTypeId')) {
      final l$applicationTypeId = applicationTypeId;
      result$data['applicationTypeId'] = l$applicationTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUpdateInput<Input$ApplicationUpdateInput>
      get copyWith => CopyWith$Input$ApplicationUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$applicationTypeId = applicationTypeId;
    final lOther$applicationTypeId = other.applicationTypeId;
    if (_$data.containsKey('applicationTypeId') !=
        other._$data.containsKey('applicationTypeId')) {
      return false;
    }
    if (l$applicationTypeId != lOther$applicationTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$ownerId = ownerId;
    final l$name = name;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$applicationTypeId = applicationTypeId;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('applicationTypeId') ? l$applicationTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationUpdateInput(
    Input$ApplicationUpdateInput instance,
    TRes Function(Input$ApplicationUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationUpdateInput;

  factory CopyWith$Input$ApplicationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUpdateInput;

  TRes call({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  });
}

class _CopyWithImpl$Input$ApplicationUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUpdateInput _instance;

  final TRes Function(Input$ApplicationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? applicationTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$ApplicationUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (applicationTypeId != _undefined)
          'applicationTypeId': (applicationTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? ownerId,
    String? name,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? applicationTypeId,
    DateTime? createdAt,
    String? iconUrl,
    String? coverUrl,
  }) =>
      _res;
}

class Input$ApplicationUserFilter {
  factory Input$ApplicationUserFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserFilter>? and,
    List<Input$ApplicationUserFilter>? or,
    Input$ApplicationUserFilter? not,
  }) =>
      Input$ApplicationUserFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationUserFilter._(this._$data);

  factory Input$ApplicationUserFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationUserFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ApplicationUserFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationUserFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationUserFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationUserFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationUserFilter>?);

  List<Input$ApplicationUserFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationUserFilter>?);

  Input$ApplicationUserFilter? get not =>
      (_$data['not'] as Input$ApplicationUserFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserFilter<Input$ApplicationUserFilter>
      get copyWith => CopyWith$Input$ApplicationUserFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserFilter<TRes> {
  factory CopyWith$Input$ApplicationUserFilter(
    Input$ApplicationUserFilter instance,
    TRes Function(Input$ApplicationUserFilter) then,
  ) = _CopyWithImpl$Input$ApplicationUserFilter;

  factory CopyWith$Input$ApplicationUserFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserFilter>? and,
    List<Input$ApplicationUserFilter>? or,
    Input$ApplicationUserFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationUserFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserFilter<
                      Input$ApplicationUserFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationUserFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserFilter<
                      Input$ApplicationUserFilter>>?)
          _fn);
  CopyWith$Input$ApplicationUserFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationUserFilter<TRes>
    implements CopyWith$Input$ApplicationUserFilter<TRes> {
  _CopyWithImpl$Input$ApplicationUserFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserFilter _instance;

  final TRes Function(Input$ApplicationUserFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationUserFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationUserFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationUserFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationUserFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationUserFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserFilter<
                          Input$ApplicationUserFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationUserFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationUserFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserFilter<
                          Input$ApplicationUserFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ApplicationUserFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ApplicationUserFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationUserFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationUserFilter<TRes>
    implements CopyWith$Input$ApplicationUserFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserFilter>? and,
    List<Input$ApplicationUserFilter>? or,
    Input$ApplicationUserFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationUserFilter<TRes> get not =>
      CopyWith$Input$ApplicationUserFilter.stub(_res);
}

class Input$ApplicationUserInsertInput {
  factory Input$ApplicationUserInsertInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  }) =>
      Input$ApplicationUserInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
      });

  Input$ApplicationUserInsertInput._(this._$data);

  factory Input$ApplicationUserInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return Input$ApplicationUserInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get userId => (_$data['userId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserInsertInput<Input$ApplicationUserInsertInput>
      get copyWith => CopyWith$Input$ApplicationUserInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserInsertInput<TRes> {
  factory CopyWith$Input$ApplicationUserInsertInput(
    Input$ApplicationUserInsertInput instance,
    TRes Function(Input$ApplicationUserInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserInsertInput;

  factory CopyWith$Input$ApplicationUserInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$ApplicationUserInsertInput<TRes>
    implements CopyWith$Input$ApplicationUserInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserInsertInput _instance;

  final TRes Function(Input$ApplicationUserInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$ApplicationUserInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserInsertInput<TRes>
    implements CopyWith$Input$ApplicationUserInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  }) =>
      _res;
}

class Input$ApplicationUserOrderBy {
  factory Input$ApplicationUserOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
  }) =>
      Input$ApplicationUserOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
      });

  Input$ApplicationUserOrderBy._(this._$data);

  factory Input$ApplicationUserOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    return Input$ApplicationUserOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserOrderBy<Input$ApplicationUserOrderBy>
      get copyWith => CopyWith$Input$ApplicationUserOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserOrderBy<TRes> {
  factory CopyWith$Input$ApplicationUserOrderBy(
    Input$ApplicationUserOrderBy instance,
    TRes Function(Input$ApplicationUserOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationUserOrderBy;

  factory CopyWith$Input$ApplicationUserOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
  });
}

class _CopyWithImpl$Input$ApplicationUserOrderBy<TRes>
    implements CopyWith$Input$ApplicationUserOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationUserOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserOrderBy _instance;

  final TRes Function(Input$ApplicationUserOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$ApplicationUserOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserOrderBy<TRes>
    implements CopyWith$Input$ApplicationUserOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
  }) =>
      _res;
}

class Input$ApplicationUserRoleFilter {
  factory Input$ApplicationUserRoleFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserRoleFilter>? and,
    List<Input$ApplicationUserRoleFilter>? or,
    Input$ApplicationUserRoleFilter? not,
  }) =>
      Input$ApplicationUserRoleFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ApplicationUserRoleFilter._(this._$data);

  factory Input$ApplicationUserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : Input$UUIDFilter.fromJson((l$roleId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationUserRoleFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationUserRoleFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ApplicationUserRoleFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ApplicationUserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get roleId => (_$data['roleId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ApplicationUserRoleFilter>? get and =>
      (_$data['and'] as List<Input$ApplicationUserRoleFilter>?);

  List<Input$ApplicationUserRoleFilter>? get or =>
      (_$data['or'] as List<Input$ApplicationUserRoleFilter>?);

  Input$ApplicationUserRoleFilter? get not =>
      (_$data['not'] as Input$ApplicationUserRoleFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserRoleFilter<Input$ApplicationUserRoleFilter>
      get copyWith => CopyWith$Input$ApplicationUserRoleFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserRoleFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    final l$roleId = roleId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserRoleFilter<TRes> {
  factory CopyWith$Input$ApplicationUserRoleFilter(
    Input$ApplicationUserRoleFilter instance,
    TRes Function(Input$ApplicationUserRoleFilter) then,
  ) = _CopyWithImpl$Input$ApplicationUserRoleFilter;

  factory CopyWith$Input$ApplicationUserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserRoleFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserRoleFilter>? and,
    List<Input$ApplicationUserRoleFilter>? or,
    Input$ApplicationUserRoleFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get roleId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ApplicationUserRoleFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserRoleFilter<
                      Input$ApplicationUserRoleFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ApplicationUserRoleFilter>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserRoleFilter<
                      Input$ApplicationUserRoleFilter>>?)
          _fn);
  CopyWith$Input$ApplicationUserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$ApplicationUserRoleFilter<TRes>
    implements CopyWith$Input$ApplicationUserRoleFilter<TRes> {
  _CopyWithImpl$Input$ApplicationUserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserRoleFilter _instance;

  final TRes Function(Input$ApplicationUserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ApplicationUserRoleFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (roleId != _undefined) 'roleId': (roleId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationUserRoleFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$ApplicationUserRoleFilter>?),
        if (not != _undefined) 'not': (not as Input$ApplicationUserRoleFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get roleId {
    final local$roleId = _instance.roleId;
    return local$roleId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$roleId, (e) => call(roleId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ApplicationUserRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserRoleFilter<
                          Input$ApplicationUserRoleFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ApplicationUserRoleFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ApplicationUserRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserRoleFilter<
                          Input$ApplicationUserRoleFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$ApplicationUserRoleFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ApplicationUserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ApplicationUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserRoleFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationUserRoleFilter<TRes>
    implements CopyWith$Input$ApplicationUserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserRoleFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$ApplicationUserRoleFilter>? and,
    List<Input$ApplicationUserRoleFilter>? or,
    Input$ApplicationUserRoleFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get roleId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ApplicationUserRoleFilter<TRes> get not =>
      CopyWith$Input$ApplicationUserRoleFilter.stub(_res);
}

class Input$ApplicationUserRoleInsertInput {
  factory Input$ApplicationUserRoleInsertInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  }) =>
      Input$ApplicationUserRoleInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
      });

  Input$ApplicationUserRoleInsertInput._(this._$data);

  factory Input$ApplicationUserRoleInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    return Input$ApplicationUserRoleInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserRoleInsertInput<
          Input$ApplicationUserRoleInsertInput>
      get copyWith => CopyWith$Input$ApplicationUserRoleInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserRoleInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    final l$roleId = roleId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserRoleInsertInput<TRes> {
  factory CopyWith$Input$ApplicationUserRoleInsertInput(
    Input$ApplicationUserRoleInsertInput instance,
    TRes Function(Input$ApplicationUserRoleInsertInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserRoleInsertInput;

  factory CopyWith$Input$ApplicationUserRoleInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserRoleInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  });
}

class _CopyWithImpl$Input$ApplicationUserRoleInsertInput<TRes>
    implements CopyWith$Input$ApplicationUserRoleInsertInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserRoleInsertInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserRoleInsertInput _instance;

  final TRes Function(Input$ApplicationUserRoleInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
  }) =>
      _then(Input$ApplicationUserRoleInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserRoleInsertInput<TRes>
    implements CopyWith$Input$ApplicationUserRoleInsertInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserRoleInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  }) =>
      _res;
}

class Input$ApplicationUserRoleOrderBy {
  factory Input$ApplicationUserRoleOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  }) =>
      Input$ApplicationUserRoleOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
      });

  Input$ApplicationUserRoleOrderBy._(this._$data);

  factory Input$ApplicationUserRoleOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$roleId as String));
    }
    return Input$ApplicationUserRoleOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get roleId =>
      (_$data['roleId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] =
          l$roleId == null ? null : toJson$Enum$OrderByDirection(l$roleId);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserRoleOrderBy<Input$ApplicationUserRoleOrderBy>
      get copyWith => CopyWith$Input$ApplicationUserRoleOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserRoleOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    final l$roleId = roleId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserRoleOrderBy<TRes> {
  factory CopyWith$Input$ApplicationUserRoleOrderBy(
    Input$ApplicationUserRoleOrderBy instance,
    TRes Function(Input$ApplicationUserRoleOrderBy) then,
  ) = _CopyWithImpl$Input$ApplicationUserRoleOrderBy;

  factory CopyWith$Input$ApplicationUserRoleOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserRoleOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  });
}

class _CopyWithImpl$Input$ApplicationUserRoleOrderBy<TRes>
    implements CopyWith$Input$ApplicationUserRoleOrderBy<TRes> {
  _CopyWithImpl$Input$ApplicationUserRoleOrderBy(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserRoleOrderBy _instance;

  final TRes Function(Input$ApplicationUserRoleOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
  }) =>
      _then(Input$ApplicationUserRoleOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (roleId != _undefined) 'roleId': (roleId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserRoleOrderBy<TRes>
    implements CopyWith$Input$ApplicationUserRoleOrderBy<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserRoleOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  }) =>
      _res;
}

class Input$ApplicationUserRoleUpdateInput {
  factory Input$ApplicationUserRoleUpdateInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  }) =>
      Input$ApplicationUserRoleUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
      });

  Input$ApplicationUserRoleUpdateInput._(this._$data);

  factory Input$ApplicationUserRoleUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    return Input$ApplicationUserRoleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserRoleUpdateInput<
          Input$ApplicationUserRoleUpdateInput>
      get copyWith => CopyWith$Input$ApplicationUserRoleUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserRoleUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    final l$roleId = roleId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserRoleUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationUserRoleUpdateInput(
    Input$ApplicationUserRoleUpdateInput instance,
    TRes Function(Input$ApplicationUserRoleUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserRoleUpdateInput;

  factory CopyWith$Input$ApplicationUserRoleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserRoleUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  });
}

class _CopyWithImpl$Input$ApplicationUserRoleUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUserRoleUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserRoleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserRoleUpdateInput _instance;

  final TRes Function(Input$ApplicationUserRoleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
  }) =>
      _then(Input$ApplicationUserRoleUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserRoleUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUserRoleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserRoleUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
    String? roleId,
  }) =>
      _res;
}

class Input$ApplicationUserUpdateInput {
  factory Input$ApplicationUserUpdateInput({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  }) =>
      Input$ApplicationUserUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (userId != null) r'userId': userId,
      });

  Input$ApplicationUserUpdateInput._(this._$data);

  factory Input$ApplicationUserUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return Input$ApplicationUserUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get userId => (_$data['userId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserUpdateInput<Input$ApplicationUserUpdateInput>
      get copyWith => CopyWith$Input$ApplicationUserUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserUpdateInput<TRes> {
  factory CopyWith$Input$ApplicationUserUpdateInput(
    Input$ApplicationUserUpdateInput instance,
    TRes Function(Input$ApplicationUserUpdateInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserUpdateInput;

  factory CopyWith$Input$ApplicationUserUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$ApplicationUserUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUserUpdateInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserUpdateInput _instance;

  final TRes Function(Input$ApplicationUserUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$ApplicationUserUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApplicationUserUpdateInput<TRes>
    implements CopyWith$Input$ApplicationUserUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? applicationId,
    String? userId,
  }) =>
      _res;
}

class Input$AssetFilter {
  factory Input$AssetFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? fileName,
    Input$StringFilter? description,
    Input$FloatFilter? fileSize,
    Input$StringFilter? hash,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? mimeTypeId,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? ownerId,
    Input$BooleanFilter? isApproved,
    Input$BooleanFilter? isPublished,
    Input$DatetimeFilter? approvedAt,
    Input$DatetimeFilter? publishedAt,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? statusId,
    Input$UUIDFilter? promptId,
    Input$UUIDFilter? creationTypeId,
    Input$IDFilter? nodeId,
    List<Input$AssetFilter>? and,
    List<Input$AssetFilter>? or,
    Input$AssetFilter? not,
  }) =>
      Input$AssetFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (fileName != null) r'fileName': fileName,
        if (description != null) r'description': description,
        if (fileSize != null) r'fileSize': fileSize,
        if (hash != null) r'hash': hash,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (ownerId != null) r'ownerId': ownerId,
        if (isApproved != null) r'isApproved': isApproved,
        if (isPublished != null) r'isPublished': isPublished,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (statusId != null) r'statusId': statusId,
        if (promptId != null) r'promptId': promptId,
        if (creationTypeId != null) r'creationTypeId': creationTypeId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AssetFilter._(this._$data);

  factory Input$AssetFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = l$fileName == null
          ? null
          : Input$StringFilter.fromJson((l$fileName as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('fileSize')) {
      final l$fileSize = data['fileSize'];
      result$data['fileSize'] = l$fileSize == null
          ? null
          : Input$FloatFilter.fromJson((l$fileSize as Map<String, dynamic>));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = l$hash == null
          ? null
          : Input$StringFilter.fromJson((l$hash as Map<String, dynamic>));
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = l$url == null
          ? null
          : Input$StringFilter.fromJson((l$url as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$mimeTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$assetTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = l$isApproved == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isApproved as Map<String, dynamic>));
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = l$isPublished == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isPublished as Map<String, dynamic>));
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$approvedAt as Map<String, dynamic>));
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = l$publishedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$publishedAt as Map<String, dynamic>));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : Input$StringFilter.fromJson(
              (l$publicationUrl as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = l$isArchived == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isArchived as Map<String, dynamic>));
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$archivedAt as Map<String, dynamic>));
    }
    if (data.containsKey('statusId')) {
      final l$statusId = data['statusId'];
      result$data['statusId'] = l$statusId == null
          ? null
          : Input$UUIDFilter.fromJson((l$statusId as Map<String, dynamic>));
    }
    if (data.containsKey('promptId')) {
      final l$promptId = data['promptId'];
      result$data['promptId'] = l$promptId == null
          ? null
          : Input$UUIDFilter.fromJson((l$promptId as Map<String, dynamic>));
    }
    if (data.containsKey('creationTypeId')) {
      final l$creationTypeId = data['creationTypeId'];
      result$data['creationTypeId'] = l$creationTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$creationTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$AssetFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$AssetFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AssetFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AssetFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get fileName =>
      (_$data['fileName'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$FloatFilter? get fileSize => (_$data['fileSize'] as Input$FloatFilter?);

  Input$StringFilter? get hash => (_$data['hash'] as Input$StringFilter?);

  Input$StringFilter? get url => (_$data['url'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get mimeTypeId =>
      (_$data['mimeTypeId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get assetTypeId =>
      (_$data['assetTypeId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$BooleanFilter? get isApproved =>
      (_$data['isApproved'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isPublished =>
      (_$data['isPublished'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get approvedAt =>
      (_$data['approvedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get publishedAt =>
      (_$data['publishedAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get publicationUrl =>
      (_$data['publicationUrl'] as Input$StringFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$BooleanFilter? get isArchived =>
      (_$data['isArchived'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get archivedAt =>
      (_$data['archivedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get statusId => (_$data['statusId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get promptId => (_$data['promptId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get creationTypeId =>
      (_$data['creationTypeId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AssetFilter>? get and =>
      (_$data['and'] as List<Input$AssetFilter>?);

  List<Input$AssetFilter>? get or => (_$data['or'] as List<Input$AssetFilter>?);

  Input$AssetFilter? get not => (_$data['not'] as Input$AssetFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('fileSize')) {
      final l$fileSize = fileSize;
      result$data['fileSize'] = l$fileSize?.toJson();
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash?.toJson();
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId?.toJson();
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved?.toJson();
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished?.toJson();
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toJson();
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt?.toJson();
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived?.toJson();
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toJson();
    }
    if (_$data.containsKey('statusId')) {
      final l$statusId = statusId;
      result$data['statusId'] = l$statusId?.toJson();
    }
    if (_$data.containsKey('promptId')) {
      final l$promptId = promptId;
      result$data['promptId'] = l$promptId?.toJson();
    }
    if (_$data.containsKey('creationTypeId')) {
      final l$creationTypeId = creationTypeId;
      result$data['creationTypeId'] = l$creationTypeId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AssetFilter<Input$AssetFilter> get copyWith =>
      CopyWith$Input$AssetFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$fileSize = fileSize;
    final lOther$fileSize = other.fileSize;
    if (_$data.containsKey('fileSize') !=
        other._$data.containsKey('fileSize')) {
      return false;
    }
    if (l$fileSize != lOther$fileSize) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$statusId = statusId;
    final lOther$statusId = other.statusId;
    if (_$data.containsKey('statusId') !=
        other._$data.containsKey('statusId')) {
      return false;
    }
    if (l$statusId != lOther$statusId) {
      return false;
    }
    final l$promptId = promptId;
    final lOther$promptId = other.promptId;
    if (_$data.containsKey('promptId') !=
        other._$data.containsKey('promptId')) {
      return false;
    }
    if (l$promptId != lOther$promptId) {
      return false;
    }
    final l$creationTypeId = creationTypeId;
    final lOther$creationTypeId = other.creationTypeId;
    if (_$data.containsKey('creationTypeId') !=
        other._$data.containsKey('creationTypeId')) {
      return false;
    }
    if (l$creationTypeId != lOther$creationTypeId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$fileName = fileName;
    final l$description = description;
    final l$fileSize = fileSize;
    final l$hash = hash;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$mimeTypeId = mimeTypeId;
    final l$assetTypeId = assetTypeId;
    final l$ownerId = ownerId;
    final l$isApproved = isApproved;
    final l$isPublished = isPublished;
    final l$approvedAt = approvedAt;
    final l$publishedAt = publishedAt;
    final l$publicationUrl = publicationUrl;
    final l$coverUrl = coverUrl;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$statusId = statusId;
    final l$promptId = promptId;
    final l$creationTypeId = creationTypeId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('fileSize') ? l$fileSize : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('statusId') ? l$statusId : const {},
      _$data.containsKey('promptId') ? l$promptId : const {},
      _$data.containsKey('creationTypeId') ? l$creationTypeId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetFilter<TRes> {
  factory CopyWith$Input$AssetFilter(
    Input$AssetFilter instance,
    TRes Function(Input$AssetFilter) then,
  ) = _CopyWithImpl$Input$AssetFilter;

  factory CopyWith$Input$AssetFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? fileName,
    Input$StringFilter? description,
    Input$FloatFilter? fileSize,
    Input$StringFilter? hash,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? mimeTypeId,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? ownerId,
    Input$BooleanFilter? isApproved,
    Input$BooleanFilter? isPublished,
    Input$DatetimeFilter? approvedAt,
    Input$DatetimeFilter? publishedAt,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? statusId,
    Input$UUIDFilter? promptId,
    Input$UUIDFilter? creationTypeId,
    Input$IDFilter? nodeId,
    List<Input$AssetFilter>? and,
    List<Input$AssetFilter>? or,
    Input$AssetFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get fileName;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$FloatFilter<TRes> get fileSize;
  CopyWith$Input$StringFilter<TRes> get hash;
  CopyWith$Input$StringFilter<TRes> get url;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId;
  CopyWith$Input$UUIDFilter<TRes> get assetTypeId;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$BooleanFilter<TRes> get isApproved;
  CopyWith$Input$BooleanFilter<TRes> get isPublished;
  CopyWith$Input$DatetimeFilter<TRes> get approvedAt;
  CopyWith$Input$DatetimeFilter<TRes> get publishedAt;
  CopyWith$Input$StringFilter<TRes> get publicationUrl;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$BooleanFilter<TRes> get isArchived;
  CopyWith$Input$DatetimeFilter<TRes> get archivedAt;
  CopyWith$Input$UUIDFilter<TRes> get statusId;
  CopyWith$Input$UUIDFilter<TRes> get promptId;
  CopyWith$Input$UUIDFilter<TRes> get creationTypeId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AssetFilter>? Function(
              Iterable<CopyWith$Input$AssetFilter<Input$AssetFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AssetFilter>? Function(
              Iterable<CopyWith$Input$AssetFilter<Input$AssetFilter>>?)
          _fn);
  CopyWith$Input$AssetFilter<TRes> get not;
}

class _CopyWithImpl$Input$AssetFilter<TRes>
    implements CopyWith$Input$AssetFilter<TRes> {
  _CopyWithImpl$Input$AssetFilter(
    this._instance,
    this._then,
  );

  final Input$AssetFilter _instance;

  final TRes Function(Input$AssetFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? fileName = _undefined,
    Object? description = _undefined,
    Object? fileSize = _undefined,
    Object? hash = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? mimeTypeId = _undefined,
    Object? assetTypeId = _undefined,
    Object? ownerId = _undefined,
    Object? isApproved = _undefined,
    Object? isPublished = _undefined,
    Object? approvedAt = _undefined,
    Object? publishedAt = _undefined,
    Object? publicationUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? statusId = _undefined,
    Object? promptId = _undefined,
    Object? creationTypeId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AssetFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (fileName != _undefined)
          'fileName': (fileName as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (fileSize != _undefined)
          'fileSize': (fileSize as Input$FloatFilter?),
        if (hash != _undefined) 'hash': (hash as Input$StringFilter?),
        if (url != _undefined) 'url': (url as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Input$UUIDFilter?),
        if (assetTypeId != _undefined)
          'assetTypeId': (assetTypeId as Input$UUIDFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (isApproved != _undefined)
          'isApproved': (isApproved as Input$BooleanFilter?),
        if (isPublished != _undefined)
          'isPublished': (isPublished as Input$BooleanFilter?),
        if (approvedAt != _undefined)
          'approvedAt': (approvedAt as Input$DatetimeFilter?),
        if (publishedAt != _undefined)
          'publishedAt': (publishedAt as Input$DatetimeFilter?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as Input$StringFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (isArchived != _undefined)
          'isArchived': (isArchived as Input$BooleanFilter?),
        if (archivedAt != _undefined)
          'archivedAt': (archivedAt as Input$DatetimeFilter?),
        if (statusId != _undefined) 'statusId': (statusId as Input$UUIDFilter?),
        if (promptId != _undefined) 'promptId': (promptId as Input$UUIDFilter?),
        if (creationTypeId != _undefined)
          'creationTypeId': (creationTypeId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AssetFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AssetFilter>?),
        if (not != _undefined) 'not': (not as Input$AssetFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get fileName {
    final local$fileName = _instance.fileName;
    return local$fileName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fileName, (e) => call(fileName: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$FloatFilter<TRes> get fileSize {
    final local$fileSize = _instance.fileSize;
    return local$fileSize == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$fileSize, (e) => call(fileSize: e));
  }

  CopyWith$Input$StringFilter<TRes> get hash {
    final local$hash = _instance.hash;
    return local$hash == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$hash, (e) => call(hash: e));
  }

  CopyWith$Input$StringFilter<TRes> get url {
    final local$url = _instance.url;
    return local$url == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$url, (e) => call(url: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId {
    final local$mimeTypeId = _instance.mimeTypeId;
    return local$mimeTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$mimeTypeId, (e) => call(mimeTypeId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get assetTypeId {
    final local$assetTypeId = _instance.assetTypeId;
    return local$assetTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$assetTypeId, (e) => call(assetTypeId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isApproved {
    final local$isApproved = _instance.isApproved;
    return local$isApproved == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isApproved, (e) => call(isApproved: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isPublished {
    final local$isPublished = _instance.isPublished;
    return local$isPublished == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isPublished, (e) => call(isPublished: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get approvedAt {
    final local$approvedAt = _instance.approvedAt;
    return local$approvedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$approvedAt, (e) => call(approvedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get publishedAt {
    final local$publishedAt = _instance.publishedAt;
    return local$publishedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$publishedAt, (e) => call(publishedAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get publicationUrl {
    final local$publicationUrl = _instance.publicationUrl;
    return local$publicationUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$publicationUrl, (e) => call(publicationUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isArchived {
    final local$isArchived = _instance.isArchived;
    return local$isArchived == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isArchived, (e) => call(isArchived: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get archivedAt {
    final local$archivedAt = _instance.archivedAt;
    return local$archivedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$archivedAt, (e) => call(archivedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get statusId {
    final local$statusId = _instance.statusId;
    return local$statusId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$statusId, (e) => call(statusId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get promptId {
    final local$promptId = _instance.promptId;
    return local$promptId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$promptId, (e) => call(promptId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get creationTypeId {
    final local$creationTypeId = _instance.creationTypeId;
    return local$creationTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$creationTypeId, (e) => call(creationTypeId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AssetFilter>? Function(
                  Iterable<CopyWith$Input$AssetFilter<Input$AssetFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AssetFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AssetFilter>? Function(
                  Iterable<CopyWith$Input$AssetFilter<Input$AssetFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AssetFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AssetFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AssetFilter.stub(_then(_instance))
        : CopyWith$Input$AssetFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AssetFilter<TRes>
    implements CopyWith$Input$AssetFilter<TRes> {
  _CopyWithStubImpl$Input$AssetFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? fileName,
    Input$StringFilter? description,
    Input$FloatFilter? fileSize,
    Input$StringFilter? hash,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? mimeTypeId,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? ownerId,
    Input$BooleanFilter? isApproved,
    Input$BooleanFilter? isPublished,
    Input$DatetimeFilter? approvedAt,
    Input$DatetimeFilter? publishedAt,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? statusId,
    Input$UUIDFilter? promptId,
    Input$UUIDFilter? creationTypeId,
    Input$IDFilter? nodeId,
    List<Input$AssetFilter>? and,
    List<Input$AssetFilter>? or,
    Input$AssetFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get fileName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$FloatFilter<TRes> get fileSize =>
      CopyWith$Input$FloatFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get hash =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get url =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get assetTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isApproved =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isPublished =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get approvedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get publishedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get publicationUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isArchived =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get archivedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get statusId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get promptId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get creationTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AssetFilter<TRes> get not =>
      CopyWith$Input$AssetFilter.stub(_res);
}

class Input$AssetInsertInput {
  factory Input$AssetInsertInput({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  }) =>
      Input$AssetInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (fileName != null) r'fileName': fileName,
        if (description != null) r'description': description,
        if (fileSize != null) r'fileSize': fileSize,
        if (data != null) r'data': data,
        if (hash != null) r'hash': hash,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (ownerId != null) r'ownerId': ownerId,
        if (isApproved != null) r'isApproved': isApproved,
        if (isPublished != null) r'isPublished': isPublished,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (statusId != null) r'statusId': statusId,
        if (promptId != null) r'promptId': promptId,
        if (creationTypeId != null) r'creationTypeId': creationTypeId,
      });

  Input$AssetInsertInput._(this._$data);

  factory Input$AssetInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = (l$fileName as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('fileSize')) {
      final l$fileSize = data['fileSize'];
      result$data['fileSize'] = (l$fileSize as num?)?.toDouble();
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = (l$hash as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = (l$assetTypeId as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = (l$isApproved as bool?);
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : DateTime.parse((l$approvedAt as String));
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = l$publishedAt == null
          ? null
          : DateTime.parse((l$publishedAt as String));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = (l$publicationUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : DateTime.parse((l$archivedAt as String));
    }
    if (data.containsKey('statusId')) {
      final l$statusId = data['statusId'];
      result$data['statusId'] = (l$statusId as String?);
    }
    if (data.containsKey('promptId')) {
      final l$promptId = data['promptId'];
      result$data['promptId'] = (l$promptId as String?);
    }
    if (data.containsKey('creationTypeId')) {
      final l$creationTypeId = data['creationTypeId'];
      result$data['creationTypeId'] = (l$creationTypeId as String?);
    }
    return Input$AssetInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get fileName => (_$data['fileName'] as String?);

  String? get description => (_$data['description'] as String?);

  double? get fileSize => (_$data['fileSize'] as double?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get hash => (_$data['hash'] as String?);

  String? get url => (_$data['url'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  String? get assetTypeId => (_$data['assetTypeId'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  bool? get isApproved => (_$data['isApproved'] as bool?);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  DateTime? get approvedAt => (_$data['approvedAt'] as DateTime?);

  DateTime? get publishedAt => (_$data['publishedAt'] as DateTime?);

  String? get publicationUrl => (_$data['publicationUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  bool? get isArchived => (_$data['isArchived'] as bool?);

  DateTime? get archivedAt => (_$data['archivedAt'] as DateTime?);

  String? get statusId => (_$data['statusId'] as String?);

  String? get promptId => (_$data['promptId'] as String?);

  String? get creationTypeId => (_$data['creationTypeId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('fileSize')) {
      final l$fileSize = fileSize;
      result$data['fileSize'] = l$fileSize;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved;
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toIso8601String();
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt?.toIso8601String();
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toIso8601String();
    }
    if (_$data.containsKey('statusId')) {
      final l$statusId = statusId;
      result$data['statusId'] = l$statusId;
    }
    if (_$data.containsKey('promptId')) {
      final l$promptId = promptId;
      result$data['promptId'] = l$promptId;
    }
    if (_$data.containsKey('creationTypeId')) {
      final l$creationTypeId = creationTypeId;
      result$data['creationTypeId'] = l$creationTypeId;
    }
    return result$data;
  }

  CopyWith$Input$AssetInsertInput<Input$AssetInsertInput> get copyWith =>
      CopyWith$Input$AssetInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$fileSize = fileSize;
    final lOther$fileSize = other.fileSize;
    if (_$data.containsKey('fileSize') !=
        other._$data.containsKey('fileSize')) {
      return false;
    }
    if (l$fileSize != lOther$fileSize) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$statusId = statusId;
    final lOther$statusId = other.statusId;
    if (_$data.containsKey('statusId') !=
        other._$data.containsKey('statusId')) {
      return false;
    }
    if (l$statusId != lOther$statusId) {
      return false;
    }
    final l$promptId = promptId;
    final lOther$promptId = other.promptId;
    if (_$data.containsKey('promptId') !=
        other._$data.containsKey('promptId')) {
      return false;
    }
    if (l$promptId != lOther$promptId) {
      return false;
    }
    final l$creationTypeId = creationTypeId;
    final lOther$creationTypeId = other.creationTypeId;
    if (_$data.containsKey('creationTypeId') !=
        other._$data.containsKey('creationTypeId')) {
      return false;
    }
    if (l$creationTypeId != lOther$creationTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$fileName = fileName;
    final l$description = description;
    final l$fileSize = fileSize;
    final l$data = data;
    final l$hash = hash;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$mimeTypeId = mimeTypeId;
    final l$assetTypeId = assetTypeId;
    final l$ownerId = ownerId;
    final l$isApproved = isApproved;
    final l$isPublished = isPublished;
    final l$approvedAt = approvedAt;
    final l$publishedAt = publishedAt;
    final l$publicationUrl = publicationUrl;
    final l$coverUrl = coverUrl;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$statusId = statusId;
    final l$promptId = promptId;
    final l$creationTypeId = creationTypeId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('fileSize') ? l$fileSize : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('statusId') ? l$statusId : const {},
      _$data.containsKey('promptId') ? l$promptId : const {},
      _$data.containsKey('creationTypeId') ? l$creationTypeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetInsertInput<TRes> {
  factory CopyWith$Input$AssetInsertInput(
    Input$AssetInsertInput instance,
    TRes Function(Input$AssetInsertInput) then,
  ) = _CopyWithImpl$Input$AssetInsertInput;

  factory CopyWith$Input$AssetInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetInsertInput;

  TRes call({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  });
}

class _CopyWithImpl$Input$AssetInsertInput<TRes>
    implements CopyWith$Input$AssetInsertInput<TRes> {
  _CopyWithImpl$Input$AssetInsertInput(
    this._instance,
    this._then,
  );

  final Input$AssetInsertInput _instance;

  final TRes Function(Input$AssetInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? fileName = _undefined,
    Object? description = _undefined,
    Object? fileSize = _undefined,
    Object? data = _undefined,
    Object? hash = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? mimeTypeId = _undefined,
    Object? assetTypeId = _undefined,
    Object? ownerId = _undefined,
    Object? isApproved = _undefined,
    Object? isPublished = _undefined,
    Object? approvedAt = _undefined,
    Object? publishedAt = _undefined,
    Object? publicationUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? statusId = _undefined,
    Object? promptId = _undefined,
    Object? creationTypeId = _undefined,
  }) =>
      _then(Input$AssetInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (fileName != _undefined) 'fileName': (fileName as String?),
        if (description != _undefined) 'description': (description as String?),
        if (fileSize != _undefined) 'fileSize': (fileSize as double?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (hash != _undefined) 'hash': (hash as String?),
        if (url != _undefined) 'url': (url as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (assetTypeId != _undefined) 'assetTypeId': (assetTypeId as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (isApproved != _undefined) 'isApproved': (isApproved as bool?),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (approvedAt != _undefined) 'approvedAt': (approvedAt as DateTime?),
        if (publishedAt != _undefined)
          'publishedAt': (publishedAt as DateTime?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (archivedAt != _undefined) 'archivedAt': (archivedAt as DateTime?),
        if (statusId != _undefined) 'statusId': (statusId as String?),
        if (promptId != _undefined) 'promptId': (promptId as String?),
        if (creationTypeId != _undefined)
          'creationTypeId': (creationTypeId as String?),
      }));
}

class _CopyWithStubImpl$Input$AssetInsertInput<TRes>
    implements CopyWith$Input$AssetInsertInput<TRes> {
  _CopyWithStubImpl$Input$AssetInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  }) =>
      _res;
}

class Input$AssetOrderBy {
  factory Input$AssetOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? fileSize,
    Enum$OrderByDirection? hash,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? isPublished,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publishedAt,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? statusId,
    Enum$OrderByDirection? promptId,
    Enum$OrderByDirection? creationTypeId,
  }) =>
      Input$AssetOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (fileName != null) r'fileName': fileName,
        if (description != null) r'description': description,
        if (fileSize != null) r'fileSize': fileSize,
        if (hash != null) r'hash': hash,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (ownerId != null) r'ownerId': ownerId,
        if (isApproved != null) r'isApproved': isApproved,
        if (isPublished != null) r'isPublished': isPublished,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (statusId != null) r'statusId': statusId,
        if (promptId != null) r'promptId': promptId,
        if (creationTypeId != null) r'creationTypeId': creationTypeId,
      });

  Input$AssetOrderBy._(this._$data);

  factory Input$AssetOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = l$fileName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$fileName as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('fileSize')) {
      final l$fileSize = data['fileSize'];
      result$data['fileSize'] = l$fileSize == null
          ? null
          : fromJson$Enum$OrderByDirection((l$fileSize as String));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = l$hash == null
          ? null
          : fromJson$Enum$OrderByDirection((l$hash as String));
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = l$url == null
          ? null
          : fromJson$Enum$OrderByDirection((l$url as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$mimeTypeId as String));
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$assetTypeId as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = l$isApproved == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isApproved as String));
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = l$isPublished == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isPublished as String));
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$approvedAt as String));
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = l$publishedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$publishedAt as String));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$publicationUrl as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = l$isArchived == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isArchived as String));
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$archivedAt as String));
    }
    if (data.containsKey('statusId')) {
      final l$statusId = data['statusId'];
      result$data['statusId'] = l$statusId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$statusId as String));
    }
    if (data.containsKey('promptId')) {
      final l$promptId = data['promptId'];
      result$data['promptId'] = l$promptId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$promptId as String));
    }
    if (data.containsKey('creationTypeId')) {
      final l$creationTypeId = data['creationTypeId'];
      result$data['creationTypeId'] = l$creationTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$creationTypeId as String));
    }
    return Input$AssetOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get fileName =>
      (_$data['fileName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get fileSize =>
      (_$data['fileSize'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get hash => (_$data['hash'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get url => (_$data['url'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get mimeTypeId =>
      (_$data['mimeTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get assetTypeId =>
      (_$data['assetTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isApproved =>
      (_$data['isApproved'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isPublished =>
      (_$data['isPublished'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get approvedAt =>
      (_$data['approvedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get publishedAt =>
      (_$data['publishedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get publicationUrl =>
      (_$data['publicationUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isArchived =>
      (_$data['isArchived'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get archivedAt =>
      (_$data['archivedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get statusId =>
      (_$data['statusId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get promptId =>
      (_$data['promptId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get creationTypeId =>
      (_$data['creationTypeId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] =
          l$fileName == null ? null : toJson$Enum$OrderByDirection(l$fileName);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('fileSize')) {
      final l$fileSize = fileSize;
      result$data['fileSize'] =
          l$fileSize == null ? null : toJson$Enum$OrderByDirection(l$fileSize);
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] =
          l$hash == null ? null : toJson$Enum$OrderByDirection(l$hash);
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] =
          l$url == null ? null : toJson$Enum$OrderByDirection(l$url);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$mimeTypeId);
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$assetTypeId);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved == null
          ? null
          : toJson$Enum$OrderByDirection(l$isApproved);
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished == null
          ? null
          : toJson$Enum$OrderByDirection(l$isPublished);
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$approvedAt);
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$publishedAt);
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$publicationUrl);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived == null
          ? null
          : toJson$Enum$OrderByDirection(l$isArchived);
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$archivedAt);
    }
    if (_$data.containsKey('statusId')) {
      final l$statusId = statusId;
      result$data['statusId'] =
          l$statusId == null ? null : toJson$Enum$OrderByDirection(l$statusId);
    }
    if (_$data.containsKey('promptId')) {
      final l$promptId = promptId;
      result$data['promptId'] =
          l$promptId == null ? null : toJson$Enum$OrderByDirection(l$promptId);
    }
    if (_$data.containsKey('creationTypeId')) {
      final l$creationTypeId = creationTypeId;
      result$data['creationTypeId'] = l$creationTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$creationTypeId);
    }
    return result$data;
  }

  CopyWith$Input$AssetOrderBy<Input$AssetOrderBy> get copyWith =>
      CopyWith$Input$AssetOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$fileSize = fileSize;
    final lOther$fileSize = other.fileSize;
    if (_$data.containsKey('fileSize') !=
        other._$data.containsKey('fileSize')) {
      return false;
    }
    if (l$fileSize != lOther$fileSize) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$statusId = statusId;
    final lOther$statusId = other.statusId;
    if (_$data.containsKey('statusId') !=
        other._$data.containsKey('statusId')) {
      return false;
    }
    if (l$statusId != lOther$statusId) {
      return false;
    }
    final l$promptId = promptId;
    final lOther$promptId = other.promptId;
    if (_$data.containsKey('promptId') !=
        other._$data.containsKey('promptId')) {
      return false;
    }
    if (l$promptId != lOther$promptId) {
      return false;
    }
    final l$creationTypeId = creationTypeId;
    final lOther$creationTypeId = other.creationTypeId;
    if (_$data.containsKey('creationTypeId') !=
        other._$data.containsKey('creationTypeId')) {
      return false;
    }
    if (l$creationTypeId != lOther$creationTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$fileName = fileName;
    final l$description = description;
    final l$fileSize = fileSize;
    final l$hash = hash;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$mimeTypeId = mimeTypeId;
    final l$assetTypeId = assetTypeId;
    final l$ownerId = ownerId;
    final l$isApproved = isApproved;
    final l$isPublished = isPublished;
    final l$approvedAt = approvedAt;
    final l$publishedAt = publishedAt;
    final l$publicationUrl = publicationUrl;
    final l$coverUrl = coverUrl;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$statusId = statusId;
    final l$promptId = promptId;
    final l$creationTypeId = creationTypeId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('fileSize') ? l$fileSize : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('statusId') ? l$statusId : const {},
      _$data.containsKey('promptId') ? l$promptId : const {},
      _$data.containsKey('creationTypeId') ? l$creationTypeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetOrderBy<TRes> {
  factory CopyWith$Input$AssetOrderBy(
    Input$AssetOrderBy instance,
    TRes Function(Input$AssetOrderBy) then,
  ) = _CopyWithImpl$Input$AssetOrderBy;

  factory CopyWith$Input$AssetOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? fileSize,
    Enum$OrderByDirection? hash,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? isPublished,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publishedAt,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? statusId,
    Enum$OrderByDirection? promptId,
    Enum$OrderByDirection? creationTypeId,
  });
}

class _CopyWithImpl$Input$AssetOrderBy<TRes>
    implements CopyWith$Input$AssetOrderBy<TRes> {
  _CopyWithImpl$Input$AssetOrderBy(
    this._instance,
    this._then,
  );

  final Input$AssetOrderBy _instance;

  final TRes Function(Input$AssetOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? fileName = _undefined,
    Object? description = _undefined,
    Object? fileSize = _undefined,
    Object? hash = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? mimeTypeId = _undefined,
    Object? assetTypeId = _undefined,
    Object? ownerId = _undefined,
    Object? isApproved = _undefined,
    Object? isPublished = _undefined,
    Object? approvedAt = _undefined,
    Object? publishedAt = _undefined,
    Object? publicationUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? statusId = _undefined,
    Object? promptId = _undefined,
    Object? creationTypeId = _undefined,
  }) =>
      _then(Input$AssetOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (fileName != _undefined)
          'fileName': (fileName as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (fileSize != _undefined)
          'fileSize': (fileSize as Enum$OrderByDirection?),
        if (hash != _undefined) 'hash': (hash as Enum$OrderByDirection?),
        if (url != _undefined) 'url': (url as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Enum$OrderByDirection?),
        if (assetTypeId != _undefined)
          'assetTypeId': (assetTypeId as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
        if (isApproved != _undefined)
          'isApproved': (isApproved as Enum$OrderByDirection?),
        if (isPublished != _undefined)
          'isPublished': (isPublished as Enum$OrderByDirection?),
        if (approvedAt != _undefined)
          'approvedAt': (approvedAt as Enum$OrderByDirection?),
        if (publishedAt != _undefined)
          'publishedAt': (publishedAt as Enum$OrderByDirection?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
        if (isArchived != _undefined)
          'isArchived': (isArchived as Enum$OrderByDirection?),
        if (archivedAt != _undefined)
          'archivedAt': (archivedAt as Enum$OrderByDirection?),
        if (statusId != _undefined)
          'statusId': (statusId as Enum$OrderByDirection?),
        if (promptId != _undefined)
          'promptId': (promptId as Enum$OrderByDirection?),
        if (creationTypeId != _undefined)
          'creationTypeId': (creationTypeId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AssetOrderBy<TRes>
    implements CopyWith$Input$AssetOrderBy<TRes> {
  _CopyWithStubImpl$Input$AssetOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? fileSize,
    Enum$OrderByDirection? hash,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? isPublished,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publishedAt,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? statusId,
    Enum$OrderByDirection? promptId,
    Enum$OrderByDirection? creationTypeId,
  }) =>
      _res;
}

class Input$AssetStatusFilter {
  factory Input$AssetStatusFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetStatusFilter>? and,
    List<Input$AssetStatusFilter>? or,
    Input$AssetStatusFilter? not,
  }) =>
      Input$AssetStatusFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AssetStatusFilter._(this._$data);

  factory Input$AssetStatusFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AssetStatusFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AssetStatusFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AssetStatusFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AssetStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AssetStatusFilter>? get and =>
      (_$data['and'] as List<Input$AssetStatusFilter>?);

  List<Input$AssetStatusFilter>? get or =>
      (_$data['or'] as List<Input$AssetStatusFilter>?);

  Input$AssetStatusFilter? get not =>
      (_$data['not'] as Input$AssetStatusFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AssetStatusFilter<Input$AssetStatusFilter> get copyWith =>
      CopyWith$Input$AssetStatusFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetStatusFilter<TRes> {
  factory CopyWith$Input$AssetStatusFilter(
    Input$AssetStatusFilter instance,
    TRes Function(Input$AssetStatusFilter) then,
  ) = _CopyWithImpl$Input$AssetStatusFilter;

  factory CopyWith$Input$AssetStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetStatusFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetStatusFilter>? and,
    List<Input$AssetStatusFilter>? or,
    Input$AssetStatusFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AssetStatusFilter>? Function(
              Iterable<
                  CopyWith$Input$AssetStatusFilter<Input$AssetStatusFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AssetStatusFilter>? Function(
              Iterable<
                  CopyWith$Input$AssetStatusFilter<Input$AssetStatusFilter>>?)
          _fn);
  CopyWith$Input$AssetStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$AssetStatusFilter<TRes>
    implements CopyWith$Input$AssetStatusFilter<TRes> {
  _CopyWithImpl$Input$AssetStatusFilter(
    this._instance,
    this._then,
  );

  final Input$AssetStatusFilter _instance;

  final TRes Function(Input$AssetStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AssetStatusFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AssetStatusFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AssetStatusFilter>?),
        if (not != _undefined) 'not': (not as Input$AssetStatusFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AssetStatusFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetStatusFilter<
                          Input$AssetStatusFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AssetStatusFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AssetStatusFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetStatusFilter<
                          Input$AssetStatusFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AssetStatusFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AssetStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AssetStatusFilter.stub(_then(_instance))
        : CopyWith$Input$AssetStatusFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AssetStatusFilter<TRes>
    implements CopyWith$Input$AssetStatusFilter<TRes> {
  _CopyWithStubImpl$Input$AssetStatusFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetStatusFilter>? and,
    List<Input$AssetStatusFilter>? or,
    Input$AssetStatusFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AssetStatusFilter<TRes> get not =>
      CopyWith$Input$AssetStatusFilter.stub(_res);
}

class Input$AssetStatusInsertInput {
  factory Input$AssetStatusInsertInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$AssetStatusInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetStatusInsertInput._(this._$data);

  factory Input$AssetStatusInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetStatusInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetStatusInsertInput<Input$AssetStatusInsertInput>
      get copyWith => CopyWith$Input$AssetStatusInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetStatusInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetStatusInsertInput<TRes> {
  factory CopyWith$Input$AssetStatusInsertInput(
    Input$AssetStatusInsertInput instance,
    TRes Function(Input$AssetStatusInsertInput) then,
  ) = _CopyWithImpl$Input$AssetStatusInsertInput;

  factory CopyWith$Input$AssetStatusInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetStatusInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetStatusInsertInput<TRes>
    implements CopyWith$Input$AssetStatusInsertInput<TRes> {
  _CopyWithImpl$Input$AssetStatusInsertInput(
    this._instance,
    this._then,
  );

  final Input$AssetStatusInsertInput _instance;

  final TRes Function(Input$AssetStatusInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetStatusInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetStatusInsertInput<TRes>
    implements CopyWith$Input$AssetStatusInsertInput<TRes> {
  _CopyWithStubImpl$Input$AssetStatusInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetStatusOrderBy {
  factory Input$AssetStatusOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$AssetStatusOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetStatusOrderBy._(this._$data);

  factory Input$AssetStatusOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$AssetStatusOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$AssetStatusOrderBy<Input$AssetStatusOrderBy> get copyWith =>
      CopyWith$Input$AssetStatusOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetStatusOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetStatusOrderBy<TRes> {
  factory CopyWith$Input$AssetStatusOrderBy(
    Input$AssetStatusOrderBy instance,
    TRes Function(Input$AssetStatusOrderBy) then,
  ) = _CopyWithImpl$Input$AssetStatusOrderBy;

  factory CopyWith$Input$AssetStatusOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetStatusOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$AssetStatusOrderBy<TRes>
    implements CopyWith$Input$AssetStatusOrderBy<TRes> {
  _CopyWithImpl$Input$AssetStatusOrderBy(
    this._instance,
    this._then,
  );

  final Input$AssetStatusOrderBy _instance;

  final TRes Function(Input$AssetStatusOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetStatusOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AssetStatusOrderBy<TRes>
    implements CopyWith$Input$AssetStatusOrderBy<TRes> {
  _CopyWithStubImpl$Input$AssetStatusOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$AssetStatusUpdateInput {
  factory Input$AssetStatusUpdateInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$AssetStatusUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetStatusUpdateInput._(this._$data);

  factory Input$AssetStatusUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetStatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetStatusUpdateInput<Input$AssetStatusUpdateInput>
      get copyWith => CopyWith$Input$AssetStatusUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetStatusUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetStatusUpdateInput<TRes> {
  factory CopyWith$Input$AssetStatusUpdateInput(
    Input$AssetStatusUpdateInput instance,
    TRes Function(Input$AssetStatusUpdateInput) then,
  ) = _CopyWithImpl$Input$AssetStatusUpdateInput;

  factory CopyWith$Input$AssetStatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetStatusUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetStatusUpdateInput<TRes>
    implements CopyWith$Input$AssetStatusUpdateInput<TRes> {
  _CopyWithImpl$Input$AssetStatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AssetStatusUpdateInput _instance;

  final TRes Function(Input$AssetStatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetStatusUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetStatusUpdateInput<TRes>
    implements CopyWith$Input$AssetStatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AssetStatusUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeFilter {
  factory Input$AssetTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeFilter>? and,
    List<Input$AssetTypeFilter>? or,
    Input$AssetTypeFilter? not,
  }) =>
      Input$AssetTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AssetTypeFilter._(this._$data);

  factory Input$AssetTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AssetTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AssetTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AssetTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$AssetTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AssetTypeFilter>? get and =>
      (_$data['and'] as List<Input$AssetTypeFilter>?);

  List<Input$AssetTypeFilter>? get or =>
      (_$data['or'] as List<Input$AssetTypeFilter>?);

  Input$AssetTypeFilter? get not => (_$data['not'] as Input$AssetTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeFilter<Input$AssetTypeFilter> get copyWith =>
      CopyWith$Input$AssetTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeFilter<TRes> {
  factory CopyWith$Input$AssetTypeFilter(
    Input$AssetTypeFilter instance,
    TRes Function(Input$AssetTypeFilter) then,
  ) = _CopyWithImpl$Input$AssetTypeFilter;

  factory CopyWith$Input$AssetTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeFilter>? and,
    List<Input$AssetTypeFilter>? or,
    Input$AssetTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AssetTypeFilter>? Function(
              Iterable<CopyWith$Input$AssetTypeFilter<Input$AssetTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AssetTypeFilter>? Function(
              Iterable<CopyWith$Input$AssetTypeFilter<Input$AssetTypeFilter>>?)
          _fn);
  CopyWith$Input$AssetTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$AssetTypeFilter<TRes>
    implements CopyWith$Input$AssetTypeFilter<TRes> {
  _CopyWithImpl$Input$AssetTypeFilter(
    this._instance,
    this._then,
  );

  final Input$AssetTypeFilter _instance;

  final TRes Function(Input$AssetTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AssetTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$AssetTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$AssetTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$AssetTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AssetTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetTypeFilter<Input$AssetTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AssetTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$AssetTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetTypeFilter<Input$AssetTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AssetTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AssetTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AssetTypeFilter.stub(_then(_instance))
        : CopyWith$Input$AssetTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AssetTypeFilter<TRes>
    implements CopyWith$Input$AssetTypeFilter<TRes> {
  _CopyWithStubImpl$Input$AssetTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeFilter>? and,
    List<Input$AssetTypeFilter>? or,
    Input$AssetTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AssetTypeFilter<TRes> get not =>
      CopyWith$Input$AssetTypeFilter.stub(_res);
}

class Input$AssetTypeInsertInput {
  factory Input$AssetTypeInsertInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$AssetTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeInsertInput._(this._$data);

  factory Input$AssetTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeInsertInput<Input$AssetTypeInsertInput>
      get copyWith => CopyWith$Input$AssetTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeInsertInput<TRes> {
  factory CopyWith$Input$AssetTypeInsertInput(
    Input$AssetTypeInsertInput instance,
    TRes Function(Input$AssetTypeInsertInput) then,
  ) = _CopyWithImpl$Input$AssetTypeInsertInput;

  factory CopyWith$Input$AssetTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeInsertInput<TRes>
    implements CopyWith$Input$AssetTypeInsertInput<TRes> {
  _CopyWithImpl$Input$AssetTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$AssetTypeInsertInput _instance;

  final TRes Function(Input$AssetTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeInsertInput<TRes>
    implements CopyWith$Input$AssetTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$AssetTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeMimeTypeFilter {
  factory Input$AssetTypeMimeTypeFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? mimeTypeId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeMimeTypeFilter>? and,
    List<Input$AssetTypeMimeTypeFilter>? or,
    Input$AssetTypeMimeTypeFilter? not,
  }) =>
      Input$AssetTypeMimeTypeFilter._({
        if (id != null) r'id': id,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$AssetTypeMimeTypeFilter._(this._$data);

  factory Input$AssetTypeMimeTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$assetTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$mimeTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$AssetTypeMimeTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$AssetTypeMimeTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$AssetTypeMimeTypeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$AssetTypeMimeTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get assetTypeId =>
      (_$data['assetTypeId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get mimeTypeId =>
      (_$data['mimeTypeId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$AssetTypeMimeTypeFilter>? get and =>
      (_$data['and'] as List<Input$AssetTypeMimeTypeFilter>?);

  List<Input$AssetTypeMimeTypeFilter>? get or =>
      (_$data['or'] as List<Input$AssetTypeMimeTypeFilter>?);

  Input$AssetTypeMimeTypeFilter? get not =>
      (_$data['not'] as Input$AssetTypeMimeTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId?.toJson();
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeMimeTypeFilter<Input$AssetTypeMimeTypeFilter>
      get copyWith => CopyWith$Input$AssetTypeMimeTypeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeMimeTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$assetTypeId = assetTypeId;
    final l$mimeTypeId = mimeTypeId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeMimeTypeFilter<TRes> {
  factory CopyWith$Input$AssetTypeMimeTypeFilter(
    Input$AssetTypeMimeTypeFilter instance,
    TRes Function(Input$AssetTypeMimeTypeFilter) then,
  ) = _CopyWithImpl$Input$AssetTypeMimeTypeFilter;

  factory CopyWith$Input$AssetTypeMimeTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeMimeTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? mimeTypeId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeMimeTypeFilter>? and,
    List<Input$AssetTypeMimeTypeFilter>? or,
    Input$AssetTypeMimeTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get assetTypeId;
  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$AssetTypeMimeTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$AssetTypeMimeTypeFilter<
                      Input$AssetTypeMimeTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$AssetTypeMimeTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$AssetTypeMimeTypeFilter<
                      Input$AssetTypeMimeTypeFilter>>?)
          _fn);
  CopyWith$Input$AssetTypeMimeTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$AssetTypeMimeTypeFilter<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeFilter<TRes> {
  _CopyWithImpl$Input$AssetTypeMimeTypeFilter(
    this._instance,
    this._then,
  );

  final Input$AssetTypeMimeTypeFilter _instance;

  final TRes Function(Input$AssetTypeMimeTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? assetTypeId = _undefined,
    Object? mimeTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$AssetTypeMimeTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (assetTypeId != _undefined)
          'assetTypeId': (assetTypeId as Input$UUIDFilter?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$AssetTypeMimeTypeFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$AssetTypeMimeTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$AssetTypeMimeTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get assetTypeId {
    final local$assetTypeId = _instance.assetTypeId;
    return local$assetTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$assetTypeId, (e) => call(assetTypeId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId {
    final local$mimeTypeId = _instance.mimeTypeId;
    return local$mimeTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$mimeTypeId, (e) => call(mimeTypeId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$AssetTypeMimeTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetTypeMimeTypeFilter<
                          Input$AssetTypeMimeTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$AssetTypeMimeTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$AssetTypeMimeTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$AssetTypeMimeTypeFilter<
                          Input$AssetTypeMimeTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$AssetTypeMimeTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$AssetTypeMimeTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$AssetTypeMimeTypeFilter.stub(_then(_instance))
        : CopyWith$Input$AssetTypeMimeTypeFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$AssetTypeMimeTypeFilter<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeFilter<TRes> {
  _CopyWithStubImpl$Input$AssetTypeMimeTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? assetTypeId,
    Input$UUIDFilter? mimeTypeId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$AssetTypeMimeTypeFilter>? and,
    List<Input$AssetTypeMimeTypeFilter>? or,
    Input$AssetTypeMimeTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get assetTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$AssetTypeMimeTypeFilter<TRes> get not =>
      CopyWith$Input$AssetTypeMimeTypeFilter.stub(_res);
}

class Input$AssetTypeMimeTypeInsertInput {
  factory Input$AssetTypeMimeTypeInsertInput({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  }) =>
      Input$AssetTypeMimeTypeInsertInput._({
        if (id != null) r'id': id,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeMimeTypeInsertInput._(this._$data);

  factory Input$AssetTypeMimeTypeInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = (l$assetTypeId as String?);
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetTypeMimeTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get assetTypeId => (_$data['assetTypeId'] as String?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId;
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeMimeTypeInsertInput<
          Input$AssetTypeMimeTypeInsertInput>
      get copyWith => CopyWith$Input$AssetTypeMimeTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeMimeTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$assetTypeId = assetTypeId;
    final l$mimeTypeId = mimeTypeId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeMimeTypeInsertInput<TRes> {
  factory CopyWith$Input$AssetTypeMimeTypeInsertInput(
    Input$AssetTypeMimeTypeInsertInput instance,
    TRes Function(Input$AssetTypeMimeTypeInsertInput) then,
  ) = _CopyWithImpl$Input$AssetTypeMimeTypeInsertInput;

  factory CopyWith$Input$AssetTypeMimeTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeMimeTypeInsertInput;

  TRes call({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeMimeTypeInsertInput<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeInsertInput<TRes> {
  _CopyWithImpl$Input$AssetTypeMimeTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$AssetTypeMimeTypeInsertInput _instance;

  final TRes Function(Input$AssetTypeMimeTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? assetTypeId = _undefined,
    Object? mimeTypeId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeMimeTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (assetTypeId != _undefined) 'assetTypeId': (assetTypeId as String?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeMimeTypeInsertInput<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$AssetTypeMimeTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeMimeTypeOrderBy {
  factory Input$AssetTypeMimeTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$AssetTypeMimeTypeOrderBy._({
        if (id != null) r'id': id,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeMimeTypeOrderBy._(this._$data);

  factory Input$AssetTypeMimeTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$assetTypeId as String));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$mimeTypeId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$AssetTypeMimeTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get assetTypeId =>
      (_$data['assetTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get mimeTypeId =>
      (_$data['mimeTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$assetTypeId);
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$mimeTypeId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeMimeTypeOrderBy<Input$AssetTypeMimeTypeOrderBy>
      get copyWith => CopyWith$Input$AssetTypeMimeTypeOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeMimeTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$assetTypeId = assetTypeId;
    final l$mimeTypeId = mimeTypeId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeMimeTypeOrderBy<TRes> {
  factory CopyWith$Input$AssetTypeMimeTypeOrderBy(
    Input$AssetTypeMimeTypeOrderBy instance,
    TRes Function(Input$AssetTypeMimeTypeOrderBy) then,
  ) = _CopyWithImpl$Input$AssetTypeMimeTypeOrderBy;

  factory CopyWith$Input$AssetTypeMimeTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeMimeTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeMimeTypeOrderBy<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeOrderBy<TRes> {
  _CopyWithImpl$Input$AssetTypeMimeTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$AssetTypeMimeTypeOrderBy _instance;

  final TRes Function(Input$AssetTypeMimeTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? assetTypeId = _undefined,
    Object? mimeTypeId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeMimeTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (assetTypeId != _undefined)
          'assetTypeId': (assetTypeId as Enum$OrderByDirection?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeMimeTypeOrderBy<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$AssetTypeMimeTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? assetTypeId,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeMimeTypeUpdateInput {
  factory Input$AssetTypeMimeTypeUpdateInput({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  }) =>
      Input$AssetTypeMimeTypeUpdateInput._({
        if (id != null) r'id': id,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeMimeTypeUpdateInput._(this._$data);

  factory Input$AssetTypeMimeTypeUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = (l$assetTypeId as String?);
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetTypeMimeTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get assetTypeId => (_$data['assetTypeId'] as String?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId;
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeMimeTypeUpdateInput<
          Input$AssetTypeMimeTypeUpdateInput>
      get copyWith => CopyWith$Input$AssetTypeMimeTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeMimeTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$assetTypeId = assetTypeId;
    final l$mimeTypeId = mimeTypeId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeMimeTypeUpdateInput<TRes> {
  factory CopyWith$Input$AssetTypeMimeTypeUpdateInput(
    Input$AssetTypeMimeTypeUpdateInput instance,
    TRes Function(Input$AssetTypeMimeTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$AssetTypeMimeTypeUpdateInput;

  factory CopyWith$Input$AssetTypeMimeTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeMimeTypeUpdateInput;

  TRes call({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeMimeTypeUpdateInput<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$AssetTypeMimeTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AssetTypeMimeTypeUpdateInput _instance;

  final TRes Function(Input$AssetTypeMimeTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? assetTypeId = _undefined,
    Object? mimeTypeId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeMimeTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (assetTypeId != _undefined) 'assetTypeId': (assetTypeId as String?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeMimeTypeUpdateInput<TRes>
    implements CopyWith$Input$AssetTypeMimeTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AssetTypeMimeTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? assetTypeId,
    String? mimeTypeId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeOrderBy {
  factory Input$AssetTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$AssetTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeOrderBy._(this._$data);

  factory Input$AssetTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$AssetTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeOrderBy<Input$AssetTypeOrderBy> get copyWith =>
      CopyWith$Input$AssetTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeOrderBy<TRes> {
  factory CopyWith$Input$AssetTypeOrderBy(
    Input$AssetTypeOrderBy instance,
    TRes Function(Input$AssetTypeOrderBy) then,
  ) = _CopyWithImpl$Input$AssetTypeOrderBy;

  factory CopyWith$Input$AssetTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeOrderBy<TRes>
    implements CopyWith$Input$AssetTypeOrderBy<TRes> {
  _CopyWithImpl$Input$AssetTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$AssetTypeOrderBy _instance;

  final TRes Function(Input$AssetTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeOrderBy<TRes>
    implements CopyWith$Input$AssetTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$AssetTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$AssetTypeUpdateInput {
  factory Input$AssetTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$AssetTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$AssetTypeUpdateInput._(this._$data);

  factory Input$AssetTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$AssetTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$AssetTypeUpdateInput<Input$AssetTypeUpdateInput>
      get copyWith => CopyWith$Input$AssetTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetTypeUpdateInput<TRes> {
  factory CopyWith$Input$AssetTypeUpdateInput(
    Input$AssetTypeUpdateInput instance,
    TRes Function(Input$AssetTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$AssetTypeUpdateInput;

  factory CopyWith$Input$AssetTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$AssetTypeUpdateInput<TRes>
    implements CopyWith$Input$AssetTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$AssetTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AssetTypeUpdateInput _instance;

  final TRes Function(Input$AssetTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$AssetTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$AssetTypeUpdateInput<TRes>
    implements CopyWith$Input$AssetTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AssetTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$AssetUpdateInput {
  factory Input$AssetUpdateInput({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  }) =>
      Input$AssetUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (fileName != null) r'fileName': fileName,
        if (description != null) r'description': description,
        if (fileSize != null) r'fileSize': fileSize,
        if (data != null) r'data': data,
        if (hash != null) r'hash': hash,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (assetTypeId != null) r'assetTypeId': assetTypeId,
        if (ownerId != null) r'ownerId': ownerId,
        if (isApproved != null) r'isApproved': isApproved,
        if (isPublished != null) r'isPublished': isPublished,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (statusId != null) r'statusId': statusId,
        if (promptId != null) r'promptId': promptId,
        if (creationTypeId != null) r'creationTypeId': creationTypeId,
      });

  Input$AssetUpdateInput._(this._$data);

  factory Input$AssetUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = (l$fileName as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('fileSize')) {
      final l$fileSize = data['fileSize'];
      result$data['fileSize'] = (l$fileSize as num?)?.toDouble();
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = (l$hash as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('assetTypeId')) {
      final l$assetTypeId = data['assetTypeId'];
      result$data['assetTypeId'] = (l$assetTypeId as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = (l$isApproved as bool?);
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : DateTime.parse((l$approvedAt as String));
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = l$publishedAt == null
          ? null
          : DateTime.parse((l$publishedAt as String));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = (l$publicationUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : DateTime.parse((l$archivedAt as String));
    }
    if (data.containsKey('statusId')) {
      final l$statusId = data['statusId'];
      result$data['statusId'] = (l$statusId as String?);
    }
    if (data.containsKey('promptId')) {
      final l$promptId = data['promptId'];
      result$data['promptId'] = (l$promptId as String?);
    }
    if (data.containsKey('creationTypeId')) {
      final l$creationTypeId = data['creationTypeId'];
      result$data['creationTypeId'] = (l$creationTypeId as String?);
    }
    return Input$AssetUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get fileName => (_$data['fileName'] as String?);

  String? get description => (_$data['description'] as String?);

  double? get fileSize => (_$data['fileSize'] as double?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get hash => (_$data['hash'] as String?);

  String? get url => (_$data['url'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  String? get assetTypeId => (_$data['assetTypeId'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  bool? get isApproved => (_$data['isApproved'] as bool?);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  DateTime? get approvedAt => (_$data['approvedAt'] as DateTime?);

  DateTime? get publishedAt => (_$data['publishedAt'] as DateTime?);

  String? get publicationUrl => (_$data['publicationUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  bool? get isArchived => (_$data['isArchived'] as bool?);

  DateTime? get archivedAt => (_$data['archivedAt'] as DateTime?);

  String? get statusId => (_$data['statusId'] as String?);

  String? get promptId => (_$data['promptId'] as String?);

  String? get creationTypeId => (_$data['creationTypeId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('fileSize')) {
      final l$fileSize = fileSize;
      result$data['fileSize'] = l$fileSize;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('assetTypeId')) {
      final l$assetTypeId = assetTypeId;
      result$data['assetTypeId'] = l$assetTypeId;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved;
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toIso8601String();
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt?.toIso8601String();
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toIso8601String();
    }
    if (_$data.containsKey('statusId')) {
      final l$statusId = statusId;
      result$data['statusId'] = l$statusId;
    }
    if (_$data.containsKey('promptId')) {
      final l$promptId = promptId;
      result$data['promptId'] = l$promptId;
    }
    if (_$data.containsKey('creationTypeId')) {
      final l$creationTypeId = creationTypeId;
      result$data['creationTypeId'] = l$creationTypeId;
    }
    return result$data;
  }

  CopyWith$Input$AssetUpdateInput<Input$AssetUpdateInput> get copyWith =>
      CopyWith$Input$AssetUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AssetUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$fileSize = fileSize;
    final lOther$fileSize = other.fileSize;
    if (_$data.containsKey('fileSize') !=
        other._$data.containsKey('fileSize')) {
      return false;
    }
    if (l$fileSize != lOther$fileSize) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$assetTypeId = assetTypeId;
    final lOther$assetTypeId = other.assetTypeId;
    if (_$data.containsKey('assetTypeId') !=
        other._$data.containsKey('assetTypeId')) {
      return false;
    }
    if (l$assetTypeId != lOther$assetTypeId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$statusId = statusId;
    final lOther$statusId = other.statusId;
    if (_$data.containsKey('statusId') !=
        other._$data.containsKey('statusId')) {
      return false;
    }
    if (l$statusId != lOther$statusId) {
      return false;
    }
    final l$promptId = promptId;
    final lOther$promptId = other.promptId;
    if (_$data.containsKey('promptId') !=
        other._$data.containsKey('promptId')) {
      return false;
    }
    if (l$promptId != lOther$promptId) {
      return false;
    }
    final l$creationTypeId = creationTypeId;
    final lOther$creationTypeId = other.creationTypeId;
    if (_$data.containsKey('creationTypeId') !=
        other._$data.containsKey('creationTypeId')) {
      return false;
    }
    if (l$creationTypeId != lOther$creationTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$fileName = fileName;
    final l$description = description;
    final l$fileSize = fileSize;
    final l$data = data;
    final l$hash = hash;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$mimeTypeId = mimeTypeId;
    final l$assetTypeId = assetTypeId;
    final l$ownerId = ownerId;
    final l$isApproved = isApproved;
    final l$isPublished = isPublished;
    final l$approvedAt = approvedAt;
    final l$publishedAt = publishedAt;
    final l$publicationUrl = publicationUrl;
    final l$coverUrl = coverUrl;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$statusId = statusId;
    final l$promptId = promptId;
    final l$creationTypeId = creationTypeId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('fileSize') ? l$fileSize : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('assetTypeId') ? l$assetTypeId : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('statusId') ? l$statusId : const {},
      _$data.containsKey('promptId') ? l$promptId : const {},
      _$data.containsKey('creationTypeId') ? l$creationTypeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AssetUpdateInput<TRes> {
  factory CopyWith$Input$AssetUpdateInput(
    Input$AssetUpdateInput instance,
    TRes Function(Input$AssetUpdateInput) then,
  ) = _CopyWithImpl$Input$AssetUpdateInput;

  factory CopyWith$Input$AssetUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AssetUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  });
}

class _CopyWithImpl$Input$AssetUpdateInput<TRes>
    implements CopyWith$Input$AssetUpdateInput<TRes> {
  _CopyWithImpl$Input$AssetUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AssetUpdateInput _instance;

  final TRes Function(Input$AssetUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? fileName = _undefined,
    Object? description = _undefined,
    Object? fileSize = _undefined,
    Object? data = _undefined,
    Object? hash = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? mimeTypeId = _undefined,
    Object? assetTypeId = _undefined,
    Object? ownerId = _undefined,
    Object? isApproved = _undefined,
    Object? isPublished = _undefined,
    Object? approvedAt = _undefined,
    Object? publishedAt = _undefined,
    Object? publicationUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? statusId = _undefined,
    Object? promptId = _undefined,
    Object? creationTypeId = _undefined,
  }) =>
      _then(Input$AssetUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (fileName != _undefined) 'fileName': (fileName as String?),
        if (description != _undefined) 'description': (description as String?),
        if (fileSize != _undefined) 'fileSize': (fileSize as double?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (hash != _undefined) 'hash': (hash as String?),
        if (url != _undefined) 'url': (url as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (assetTypeId != _undefined) 'assetTypeId': (assetTypeId as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (isApproved != _undefined) 'isApproved': (isApproved as bool?),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (approvedAt != _undefined) 'approvedAt': (approvedAt as DateTime?),
        if (publishedAt != _undefined)
          'publishedAt': (publishedAt as DateTime?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (archivedAt != _undefined) 'archivedAt': (archivedAt as DateTime?),
        if (statusId != _undefined) 'statusId': (statusId as String?),
        if (promptId != _undefined) 'promptId': (promptId as String?),
        if (creationTypeId != _undefined)
          'creationTypeId': (creationTypeId as String?),
      }));
}

class _CopyWithStubImpl$Input$AssetUpdateInput<TRes>
    implements CopyWith$Input$AssetUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AssetUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? fileName,
    String? description,
    double? fileSize,
    Map<String, dynamic>? data,
    String? hash,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? mimeTypeId,
    String? assetTypeId,
    String? ownerId,
    bool? isApproved,
    bool? isPublished,
    DateTime? approvedAt,
    DateTime? publishedAt,
    String? publicationUrl,
    String? coverUrl,
    bool? isArchived,
    DateTime? archivedAt,
    String? statusId,
    String? promptId,
    String? creationTypeId,
  }) =>
      _res;
}

class Input$BigFloatFilter {
  factory Input$BigFloatFilter({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  }) =>
      Input$BigFloatFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$BigFloatFilter._(this._$data);

  factory Input$BigFloatFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as num?)?.toDouble();
    }
    return Input$BigFloatFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get eq => (_$data['eq'] as double?);

  double? get gt => (_$data['gt'] as double?);

  double? get gte => (_$data['gte'] as double?);

  List<double>? get $in => (_$data['in'] as List<double>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  double? get lt => (_$data['lt'] as double?);

  double? get lte => (_$data['lte'] as double?);

  double? get neq => (_$data['neq'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$BigFloatFilter<Input$BigFloatFilter> get copyWith =>
      CopyWith$Input$BigFloatFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BigFloatFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$BigFloatFilter<TRes> {
  factory CopyWith$Input$BigFloatFilter(
    Input$BigFloatFilter instance,
    TRes Function(Input$BigFloatFilter) then,
  ) = _CopyWithImpl$Input$BigFloatFilter;

  factory CopyWith$Input$BigFloatFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BigFloatFilter;

  TRes call({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  });
}

class _CopyWithImpl$Input$BigFloatFilter<TRes>
    implements CopyWith$Input$BigFloatFilter<TRes> {
  _CopyWithImpl$Input$BigFloatFilter(
    this._instance,
    this._then,
  );

  final Input$BigFloatFilter _instance;

  final TRes Function(Input$BigFloatFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$BigFloatFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (neq != _undefined) 'neq': (neq as double?),
      }));
}

class _CopyWithStubImpl$Input$BigFloatFilter<TRes>
    implements CopyWith$Input$BigFloatFilter<TRes> {
  _CopyWithStubImpl$Input$BigFloatFilter(this._res);

  TRes _res;

  call({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  }) =>
      _res;
}

class Input$BigIntFilter {
  factory Input$BigIntFilter({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  }) =>
      Input$BigIntFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$BigIntFilter._(this._$data);

  factory Input$BigIntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    return Input$BigIntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  int? get neq => (_$data['neq'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$BigIntFilter<Input$BigIntFilter> get copyWith =>
      CopyWith$Input$BigIntFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BigIntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$BigIntFilter<TRes> {
  factory CopyWith$Input$BigIntFilter(
    Input$BigIntFilter instance,
    TRes Function(Input$BigIntFilter) then,
  ) = _CopyWithImpl$Input$BigIntFilter;

  factory CopyWith$Input$BigIntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BigIntFilter;

  TRes call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  });
}

class _CopyWithImpl$Input$BigIntFilter<TRes>
    implements CopyWith$Input$BigIntFilter<TRes> {
  _CopyWithImpl$Input$BigIntFilter(
    this._instance,
    this._then,
  );

  final Input$BigIntFilter _instance;

  final TRes Function(Input$BigIntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$BigIntFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (neq != _undefined) 'neq': (neq as int?),
      }));
}

class _CopyWithStubImpl$Input$BigIntFilter<TRes>
    implements CopyWith$Input$BigIntFilter<TRes> {
  _CopyWithStubImpl$Input$BigIntFilter(this._res);

  TRes _res;

  call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  }) =>
      _res;
}

class Input$BooleanFilter {
  factory Input$BooleanFilter({
    bool? eq,
    Enum$FilterIs? $is,
  }) =>
      Input$BooleanFilter._({
        if (eq != null) r'eq': eq,
        if ($is != null) r'is': $is,
      });

  Input$BooleanFilter._(this._$data);

  factory Input$BooleanFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as bool?);
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    return Input$BooleanFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get eq => (_$data['eq'] as bool?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    return result$data;
  }

  CopyWith$Input$BooleanFilter<Input$BooleanFilter> get copyWith =>
      CopyWith$Input$BooleanFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BooleanFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$is = $is;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('is') ? l$$is : const {},
    ]);
  }
}

abstract class CopyWith$Input$BooleanFilter<TRes> {
  factory CopyWith$Input$BooleanFilter(
    Input$BooleanFilter instance,
    TRes Function(Input$BooleanFilter) then,
  ) = _CopyWithImpl$Input$BooleanFilter;

  factory CopyWith$Input$BooleanFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BooleanFilter;

  TRes call({
    bool? eq,
    Enum$FilterIs? $is,
  });
}

class _CopyWithImpl$Input$BooleanFilter<TRes>
    implements CopyWith$Input$BooleanFilter<TRes> {
  _CopyWithImpl$Input$BooleanFilter(
    this._instance,
    this._then,
  );

  final Input$BooleanFilter _instance;

  final TRes Function(Input$BooleanFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? $is = _undefined,
  }) =>
      _then(Input$BooleanFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as bool?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
      }));
}

class _CopyWithStubImpl$Input$BooleanFilter<TRes>
    implements CopyWith$Input$BooleanFilter<TRes> {
  _CopyWithStubImpl$Input$BooleanFilter(this._res);

  TRes _res;

  call({
    bool? eq,
    Enum$FilterIs? $is,
  }) =>
      _res;
}

class Input$ChatMessageFilter {
  factory Input$ChatMessageFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? content,
    Input$UUIDFilter? roleId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? chatSessionId,
    Input$BigIntFilter? index,
    Input$UUIDFilter? previousMessageId,
    Input$IDFilter? nodeId,
    List<Input$ChatMessageFilter>? and,
    List<Input$ChatMessageFilter>? or,
    Input$ChatMessageFilter? not,
  }) =>
      Input$ChatMessageFilter._({
        if (id != null) r'id': id,
        if (content != null) r'content': content,
        if (roleId != null) r'roleId': roleId,
        if (createdAt != null) r'createdAt': createdAt,
        if (chatSessionId != null) r'chatSessionId': chatSessionId,
        if (index != null) r'index': index,
        if (previousMessageId != null) r'previousMessageId': previousMessageId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ChatMessageFilter._(this._$data);

  factory Input$ChatMessageFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringFilter.fromJson((l$content as Map<String, dynamic>));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : Input$UUIDFilter.fromJson((l$roleId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('chatSessionId')) {
      final l$chatSessionId = data['chatSessionId'];
      result$data['chatSessionId'] = l$chatSessionId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$chatSessionId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$BigIntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('previousMessageId')) {
      final l$previousMessageId = data['previousMessageId'];
      result$data['previousMessageId'] = l$previousMessageId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$previousMessageId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ChatMessageFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ChatMessageFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ChatMessageFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ChatMessageFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get content => (_$data['content'] as Input$StringFilter?);

  Input$UUIDFilter? get roleId => (_$data['roleId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get chatSessionId =>
      (_$data['chatSessionId'] as Input$UUIDFilter?);

  Input$BigIntFilter? get index => (_$data['index'] as Input$BigIntFilter?);

  Input$UUIDFilter? get previousMessageId =>
      (_$data['previousMessageId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ChatMessageFilter>? get and =>
      (_$data['and'] as List<Input$ChatMessageFilter>?);

  List<Input$ChatMessageFilter>? get or =>
      (_$data['or'] as List<Input$ChatMessageFilter>?);

  Input$ChatMessageFilter? get not =>
      (_$data['not'] as Input$ChatMessageFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('chatSessionId')) {
      final l$chatSessionId = chatSessionId;
      result$data['chatSessionId'] = l$chatSessionId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('previousMessageId')) {
      final l$previousMessageId = previousMessageId;
      result$data['previousMessageId'] = l$previousMessageId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChatMessageFilter<Input$ChatMessageFilter> get copyWith =>
      CopyWith$Input$ChatMessageFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatMessageFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (_$data.containsKey('chatSessionId') !=
        other._$data.containsKey('chatSessionId')) {
      return false;
    }
    if (l$chatSessionId != lOther$chatSessionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$previousMessageId = previousMessageId;
    final lOther$previousMessageId = other.previousMessageId;
    if (_$data.containsKey('previousMessageId') !=
        other._$data.containsKey('previousMessageId')) {
      return false;
    }
    if (l$previousMessageId != lOther$previousMessageId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$content = content;
    final l$roleId = roleId;
    final l$createdAt = createdAt;
    final l$chatSessionId = chatSessionId;
    final l$index = index;
    final l$previousMessageId = previousMessageId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('chatSessionId') ? l$chatSessionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('previousMessageId') ? l$previousMessageId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatMessageFilter<TRes> {
  factory CopyWith$Input$ChatMessageFilter(
    Input$ChatMessageFilter instance,
    TRes Function(Input$ChatMessageFilter) then,
  ) = _CopyWithImpl$Input$ChatMessageFilter;

  factory CopyWith$Input$ChatMessageFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatMessageFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? content,
    Input$UUIDFilter? roleId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? chatSessionId,
    Input$BigIntFilter? index,
    Input$UUIDFilter? previousMessageId,
    Input$IDFilter? nodeId,
    List<Input$ChatMessageFilter>? and,
    List<Input$ChatMessageFilter>? or,
    Input$ChatMessageFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get content;
  CopyWith$Input$UUIDFilter<TRes> get roleId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get chatSessionId;
  CopyWith$Input$BigIntFilter<TRes> get index;
  CopyWith$Input$UUIDFilter<TRes> get previousMessageId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ChatMessageFilter>? Function(
              Iterable<
                  CopyWith$Input$ChatMessageFilter<Input$ChatMessageFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ChatMessageFilter>? Function(
              Iterable<
                  CopyWith$Input$ChatMessageFilter<Input$ChatMessageFilter>>?)
          _fn);
  CopyWith$Input$ChatMessageFilter<TRes> get not;
}

class _CopyWithImpl$Input$ChatMessageFilter<TRes>
    implements CopyWith$Input$ChatMessageFilter<TRes> {
  _CopyWithImpl$Input$ChatMessageFilter(
    this._instance,
    this._then,
  );

  final Input$ChatMessageFilter _instance;

  final TRes Function(Input$ChatMessageFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? content = _undefined,
    Object? roleId = _undefined,
    Object? createdAt = _undefined,
    Object? chatSessionId = _undefined,
    Object? index = _undefined,
    Object? previousMessageId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ChatMessageFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (content != _undefined) 'content': (content as Input$StringFilter?),
        if (roleId != _undefined) 'roleId': (roleId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (chatSessionId != _undefined)
          'chatSessionId': (chatSessionId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$BigIntFilter?),
        if (previousMessageId != _undefined)
          'previousMessageId': (previousMessageId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ChatMessageFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ChatMessageFilter>?),
        if (not != _undefined) 'not': (not as Input$ChatMessageFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$content, (e) => call(content: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get roleId {
    final local$roleId = _instance.roleId;
    return local$roleId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$roleId, (e) => call(roleId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get chatSessionId {
    final local$chatSessionId = _instance.chatSessionId;
    return local$chatSessionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$chatSessionId, (e) => call(chatSessionId: e));
  }

  CopyWith$Input$BigIntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$BigIntFilter.stub(_then(_instance))
        : CopyWith$Input$BigIntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get previousMessageId {
    final local$previousMessageId = _instance.previousMessageId;
    return local$previousMessageId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$previousMessageId, (e) => call(previousMessageId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ChatMessageFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatMessageFilter<
                          Input$ChatMessageFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ChatMessageFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ChatMessageFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatMessageFilter<
                          Input$ChatMessageFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ChatMessageFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ChatMessageFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ChatMessageFilter.stub(_then(_instance))
        : CopyWith$Input$ChatMessageFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ChatMessageFilter<TRes>
    implements CopyWith$Input$ChatMessageFilter<TRes> {
  _CopyWithStubImpl$Input$ChatMessageFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? content,
    Input$UUIDFilter? roleId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? chatSessionId,
    Input$BigIntFilter? index,
    Input$UUIDFilter? previousMessageId,
    Input$IDFilter? nodeId,
    List<Input$ChatMessageFilter>? and,
    List<Input$ChatMessageFilter>? or,
    Input$ChatMessageFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get content =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get roleId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get chatSessionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BigIntFilter<TRes> get index =>
      CopyWith$Input$BigIntFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get previousMessageId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ChatMessageFilter<TRes> get not =>
      CopyWith$Input$ChatMessageFilter.stub(_res);
}

class Input$ChatMessageInsertInput {
  factory Input$ChatMessageInsertInput({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  }) =>
      Input$ChatMessageInsertInput._({
        if (id != null) r'id': id,
        if (content != null) r'content': content,
        if (roleId != null) r'roleId': roleId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (chatSessionId != null) r'chatSessionId': chatSessionId,
        if (index != null) r'index': index,
        if (previousMessageId != null) r'previousMessageId': previousMessageId,
      });

  Input$ChatMessageInsertInput._(this._$data);

  factory Input$ChatMessageInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('chatSessionId')) {
      final l$chatSessionId = data['chatSessionId'];
      result$data['chatSessionId'] = (l$chatSessionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('previousMessageId')) {
      final l$previousMessageId = data['previousMessageId'];
      result$data['previousMessageId'] = (l$previousMessageId as String?);
    }
    return Input$ChatMessageInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get chatSessionId => (_$data['chatSessionId'] as String?);

  int? get index => (_$data['index'] as int?);

  String? get previousMessageId => (_$data['previousMessageId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('chatSessionId')) {
      final l$chatSessionId = chatSessionId;
      result$data['chatSessionId'] = l$chatSessionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('previousMessageId')) {
      final l$previousMessageId = previousMessageId;
      result$data['previousMessageId'] = l$previousMessageId;
    }
    return result$data;
  }

  CopyWith$Input$ChatMessageInsertInput<Input$ChatMessageInsertInput>
      get copyWith => CopyWith$Input$ChatMessageInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatMessageInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (_$data.containsKey('chatSessionId') !=
        other._$data.containsKey('chatSessionId')) {
      return false;
    }
    if (l$chatSessionId != lOther$chatSessionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$previousMessageId = previousMessageId;
    final lOther$previousMessageId = other.previousMessageId;
    if (_$data.containsKey('previousMessageId') !=
        other._$data.containsKey('previousMessageId')) {
      return false;
    }
    if (l$previousMessageId != lOther$previousMessageId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$content = content;
    final l$roleId = roleId;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$chatSessionId = chatSessionId;
    final l$index = index;
    final l$previousMessageId = previousMessageId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('chatSessionId') ? l$chatSessionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('previousMessageId') ? l$previousMessageId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatMessageInsertInput<TRes> {
  factory CopyWith$Input$ChatMessageInsertInput(
    Input$ChatMessageInsertInput instance,
    TRes Function(Input$ChatMessageInsertInput) then,
  ) = _CopyWithImpl$Input$ChatMessageInsertInput;

  factory CopyWith$Input$ChatMessageInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatMessageInsertInput;

  TRes call({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  });
}

class _CopyWithImpl$Input$ChatMessageInsertInput<TRes>
    implements CopyWith$Input$ChatMessageInsertInput<TRes> {
  _CopyWithImpl$Input$ChatMessageInsertInput(
    this._instance,
    this._then,
  );

  final Input$ChatMessageInsertInput _instance;

  final TRes Function(Input$ChatMessageInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? content = _undefined,
    Object? roleId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? chatSessionId = _undefined,
    Object? index = _undefined,
    Object? previousMessageId = _undefined,
  }) =>
      _then(Input$ChatMessageInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (content != _undefined) 'content': (content as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (chatSessionId != _undefined)
          'chatSessionId': (chatSessionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (previousMessageId != _undefined)
          'previousMessageId': (previousMessageId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChatMessageInsertInput<TRes>
    implements CopyWith$Input$ChatMessageInsertInput<TRes> {
  _CopyWithStubImpl$Input$ChatMessageInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  }) =>
      _res;
}

class Input$ChatMessageOrderBy {
  factory Input$ChatMessageOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? chatSessionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? previousMessageId,
  }) =>
      Input$ChatMessageOrderBy._({
        if (id != null) r'id': id,
        if (content != null) r'content': content,
        if (roleId != null) r'roleId': roleId,
        if (createdAt != null) r'createdAt': createdAt,
        if (chatSessionId != null) r'chatSessionId': chatSessionId,
        if (index != null) r'index': index,
        if (previousMessageId != null) r'previousMessageId': previousMessageId,
      });

  Input$ChatMessageOrderBy._(this._$data);

  factory Input$ChatMessageOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$OrderByDirection((l$content as String));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$roleId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('chatSessionId')) {
      final l$chatSessionId = data['chatSessionId'];
      result$data['chatSessionId'] = l$chatSessionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$chatSessionId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('previousMessageId')) {
      final l$previousMessageId = data['previousMessageId'];
      result$data['previousMessageId'] = l$previousMessageId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$previousMessageId as String));
    }
    return Input$ChatMessageOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get content =>
      (_$data['content'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get roleId =>
      (_$data['roleId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get chatSessionId =>
      (_$data['chatSessionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get previousMessageId =>
      (_$data['previousMessageId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$OrderByDirection(l$content);
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] =
          l$roleId == null ? null : toJson$Enum$OrderByDirection(l$roleId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('chatSessionId')) {
      final l$chatSessionId = chatSessionId;
      result$data['chatSessionId'] = l$chatSessionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$chatSessionId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('previousMessageId')) {
      final l$previousMessageId = previousMessageId;
      result$data['previousMessageId'] = l$previousMessageId == null
          ? null
          : toJson$Enum$OrderByDirection(l$previousMessageId);
    }
    return result$data;
  }

  CopyWith$Input$ChatMessageOrderBy<Input$ChatMessageOrderBy> get copyWith =>
      CopyWith$Input$ChatMessageOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatMessageOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (_$data.containsKey('chatSessionId') !=
        other._$data.containsKey('chatSessionId')) {
      return false;
    }
    if (l$chatSessionId != lOther$chatSessionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$previousMessageId = previousMessageId;
    final lOther$previousMessageId = other.previousMessageId;
    if (_$data.containsKey('previousMessageId') !=
        other._$data.containsKey('previousMessageId')) {
      return false;
    }
    if (l$previousMessageId != lOther$previousMessageId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$content = content;
    final l$roleId = roleId;
    final l$createdAt = createdAt;
    final l$chatSessionId = chatSessionId;
    final l$index = index;
    final l$previousMessageId = previousMessageId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('chatSessionId') ? l$chatSessionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('previousMessageId') ? l$previousMessageId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatMessageOrderBy<TRes> {
  factory CopyWith$Input$ChatMessageOrderBy(
    Input$ChatMessageOrderBy instance,
    TRes Function(Input$ChatMessageOrderBy) then,
  ) = _CopyWithImpl$Input$ChatMessageOrderBy;

  factory CopyWith$Input$ChatMessageOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatMessageOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? chatSessionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? previousMessageId,
  });
}

class _CopyWithImpl$Input$ChatMessageOrderBy<TRes>
    implements CopyWith$Input$ChatMessageOrderBy<TRes> {
  _CopyWithImpl$Input$ChatMessageOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChatMessageOrderBy _instance;

  final TRes Function(Input$ChatMessageOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? content = _undefined,
    Object? roleId = _undefined,
    Object? createdAt = _undefined,
    Object? chatSessionId = _undefined,
    Object? index = _undefined,
    Object? previousMessageId = _undefined,
  }) =>
      _then(Input$ChatMessageOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (content != _undefined)
          'content': (content as Enum$OrderByDirection?),
        if (roleId != _undefined) 'roleId': (roleId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (chatSessionId != _undefined)
          'chatSessionId': (chatSessionId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (previousMessageId != _undefined)
          'previousMessageId': (previousMessageId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ChatMessageOrderBy<TRes>
    implements CopyWith$Input$ChatMessageOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChatMessageOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? chatSessionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? previousMessageId,
  }) =>
      _res;
}

class Input$ChatMessageUpdateInput {
  factory Input$ChatMessageUpdateInput({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  }) =>
      Input$ChatMessageUpdateInput._({
        if (id != null) r'id': id,
        if (content != null) r'content': content,
        if (roleId != null) r'roleId': roleId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (chatSessionId != null) r'chatSessionId': chatSessionId,
        if (index != null) r'index': index,
        if (previousMessageId != null) r'previousMessageId': previousMessageId,
      });

  Input$ChatMessageUpdateInput._(this._$data);

  factory Input$ChatMessageUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('chatSessionId')) {
      final l$chatSessionId = data['chatSessionId'];
      result$data['chatSessionId'] = (l$chatSessionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('previousMessageId')) {
      final l$previousMessageId = data['previousMessageId'];
      result$data['previousMessageId'] = (l$previousMessageId as String?);
    }
    return Input$ChatMessageUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get chatSessionId => (_$data['chatSessionId'] as String?);

  int? get index => (_$data['index'] as int?);

  String? get previousMessageId => (_$data['previousMessageId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('chatSessionId')) {
      final l$chatSessionId = chatSessionId;
      result$data['chatSessionId'] = l$chatSessionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('previousMessageId')) {
      final l$previousMessageId = previousMessageId;
      result$data['previousMessageId'] = l$previousMessageId;
    }
    return result$data;
  }

  CopyWith$Input$ChatMessageUpdateInput<Input$ChatMessageUpdateInput>
      get copyWith => CopyWith$Input$ChatMessageUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatMessageUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (_$data.containsKey('chatSessionId') !=
        other._$data.containsKey('chatSessionId')) {
      return false;
    }
    if (l$chatSessionId != lOther$chatSessionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$previousMessageId = previousMessageId;
    final lOther$previousMessageId = other.previousMessageId;
    if (_$data.containsKey('previousMessageId') !=
        other._$data.containsKey('previousMessageId')) {
      return false;
    }
    if (l$previousMessageId != lOther$previousMessageId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$content = content;
    final l$roleId = roleId;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$chatSessionId = chatSessionId;
    final l$index = index;
    final l$previousMessageId = previousMessageId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('chatSessionId') ? l$chatSessionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('previousMessageId') ? l$previousMessageId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatMessageUpdateInput<TRes> {
  factory CopyWith$Input$ChatMessageUpdateInput(
    Input$ChatMessageUpdateInput instance,
    TRes Function(Input$ChatMessageUpdateInput) then,
  ) = _CopyWithImpl$Input$ChatMessageUpdateInput;

  factory CopyWith$Input$ChatMessageUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatMessageUpdateInput;

  TRes call({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  });
}

class _CopyWithImpl$Input$ChatMessageUpdateInput<TRes>
    implements CopyWith$Input$ChatMessageUpdateInput<TRes> {
  _CopyWithImpl$Input$ChatMessageUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ChatMessageUpdateInput _instance;

  final TRes Function(Input$ChatMessageUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? content = _undefined,
    Object? roleId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? chatSessionId = _undefined,
    Object? index = _undefined,
    Object? previousMessageId = _undefined,
  }) =>
      _then(Input$ChatMessageUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (content != _undefined) 'content': (content as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (chatSessionId != _undefined)
          'chatSessionId': (chatSessionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (previousMessageId != _undefined)
          'previousMessageId': (previousMessageId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChatMessageUpdateInput<TRes>
    implements CopyWith$Input$ChatMessageUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ChatMessageUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? content,
    String? roleId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? chatSessionId,
    int? index,
    String? previousMessageId,
  }) =>
      _res;
}

class Input$ChatRoleFilter {
  factory Input$ChatRoleFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ChatRoleFilter>? and,
    List<Input$ChatRoleFilter>? or,
    Input$ChatRoleFilter? not,
  }) =>
      Input$ChatRoleFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ChatRoleFilter._(this._$data);

  factory Input$ChatRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$ChatRoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$ChatRoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ChatRoleFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ChatRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ChatRoleFilter>? get and =>
      (_$data['and'] as List<Input$ChatRoleFilter>?);

  List<Input$ChatRoleFilter>? get or =>
      (_$data['or'] as List<Input$ChatRoleFilter>?);

  Input$ChatRoleFilter? get not => (_$data['not'] as Input$ChatRoleFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChatRoleFilter<Input$ChatRoleFilter> get copyWith =>
      CopyWith$Input$ChatRoleFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatRoleFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatRoleFilter<TRes> {
  factory CopyWith$Input$ChatRoleFilter(
    Input$ChatRoleFilter instance,
    TRes Function(Input$ChatRoleFilter) then,
  ) = _CopyWithImpl$Input$ChatRoleFilter;

  factory CopyWith$Input$ChatRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatRoleFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ChatRoleFilter>? and,
    List<Input$ChatRoleFilter>? or,
    Input$ChatRoleFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ChatRoleFilter>? Function(
              Iterable<CopyWith$Input$ChatRoleFilter<Input$ChatRoleFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ChatRoleFilter>? Function(
              Iterable<CopyWith$Input$ChatRoleFilter<Input$ChatRoleFilter>>?)
          _fn);
  CopyWith$Input$ChatRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$ChatRoleFilter<TRes>
    implements CopyWith$Input$ChatRoleFilter<TRes> {
  _CopyWithImpl$Input$ChatRoleFilter(
    this._instance,
    this._then,
  );

  final Input$ChatRoleFilter _instance;

  final TRes Function(Input$ChatRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ChatRoleFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ChatRoleFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ChatRoleFilter>?),
        if (not != _undefined) 'not': (not as Input$ChatRoleFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ChatRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatRoleFilter<Input$ChatRoleFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ChatRoleFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ChatRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatRoleFilter<Input$ChatRoleFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ChatRoleFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ChatRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ChatRoleFilter.stub(_then(_instance))
        : CopyWith$Input$ChatRoleFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ChatRoleFilter<TRes>
    implements CopyWith$Input$ChatRoleFilter<TRes> {
  _CopyWithStubImpl$Input$ChatRoleFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ChatRoleFilter>? and,
    List<Input$ChatRoleFilter>? or,
    Input$ChatRoleFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ChatRoleFilter<TRes> get not =>
      CopyWith$Input$ChatRoleFilter.stub(_res);
}

class Input$ChatRoleInsertInput {
  factory Input$ChatRoleInsertInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$ChatRoleInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ChatRoleInsertInput._(this._$data);

  factory Input$ChatRoleInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ChatRoleInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ChatRoleInsertInput<Input$ChatRoleInsertInput> get copyWith =>
      CopyWith$Input$ChatRoleInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatRoleInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatRoleInsertInput<TRes> {
  factory CopyWith$Input$ChatRoleInsertInput(
    Input$ChatRoleInsertInput instance,
    TRes Function(Input$ChatRoleInsertInput) then,
  ) = _CopyWithImpl$Input$ChatRoleInsertInput;

  factory CopyWith$Input$ChatRoleInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatRoleInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ChatRoleInsertInput<TRes>
    implements CopyWith$Input$ChatRoleInsertInput<TRes> {
  _CopyWithImpl$Input$ChatRoleInsertInput(
    this._instance,
    this._then,
  );

  final Input$ChatRoleInsertInput _instance;

  final TRes Function(Input$ChatRoleInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ChatRoleInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ChatRoleInsertInput<TRes>
    implements CopyWith$Input$ChatRoleInsertInput<TRes> {
  _CopyWithStubImpl$Input$ChatRoleInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ChatRoleOrderBy {
  factory Input$ChatRoleOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ChatRoleOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ChatRoleOrderBy._(this._$data);

  factory Input$ChatRoleOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ChatRoleOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ChatRoleOrderBy<Input$ChatRoleOrderBy> get copyWith =>
      CopyWith$Input$ChatRoleOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatRoleOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatRoleOrderBy<TRes> {
  factory CopyWith$Input$ChatRoleOrderBy(
    Input$ChatRoleOrderBy instance,
    TRes Function(Input$ChatRoleOrderBy) then,
  ) = _CopyWithImpl$Input$ChatRoleOrderBy;

  factory CopyWith$Input$ChatRoleOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatRoleOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ChatRoleOrderBy<TRes>
    implements CopyWith$Input$ChatRoleOrderBy<TRes> {
  _CopyWithImpl$Input$ChatRoleOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChatRoleOrderBy _instance;

  final TRes Function(Input$ChatRoleOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ChatRoleOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ChatRoleOrderBy<TRes>
    implements CopyWith$Input$ChatRoleOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChatRoleOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ChatRoleUpdateInput {
  factory Input$ChatRoleUpdateInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$ChatRoleUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ChatRoleUpdateInput._(this._$data);

  factory Input$ChatRoleUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ChatRoleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ChatRoleUpdateInput<Input$ChatRoleUpdateInput> get copyWith =>
      CopyWith$Input$ChatRoleUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatRoleUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatRoleUpdateInput<TRes> {
  factory CopyWith$Input$ChatRoleUpdateInput(
    Input$ChatRoleUpdateInput instance,
    TRes Function(Input$ChatRoleUpdateInput) then,
  ) = _CopyWithImpl$Input$ChatRoleUpdateInput;

  factory CopyWith$Input$ChatRoleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatRoleUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ChatRoleUpdateInput<TRes>
    implements CopyWith$Input$ChatRoleUpdateInput<TRes> {
  _CopyWithImpl$Input$ChatRoleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ChatRoleUpdateInput _instance;

  final TRes Function(Input$ChatRoleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ChatRoleUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ChatRoleUpdateInput<TRes>
    implements CopyWith$Input$ChatRoleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ChatRoleUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ChatSessionFilter {
  factory Input$ChatSessionFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$DatetimeFilter? endedAt,
    Input$DatetimeFilter? lastActiveAt,
    Input$StringFilter? title,
    Input$StringFilter? notes,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$ChatSessionFilter>? and,
    List<Input$ChatSessionFilter>? or,
    Input$ChatSessionFilter? not,
  }) =>
      Input$ChatSessionFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (endedAt != null) r'endedAt': endedAt,
        if (lastActiveAt != null) r'lastActiveAt': lastActiveAt,
        if (title != null) r'title': title,
        if (notes != null) r'notes': notes,
        if (applicationId != null) r'applicationId': applicationId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ChatSessionFilter._(this._$data);

  factory Input$ChatSessionFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$startedAt as Map<String, dynamic>));
    }
    if (data.containsKey('endedAt')) {
      final l$endedAt = data['endedAt'];
      result$data['endedAt'] = l$endedAt == null
          ? null
          : Input$DatetimeFilter.fromJson((l$endedAt as Map<String, dynamic>));
    }
    if (data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = data['lastActiveAt'];
      result$data['lastActiveAt'] = l$lastActiveAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$lastActiveAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : Input$StringFilter.fromJson((l$notes as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ChatSessionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ChatSessionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ChatSessionFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ChatSessionFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get startedAt =>
      (_$data['startedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get endedAt =>
      (_$data['endedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get lastActiveAt =>
      (_$data['lastActiveAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get notes => (_$data['notes'] as Input$StringFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ChatSessionFilter>? get and =>
      (_$data['and'] as List<Input$ChatSessionFilter>?);

  List<Input$ChatSessionFilter>? get or =>
      (_$data['or'] as List<Input$ChatSessionFilter>?);

  Input$ChatSessionFilter? get not =>
      (_$data['not'] as Input$ChatSessionFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toJson();
    }
    if (_$data.containsKey('endedAt')) {
      final l$endedAt = endedAt;
      result$data['endedAt'] = l$endedAt?.toJson();
    }
    if (_$data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = lastActiveAt;
      result$data['lastActiveAt'] = l$lastActiveAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChatSessionFilter<Input$ChatSessionFilter> get copyWith =>
      CopyWith$Input$ChatSessionFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatSessionFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$endedAt = endedAt;
    final lOther$endedAt = other.endedAt;
    if (_$data.containsKey('endedAt') != other._$data.containsKey('endedAt')) {
      return false;
    }
    if (l$endedAt != lOther$endedAt) {
      return false;
    }
    final l$lastActiveAt = lastActiveAt;
    final lOther$lastActiveAt = other.lastActiveAt;
    if (_$data.containsKey('lastActiveAt') !=
        other._$data.containsKey('lastActiveAt')) {
      return false;
    }
    if (l$lastActiveAt != lOther$lastActiveAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$endedAt = endedAt;
    final l$lastActiveAt = lastActiveAt;
    final l$title = title;
    final l$notes = notes;
    final l$applicationId = applicationId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('endedAt') ? l$endedAt : const {},
      _$data.containsKey('lastActiveAt') ? l$lastActiveAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatSessionFilter<TRes> {
  factory CopyWith$Input$ChatSessionFilter(
    Input$ChatSessionFilter instance,
    TRes Function(Input$ChatSessionFilter) then,
  ) = _CopyWithImpl$Input$ChatSessionFilter;

  factory CopyWith$Input$ChatSessionFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatSessionFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$DatetimeFilter? endedAt,
    Input$DatetimeFilter? lastActiveAt,
    Input$StringFilter? title,
    Input$StringFilter? notes,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$ChatSessionFilter>? and,
    List<Input$ChatSessionFilter>? or,
    Input$ChatSessionFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get startedAt;
  CopyWith$Input$DatetimeFilter<TRes> get endedAt;
  CopyWith$Input$DatetimeFilter<TRes> get lastActiveAt;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get notes;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ChatSessionFilter>? Function(
              Iterable<
                  CopyWith$Input$ChatSessionFilter<Input$ChatSessionFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ChatSessionFilter>? Function(
              Iterable<
                  CopyWith$Input$ChatSessionFilter<Input$ChatSessionFilter>>?)
          _fn);
  CopyWith$Input$ChatSessionFilter<TRes> get not;
}

class _CopyWithImpl$Input$ChatSessionFilter<TRes>
    implements CopyWith$Input$ChatSessionFilter<TRes> {
  _CopyWithImpl$Input$ChatSessionFilter(
    this._instance,
    this._then,
  );

  final Input$ChatSessionFilter _instance;

  final TRes Function(Input$ChatSessionFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? endedAt = _undefined,
    Object? lastActiveAt = _undefined,
    Object? title = _undefined,
    Object? notes = _undefined,
    Object? applicationId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ChatSessionFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Input$DatetimeFilter?),
        if (endedAt != _undefined)
          'endedAt': (endedAt as Input$DatetimeFilter?),
        if (lastActiveAt != _undefined)
          'lastActiveAt': (lastActiveAt as Input$DatetimeFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (notes != _undefined) 'notes': (notes as Input$StringFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ChatSessionFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ChatSessionFilter>?),
        if (not != _undefined) 'not': (not as Input$ChatSessionFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get startedAt {
    final local$startedAt = _instance.startedAt;
    return local$startedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$startedAt, (e) => call(startedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get endedAt {
    final local$endedAt = _instance.endedAt;
    return local$endedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(local$endedAt, (e) => call(endedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get lastActiveAt {
    final local$lastActiveAt = _instance.lastActiveAt;
    return local$lastActiveAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$lastActiveAt, (e) => call(lastActiveAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get notes {
    final local$notes = _instance.notes;
    return local$notes == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$notes, (e) => call(notes: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ChatSessionFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatSessionFilter<
                          Input$ChatSessionFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ChatSessionFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ChatSessionFilter>? Function(
                  Iterable<
                      CopyWith$Input$ChatSessionFilter<
                          Input$ChatSessionFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ChatSessionFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ChatSessionFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ChatSessionFilter.stub(_then(_instance))
        : CopyWith$Input$ChatSessionFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ChatSessionFilter<TRes>
    implements CopyWith$Input$ChatSessionFilter<TRes> {
  _CopyWithStubImpl$Input$ChatSessionFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$DatetimeFilter? endedAt,
    Input$DatetimeFilter? lastActiveAt,
    Input$StringFilter? title,
    Input$StringFilter? notes,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$ChatSessionFilter>? and,
    List<Input$ChatSessionFilter>? or,
    Input$ChatSessionFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get startedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get endedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get lastActiveAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get notes =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ChatSessionFilter<TRes> get not =>
      CopyWith$Input$ChatSessionFilter.stub(_res);
}

class Input$ChatSessionInsertInput {
  factory Input$ChatSessionInsertInput({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  }) =>
      Input$ChatSessionInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (endedAt != null) r'endedAt': endedAt,
        if (lastActiveAt != null) r'lastActiveAt': lastActiveAt,
        if (data != null) r'data': data,
        if (title != null) r'title': title,
        if (notes != null) r'notes': notes,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$ChatSessionInsertInput._(this._$data);

  factory Input$ChatSessionInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('endedAt')) {
      final l$endedAt = data['endedAt'];
      result$data['endedAt'] =
          l$endedAt == null ? null : DateTime.parse((l$endedAt as String));
    }
    if (data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = data['lastActiveAt'];
      result$data['lastActiveAt'] = l$lastActiveAt == null
          ? null
          : DateTime.parse((l$lastActiveAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = (l$notes as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$ChatSessionInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  DateTime? get endedAt => (_$data['endedAt'] as DateTime?);

  DateTime? get lastActiveAt => (_$data['lastActiveAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get title => (_$data['title'] as String?);

  String? get notes => (_$data['notes'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('endedAt')) {
      final l$endedAt = endedAt;
      result$data['endedAt'] = l$endedAt?.toIso8601String();
    }
    if (_$data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = lastActiveAt;
      result$data['lastActiveAt'] = l$lastActiveAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$ChatSessionInsertInput<Input$ChatSessionInsertInput>
      get copyWith => CopyWith$Input$ChatSessionInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatSessionInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$endedAt = endedAt;
    final lOther$endedAt = other.endedAt;
    if (_$data.containsKey('endedAt') != other._$data.containsKey('endedAt')) {
      return false;
    }
    if (l$endedAt != lOther$endedAt) {
      return false;
    }
    final l$lastActiveAt = lastActiveAt;
    final lOther$lastActiveAt = other.lastActiveAt;
    if (_$data.containsKey('lastActiveAt') !=
        other._$data.containsKey('lastActiveAt')) {
      return false;
    }
    if (l$lastActiveAt != lOther$lastActiveAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$endedAt = endedAt;
    final l$lastActiveAt = lastActiveAt;
    final l$data = data;
    final l$title = title;
    final l$notes = notes;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('endedAt') ? l$endedAt : const {},
      _$data.containsKey('lastActiveAt') ? l$lastActiveAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatSessionInsertInput<TRes> {
  factory CopyWith$Input$ChatSessionInsertInput(
    Input$ChatSessionInsertInput instance,
    TRes Function(Input$ChatSessionInsertInput) then,
  ) = _CopyWithImpl$Input$ChatSessionInsertInput;

  factory CopyWith$Input$ChatSessionInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatSessionInsertInput;

  TRes call({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$ChatSessionInsertInput<TRes>
    implements CopyWith$Input$ChatSessionInsertInput<TRes> {
  _CopyWithImpl$Input$ChatSessionInsertInput(
    this._instance,
    this._then,
  );

  final Input$ChatSessionInsertInput _instance;

  final TRes Function(Input$ChatSessionInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? endedAt = _undefined,
    Object? lastActiveAt = _undefined,
    Object? data = _undefined,
    Object? title = _undefined,
    Object? notes = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$ChatSessionInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (endedAt != _undefined) 'endedAt': (endedAt as DateTime?),
        if (lastActiveAt != _undefined)
          'lastActiveAt': (lastActiveAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (title != _undefined) 'title': (title as String?),
        if (notes != _undefined) 'notes': (notes as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChatSessionInsertInput<TRes>
    implements CopyWith$Input$ChatSessionInsertInput<TRes> {
  _CopyWithStubImpl$Input$ChatSessionInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  }) =>
      _res;
}

class Input$ChatSessionOrderBy {
  factory Input$ChatSessionOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? endedAt,
    Enum$OrderByDirection? lastActiveAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? notes,
    Enum$OrderByDirection? applicationId,
  }) =>
      Input$ChatSessionOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (endedAt != null) r'endedAt': endedAt,
        if (lastActiveAt != null) r'lastActiveAt': lastActiveAt,
        if (title != null) r'title': title,
        if (notes != null) r'notes': notes,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$ChatSessionOrderBy._(this._$data);

  factory Input$ChatSessionOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$startedAt as String));
    }
    if (data.containsKey('endedAt')) {
      final l$endedAt = data['endedAt'];
      result$data['endedAt'] = l$endedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$endedAt as String));
    }
    if (data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = data['lastActiveAt'];
      result$data['lastActiveAt'] = l$lastActiveAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$lastActiveAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : fromJson$Enum$OrderByDirection((l$notes as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    return Input$ChatSessionOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get startedAt =>
      (_$data['startedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get endedAt =>
      (_$data['endedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get lastActiveAt =>
      (_$data['lastActiveAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get notes =>
      (_$data['notes'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$startedAt);
    }
    if (_$data.containsKey('endedAt')) {
      final l$endedAt = endedAt;
      result$data['endedAt'] =
          l$endedAt == null ? null : toJson$Enum$OrderByDirection(l$endedAt);
    }
    if (_$data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = lastActiveAt;
      result$data['lastActiveAt'] = l$lastActiveAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$lastActiveAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] =
          l$notes == null ? null : toJson$Enum$OrderByDirection(l$notes);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    return result$data;
  }

  CopyWith$Input$ChatSessionOrderBy<Input$ChatSessionOrderBy> get copyWith =>
      CopyWith$Input$ChatSessionOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatSessionOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$endedAt = endedAt;
    final lOther$endedAt = other.endedAt;
    if (_$data.containsKey('endedAt') != other._$data.containsKey('endedAt')) {
      return false;
    }
    if (l$endedAt != lOther$endedAt) {
      return false;
    }
    final l$lastActiveAt = lastActiveAt;
    final lOther$lastActiveAt = other.lastActiveAt;
    if (_$data.containsKey('lastActiveAt') !=
        other._$data.containsKey('lastActiveAt')) {
      return false;
    }
    if (l$lastActiveAt != lOther$lastActiveAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$endedAt = endedAt;
    final l$lastActiveAt = lastActiveAt;
    final l$title = title;
    final l$notes = notes;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('endedAt') ? l$endedAt : const {},
      _$data.containsKey('lastActiveAt') ? l$lastActiveAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatSessionOrderBy<TRes> {
  factory CopyWith$Input$ChatSessionOrderBy(
    Input$ChatSessionOrderBy instance,
    TRes Function(Input$ChatSessionOrderBy) then,
  ) = _CopyWithImpl$Input$ChatSessionOrderBy;

  factory CopyWith$Input$ChatSessionOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatSessionOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? endedAt,
    Enum$OrderByDirection? lastActiveAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? notes,
    Enum$OrderByDirection? applicationId,
  });
}

class _CopyWithImpl$Input$ChatSessionOrderBy<TRes>
    implements CopyWith$Input$ChatSessionOrderBy<TRes> {
  _CopyWithImpl$Input$ChatSessionOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChatSessionOrderBy _instance;

  final TRes Function(Input$ChatSessionOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? endedAt = _undefined,
    Object? lastActiveAt = _undefined,
    Object? title = _undefined,
    Object? notes = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$ChatSessionOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Enum$OrderByDirection?),
        if (endedAt != _undefined)
          'endedAt': (endedAt as Enum$OrderByDirection?),
        if (lastActiveAt != _undefined)
          'lastActiveAt': (lastActiveAt as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (notes != _undefined) 'notes': (notes as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ChatSessionOrderBy<TRes>
    implements CopyWith$Input$ChatSessionOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChatSessionOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? endedAt,
    Enum$OrderByDirection? lastActiveAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? notes,
    Enum$OrderByDirection? applicationId,
  }) =>
      _res;
}

class Input$ChatSessionUpdateInput {
  factory Input$ChatSessionUpdateInput({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  }) =>
      Input$ChatSessionUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (endedAt != null) r'endedAt': endedAt,
        if (lastActiveAt != null) r'lastActiveAt': lastActiveAt,
        if (data != null) r'data': data,
        if (title != null) r'title': title,
        if (notes != null) r'notes': notes,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$ChatSessionUpdateInput._(this._$data);

  factory Input$ChatSessionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('endedAt')) {
      final l$endedAt = data['endedAt'];
      result$data['endedAt'] =
          l$endedAt == null ? null : DateTime.parse((l$endedAt as String));
    }
    if (data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = data['lastActiveAt'];
      result$data['lastActiveAt'] = l$lastActiveAt == null
          ? null
          : DateTime.parse((l$lastActiveAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = (l$notes as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$ChatSessionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  DateTime? get endedAt => (_$data['endedAt'] as DateTime?);

  DateTime? get lastActiveAt => (_$data['lastActiveAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get title => (_$data['title'] as String?);

  String? get notes => (_$data['notes'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('endedAt')) {
      final l$endedAt = endedAt;
      result$data['endedAt'] = l$endedAt?.toIso8601String();
    }
    if (_$data.containsKey('lastActiveAt')) {
      final l$lastActiveAt = lastActiveAt;
      result$data['lastActiveAt'] = l$lastActiveAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$ChatSessionUpdateInput<Input$ChatSessionUpdateInput>
      get copyWith => CopyWith$Input$ChatSessionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChatSessionUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$endedAt = endedAt;
    final lOther$endedAt = other.endedAt;
    if (_$data.containsKey('endedAt') != other._$data.containsKey('endedAt')) {
      return false;
    }
    if (l$endedAt != lOther$endedAt) {
      return false;
    }
    final l$lastActiveAt = lastActiveAt;
    final lOther$lastActiveAt = other.lastActiveAt;
    if (_$data.containsKey('lastActiveAt') !=
        other._$data.containsKey('lastActiveAt')) {
      return false;
    }
    if (l$lastActiveAt != lOther$lastActiveAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$endedAt = endedAt;
    final l$lastActiveAt = lastActiveAt;
    final l$data = data;
    final l$title = title;
    final l$notes = notes;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('endedAt') ? l$endedAt : const {},
      _$data.containsKey('lastActiveAt') ? l$lastActiveAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChatSessionUpdateInput<TRes> {
  factory CopyWith$Input$ChatSessionUpdateInput(
    Input$ChatSessionUpdateInput instance,
    TRes Function(Input$ChatSessionUpdateInput) then,
  ) = _CopyWithImpl$Input$ChatSessionUpdateInput;

  factory CopyWith$Input$ChatSessionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChatSessionUpdateInput;

  TRes call({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$ChatSessionUpdateInput<TRes>
    implements CopyWith$Input$ChatSessionUpdateInput<TRes> {
  _CopyWithImpl$Input$ChatSessionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ChatSessionUpdateInput _instance;

  final TRes Function(Input$ChatSessionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? endedAt = _undefined,
    Object? lastActiveAt = _undefined,
    Object? data = _undefined,
    Object? title = _undefined,
    Object? notes = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$ChatSessionUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (endedAt != _undefined) 'endedAt': (endedAt as DateTime?),
        if (lastActiveAt != _undefined)
          'lastActiveAt': (lastActiveAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (title != _undefined) 'title': (title as String?),
        if (notes != _undefined) 'notes': (notes as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChatSessionUpdateInput<TRes>
    implements CopyWith$Input$ChatSessionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ChatSessionUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    DateTime? createdAt,
    DateTime? startedAt,
    DateTime? endedAt,
    DateTime? lastActiveAt,
    Map<String, dynamic>? data,
    String? title,
    String? notes,
    String? applicationId,
  }) =>
      _res;
}

class Input$ContentContentPartFilter {
  factory Input$ContentContentPartFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$UUIDFilter? contentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentContentPartFilter>? and,
    List<Input$ContentContentPartFilter>? or,
    Input$ContentContentPartFilter? not,
  }) =>
      Input$ContentContentPartFilter._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (contentPartId != null) r'contentPartId': contentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentContentPartFilter._(this._$data);

  factory Input$ContentContentPartFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = l$contentId == null
          ? null
          : Input$UUIDFilter.fromJson((l$contentId as Map<String, dynamic>));
    }
    if (data.containsKey('contentPartId')) {
      final l$contentPartId = data['contentPartId'];
      result$data['contentPartId'] = l$contentPartId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentPartId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ContentContentPartFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ContentContentPartFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentContentPartFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ContentContentPartFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentId => (_$data['contentId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentPartId =>
      (_$data['contentPartId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentContentPartFilter>? get and =>
      (_$data['and'] as List<Input$ContentContentPartFilter>?);

  List<Input$ContentContentPartFilter>? get or =>
      (_$data['or'] as List<Input$ContentContentPartFilter>?);

  Input$ContentContentPartFilter? get not =>
      (_$data['not'] as Input$ContentContentPartFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId?.toJson();
    }
    if (_$data.containsKey('contentPartId')) {
      final l$contentPartId = contentPartId;
      result$data['contentPartId'] = l$contentPartId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentContentPartFilter<Input$ContentContentPartFilter>
      get copyWith => CopyWith$Input$ContentContentPartFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentContentPartFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$contentPartId = contentPartId;
    final lOther$contentPartId = other.contentPartId;
    if (_$data.containsKey('contentPartId') !=
        other._$data.containsKey('contentPartId')) {
      return false;
    }
    if (l$contentPartId != lOther$contentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$contentPartId = contentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('contentPartId') ? l$contentPartId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentContentPartFilter<TRes> {
  factory CopyWith$Input$ContentContentPartFilter(
    Input$ContentContentPartFilter instance,
    TRes Function(Input$ContentContentPartFilter) then,
  ) = _CopyWithImpl$Input$ContentContentPartFilter;

  factory CopyWith$Input$ContentContentPartFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentContentPartFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$UUIDFilter? contentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentContentPartFilter>? and,
    List<Input$ContentContentPartFilter>? or,
    Input$ContentContentPartFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get contentId;
  CopyWith$Input$UUIDFilter<TRes> get contentPartId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentContentPartFilter<
                      Input$ContentContentPartFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentContentPartFilter<
                      Input$ContentContentPartFilter>>?)
          _fn);
  CopyWith$Input$ContentContentPartFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentContentPartFilter<TRes>
    implements CopyWith$Input$ContentContentPartFilter<TRes> {
  _CopyWithImpl$Input$ContentContentPartFilter(
    this._instance,
    this._then,
  );

  final Input$ContentContentPartFilter _instance;

  final TRes Function(Input$ContentContentPartFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? contentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentContentPartFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (contentId != _undefined)
          'contentId': (contentId as Input$UUIDFilter?),
        if (contentPartId != _undefined)
          'contentPartId': (contentPartId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ContentContentPartFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$ContentContentPartFilter>?),
        if (not != _undefined) 'not': (not as Input$ContentContentPartFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentId {
    final local$contentId = _instance.contentId;
    return local$contentId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$contentId, (e) => call(contentId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentPartId {
    final local$contentPartId = _instance.contentPartId;
    return local$contentPartId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentPartId, (e) => call(contentPartId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentContentPartFilter<
                          Input$ContentContentPartFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ContentContentPartFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ContentContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentContentPartFilter<
                          Input$ContentContentPartFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$ContentContentPartFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ContentContentPartFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentContentPartFilter.stub(_then(_instance))
        : CopyWith$Input$ContentContentPartFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentContentPartFilter<TRes>
    implements CopyWith$Input$ContentContentPartFilter<TRes> {
  _CopyWithStubImpl$Input$ContentContentPartFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$UUIDFilter? contentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentContentPartFilter>? and,
    List<Input$ContentContentPartFilter>? or,
    Input$ContentContentPartFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentPartId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentContentPartFilter<TRes> get not =>
      CopyWith$Input$ContentContentPartFilter.stub(_res);
}

class Input$ContentContentPartInsertInput {
  factory Input$ContentContentPartInsertInput({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$ContentContentPartInsertInput._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (contentPartId != null) r'contentPartId': contentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentContentPartInsertInput._(this._$data);

  factory Input$ContentContentPartInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('contentPartId')) {
      final l$contentPartId = data['contentPartId'];
      result$data['contentPartId'] = (l$contentPartId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ContentContentPartInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentId => (_$data['contentId'] as String?);

  String? get contentPartId => (_$data['contentPartId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('contentPartId')) {
      final l$contentPartId = contentPartId;
      result$data['contentPartId'] = l$contentPartId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentContentPartInsertInput<
          Input$ContentContentPartInsertInput>
      get copyWith => CopyWith$Input$ContentContentPartInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentContentPartInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$contentPartId = contentPartId;
    final lOther$contentPartId = other.contentPartId;
    if (_$data.containsKey('contentPartId') !=
        other._$data.containsKey('contentPartId')) {
      return false;
    }
    if (l$contentPartId != lOther$contentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$contentPartId = contentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('contentPartId') ? l$contentPartId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentContentPartInsertInput<TRes> {
  factory CopyWith$Input$ContentContentPartInsertInput(
    Input$ContentContentPartInsertInput instance,
    TRes Function(Input$ContentContentPartInsertInput) then,
  ) = _CopyWithImpl$Input$ContentContentPartInsertInput;

  factory CopyWith$Input$ContentContentPartInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentContentPartInsertInput;

  TRes call({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ContentContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentContentPartInsertInput<TRes> {
  _CopyWithImpl$Input$ContentContentPartInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentContentPartInsertInput _instance;

  final TRes Function(Input$ContentContentPartInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? contentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentContentPartInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (contentPartId != _undefined)
          'contentPartId': (contentPartId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentContentPartInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentContentPartInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ContentContentPartOrderBy {
  factory Input$ContentContentPartOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? contentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ContentContentPartOrderBy._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (contentPartId != null) r'contentPartId': contentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentContentPartOrderBy._(this._$data);

  factory Input$ContentContentPartOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = l$contentId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentId as String));
    }
    if (data.containsKey('contentPartId')) {
      final l$contentPartId = data['contentPartId'];
      result$data['contentPartId'] = l$contentPartId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentPartId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ContentContentPartOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentId =>
      (_$data['contentId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentPartId =>
      (_$data['contentPartId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentId);
    }
    if (_$data.containsKey('contentPartId')) {
      final l$contentPartId = contentPartId;
      result$data['contentPartId'] = l$contentPartId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentPartId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ContentContentPartOrderBy<Input$ContentContentPartOrderBy>
      get copyWith => CopyWith$Input$ContentContentPartOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentContentPartOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$contentPartId = contentPartId;
    final lOther$contentPartId = other.contentPartId;
    if (_$data.containsKey('contentPartId') !=
        other._$data.containsKey('contentPartId')) {
      return false;
    }
    if (l$contentPartId != lOther$contentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$contentPartId = contentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('contentPartId') ? l$contentPartId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentContentPartOrderBy<TRes> {
  factory CopyWith$Input$ContentContentPartOrderBy(
    Input$ContentContentPartOrderBy instance,
    TRes Function(Input$ContentContentPartOrderBy) then,
  ) = _CopyWithImpl$Input$ContentContentPartOrderBy;

  factory CopyWith$Input$ContentContentPartOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentContentPartOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? contentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ContentContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentContentPartOrderBy<TRes> {
  _CopyWithImpl$Input$ContentContentPartOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentContentPartOrderBy _instance;

  final TRes Function(Input$ContentContentPartOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? contentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentContentPartOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (contentId != _undefined)
          'contentId': (contentId as Enum$OrderByDirection?),
        if (contentPartId != _undefined)
          'contentPartId': (contentPartId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentContentPartOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentContentPartOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? contentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ContentContentPartUpdateInput {
  factory Input$ContentContentPartUpdateInput({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$ContentContentPartUpdateInput._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (contentPartId != null) r'contentPartId': contentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentContentPartUpdateInput._(this._$data);

  factory Input$ContentContentPartUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('contentPartId')) {
      final l$contentPartId = data['contentPartId'];
      result$data['contentPartId'] = (l$contentPartId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ContentContentPartUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentId => (_$data['contentId'] as String?);

  String? get contentPartId => (_$data['contentPartId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('contentPartId')) {
      final l$contentPartId = contentPartId;
      result$data['contentPartId'] = l$contentPartId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentContentPartUpdateInput<
          Input$ContentContentPartUpdateInput>
      get copyWith => CopyWith$Input$ContentContentPartUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentContentPartUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$contentPartId = contentPartId;
    final lOther$contentPartId = other.contentPartId;
    if (_$data.containsKey('contentPartId') !=
        other._$data.containsKey('contentPartId')) {
      return false;
    }
    if (l$contentPartId != lOther$contentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$contentPartId = contentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('contentPartId') ? l$contentPartId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentContentPartUpdateInput<TRes> {
  factory CopyWith$Input$ContentContentPartUpdateInput(
    Input$ContentContentPartUpdateInput instance,
    TRes Function(Input$ContentContentPartUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentContentPartUpdateInput;

  factory CopyWith$Input$ContentContentPartUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentContentPartUpdateInput;

  TRes call({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ContentContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentContentPartUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentContentPartUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentContentPartUpdateInput _instance;

  final TRes Function(Input$ContentContentPartUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? contentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentContentPartUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (contentPartId != _undefined)
          'contentPartId': (contentPartId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentContentPartUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentContentPartUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentId,
    String? contentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ContentFilter {
  factory Input$ContentFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? body,
    Input$UUIDFilter? contentTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? authorId,
    Input$IntFilter? version,
    Input$BooleanFilter? isApproved,
    Input$DatetimeFilter? approvedAt,
    Input$UUIDFilter? publicationStateId,
    Input$StringFilter? coverUrl,
    Input$UUIDFilter? contentTemplateId,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentFilter>? and,
    List<Input$ContentFilter>? or,
    Input$ContentFilter? not,
  }) =>
      Input$ContentFilter._({
        if (id != null) r'id': id,
        if (applicationId != null) r'applicationId': applicationId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (body != null) r'body': body,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (authorId != null) r'authorId': authorId,
        if (version != null) r'version': version,
        if (isApproved != null) r'isApproved': isApproved,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publicationStateId != null)
          r'publicationStateId': publicationStateId,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentFilter._(this._$data);

  factory Input$ContentFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : Input$StringFilter.fromJson((l$body as Map<String, dynamic>));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('authorId')) {
      final l$authorId = data['authorId'];
      result$data['authorId'] = l$authorId == null
          ? null
          : Input$UUIDFilter.fromJson((l$authorId as Map<String, dynamic>));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$IntFilter.fromJson((l$version as Map<String, dynamic>));
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = l$isApproved == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isApproved as Map<String, dynamic>));
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$approvedAt as Map<String, dynamic>));
    }
    if (data.containsKey('publicationStateId')) {
      final l$publicationStateId = data['publicationStateId'];
      result$data['publicationStateId'] = l$publicationStateId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$publicationStateId as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentTemplateId as Map<String, dynamic>));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : Input$StringFilter.fromJson(
              (l$publicationUrl as Map<String, dynamic>));
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$bodyMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$ContentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$ContentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ContentFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get body => (_$data['body'] as Input$StringFilter?);

  Input$UUIDFilter? get contentTypeId =>
      (_$data['contentTypeId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get authorId => (_$data['authorId'] as Input$UUIDFilter?);

  Input$IntFilter? get version => (_$data['version'] as Input$IntFilter?);

  Input$BooleanFilter? get isApproved =>
      (_$data['isApproved'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get approvedAt =>
      (_$data['approvedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get publicationStateId =>
      (_$data['publicationStateId'] as Input$UUIDFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$UUIDFilter? get contentTemplateId =>
      (_$data['contentTemplateId'] as Input$UUIDFilter?);

  Input$StringFilter? get publicationUrl =>
      (_$data['publicationUrl'] as Input$StringFilter?);

  Input$StringFilter? get bodyMarkdown =>
      (_$data['bodyMarkdown'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentFilter>? get and =>
      (_$data['and'] as List<Input$ContentFilter>?);

  List<Input$ContentFilter>? get or =>
      (_$data['or'] as List<Input$ContentFilter>?);

  Input$ContentFilter? get not => (_$data['not'] as Input$ContentFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body?.toJson();
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('authorId')) {
      final l$authorId = authorId;
      result$data['authorId'] = l$authorId?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved?.toJson();
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toJson();
    }
    if (_$data.containsKey('publicationStateId')) {
      final l$publicationStateId = publicationStateId;
      result$data['publicationStateId'] = l$publicationStateId?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId?.toJson();
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl?.toJson();
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentFilter<Input$ContentFilter> get copyWith =>
      CopyWith$Input$ContentFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (_$data.containsKey('authorId') !=
        other._$data.containsKey('authorId')) {
      return false;
    }
    if (l$authorId != lOther$authorId) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publicationStateId = publicationStateId;
    final lOther$publicationStateId = other.publicationStateId;
    if (_$data.containsKey('publicationStateId') !=
        other._$data.containsKey('publicationStateId')) {
      return false;
    }
    if (l$publicationStateId != lOther$publicationStateId) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$applicationId = applicationId;
    final l$title = title;
    final l$description = description;
    final l$body = body;
    final l$contentTypeId = contentTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$version = version;
    final l$isApproved = isApproved;
    final l$approvedAt = approvedAt;
    final l$publicationStateId = publicationStateId;
    final l$coverUrl = coverUrl;
    final l$contentTemplateId = contentTemplateId;
    final l$publicationUrl = publicationUrl;
    final l$bodyMarkdown = bodyMarkdown;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('authorId') ? l$authorId : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publicationStateId')
          ? l$publicationStateId
          : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentFilter<TRes> {
  factory CopyWith$Input$ContentFilter(
    Input$ContentFilter instance,
    TRes Function(Input$ContentFilter) then,
  ) = _CopyWithImpl$Input$ContentFilter;

  factory CopyWith$Input$ContentFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? body,
    Input$UUIDFilter? contentTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? authorId,
    Input$IntFilter? version,
    Input$BooleanFilter? isApproved,
    Input$DatetimeFilter? approvedAt,
    Input$UUIDFilter? publicationStateId,
    Input$StringFilter? coverUrl,
    Input$UUIDFilter? contentTemplateId,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentFilter>? and,
    List<Input$ContentFilter>? or,
    Input$ContentFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get body;
  CopyWith$Input$UUIDFilter<TRes> get contentTypeId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$UUIDFilter<TRes> get authorId;
  CopyWith$Input$IntFilter<TRes> get version;
  CopyWith$Input$BooleanFilter<TRes> get isApproved;
  CopyWith$Input$DatetimeFilter<TRes> get approvedAt;
  CopyWith$Input$UUIDFilter<TRes> get publicationStateId;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId;
  CopyWith$Input$StringFilter<TRes> get publicationUrl;
  CopyWith$Input$StringFilter<TRes> get bodyMarkdown;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentFilter>? Function(
              Iterable<CopyWith$Input$ContentFilter<Input$ContentFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentFilter>? Function(
              Iterable<CopyWith$Input$ContentFilter<Input$ContentFilter>>?)
          _fn);
  CopyWith$Input$ContentFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentFilter<TRes>
    implements CopyWith$Input$ContentFilter<TRes> {
  _CopyWithImpl$Input$ContentFilter(
    this._instance,
    this._then,
  );

  final Input$ContentFilter _instance;

  final TRes Function(Input$ContentFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? applicationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? body = _undefined,
    Object? contentTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? authorId = _undefined,
    Object? version = _undefined,
    Object? isApproved = _undefined,
    Object? approvedAt = _undefined,
    Object? publicationStateId = _undefined,
    Object? coverUrl = _undefined,
    Object? contentTemplateId = _undefined,
    Object? publicationUrl = _undefined,
    Object? bodyMarkdown = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (body != _undefined) 'body': (body as Input$StringFilter?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (authorId != _undefined) 'authorId': (authorId as Input$UUIDFilter?),
        if (version != _undefined) 'version': (version as Input$IntFilter?),
        if (isApproved != _undefined)
          'isApproved': (isApproved as Input$BooleanFilter?),
        if (approvedAt != _undefined)
          'approvedAt': (approvedAt as Input$DatetimeFilter?),
        if (publicationStateId != _undefined)
          'publicationStateId': (publicationStateId as Input$UUIDFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as Input$UUIDFilter?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as Input$StringFilter?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ContentFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ContentFilter>?),
        if (not != _undefined) 'not': (not as Input$ContentFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get body {
    final local$body = _instance.body;
    return local$body == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$body, (e) => call(body: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId {
    final local$contentTypeId = _instance.contentTypeId;
    return local$contentTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentTypeId, (e) => call(contentTypeId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get authorId {
    final local$authorId = _instance.authorId;
    return local$authorId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$authorId, (e) => call(authorId: e));
  }

  CopyWith$Input$IntFilter<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$version, (e) => call(version: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isApproved {
    final local$isApproved = _instance.isApproved;
    return local$isApproved == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isApproved, (e) => call(isApproved: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get approvedAt {
    final local$approvedAt = _instance.approvedAt;
    return local$approvedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$approvedAt, (e) => call(approvedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get publicationStateId {
    final local$publicationStateId = _instance.publicationStateId;
    return local$publicationStateId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$publicationStateId, (e) => call(publicationStateId: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId {
    final local$contentTemplateId = _instance.contentTemplateId;
    return local$contentTemplateId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentTemplateId, (e) => call(contentTemplateId: e));
  }

  CopyWith$Input$StringFilter<TRes> get publicationUrl {
    final local$publicationUrl = _instance.publicationUrl;
    return local$publicationUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$publicationUrl, (e) => call(publicationUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get bodyMarkdown {
    final local$bodyMarkdown = _instance.bodyMarkdown;
    return local$bodyMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$bodyMarkdown, (e) => call(bodyMarkdown: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentFilter>? Function(
                  Iterable<CopyWith$Input$ContentFilter<Input$ContentFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ContentFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ContentFilter>? Function(
                  Iterable<CopyWith$Input$ContentFilter<Input$ContentFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ContentFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ContentFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentFilter.stub(_then(_instance))
        : CopyWith$Input$ContentFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentFilter<TRes>
    implements CopyWith$Input$ContentFilter<TRes> {
  _CopyWithStubImpl$Input$ContentFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? body,
    Input$UUIDFilter? contentTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? authorId,
    Input$IntFilter? version,
    Input$BooleanFilter? isApproved,
    Input$DatetimeFilter? approvedAt,
    Input$UUIDFilter? publicationStateId,
    Input$StringFilter? coverUrl,
    Input$UUIDFilter? contentTemplateId,
    Input$StringFilter? publicationUrl,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentFilter>? and,
    List<Input$ContentFilter>? or,
    Input$ContentFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get body =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get authorId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get version =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isApproved =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get approvedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get publicationStateId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get publicationUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get bodyMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentFilter<TRes> get not =>
      CopyWith$Input$ContentFilter.stub(_res);
}

class Input$ContentInsertInput {
  factory Input$ContentInsertInput({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  }) =>
      Input$ContentInsertInput._({
        if (id != null) r'id': id,
        if (applicationId != null) r'applicationId': applicationId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (body != null) r'body': body,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (authorId != null) r'authorId': authorId,
        if (data != null) r'data': data,
        if (version != null) r'version': version,
        if (isApproved != null) r'isApproved': isApproved,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publicationStateId != null)
          r'publicationStateId': publicationStateId,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentInsertInput._(this._$data);

  factory Input$ContentInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('authorId')) {
      final l$authorId = data['authorId'];
      result$data['authorId'] = (l$authorId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as int?);
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = (l$isApproved as bool?);
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : DateTime.parse((l$approvedAt as String));
    }
    if (data.containsKey('publicationStateId')) {
      final l$publicationStateId = data['publicationStateId'];
      result$data['publicationStateId'] = (l$publicationStateId as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = (l$contentTemplateId as String?);
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = (l$publicationUrl as String?);
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = (l$bodyMarkdown as String?);
    }
    return Input$ContentInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get body => (_$data['body'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get authorId => (_$data['authorId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  int? get version => (_$data['version'] as int?);

  bool? get isApproved => (_$data['isApproved'] as bool?);

  DateTime? get approvedAt => (_$data['approvedAt'] as DateTime?);

  String? get publicationStateId => (_$data['publicationStateId'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  String? get contentTemplateId => (_$data['contentTemplateId'] as String?);

  String? get publicationUrl => (_$data['publicationUrl'] as String?);

  String? get bodyMarkdown => (_$data['bodyMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('authorId')) {
      final l$authorId = authorId;
      result$data['authorId'] = l$authorId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved;
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toIso8601String();
    }
    if (_$data.containsKey('publicationStateId')) {
      final l$publicationStateId = publicationStateId;
      result$data['publicationStateId'] = l$publicationStateId;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId;
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl;
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$ContentInsertInput<Input$ContentInsertInput> get copyWith =>
      CopyWith$Input$ContentInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (_$data.containsKey('authorId') !=
        other._$data.containsKey('authorId')) {
      return false;
    }
    if (l$authorId != lOther$authorId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publicationStateId = publicationStateId;
    final lOther$publicationStateId = other.publicationStateId;
    if (_$data.containsKey('publicationStateId') !=
        other._$data.containsKey('publicationStateId')) {
      return false;
    }
    if (l$publicationStateId != lOther$publicationStateId) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$applicationId = applicationId;
    final l$title = title;
    final l$description = description;
    final l$body = body;
    final l$contentTypeId = contentTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$data = data;
    final l$version = version;
    final l$isApproved = isApproved;
    final l$approvedAt = approvedAt;
    final l$publicationStateId = publicationStateId;
    final l$coverUrl = coverUrl;
    final l$contentTemplateId = contentTemplateId;
    final l$publicationUrl = publicationUrl;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('authorId') ? l$authorId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publicationStateId')
          ? l$publicationStateId
          : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentInsertInput<TRes> {
  factory CopyWith$Input$ContentInsertInput(
    Input$ContentInsertInput instance,
    TRes Function(Input$ContentInsertInput) then,
  ) = _CopyWithImpl$Input$ContentInsertInput;

  factory CopyWith$Input$ContentInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentInsertInput;

  TRes call({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentInsertInput<TRes>
    implements CopyWith$Input$ContentInsertInput<TRes> {
  _CopyWithImpl$Input$ContentInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentInsertInput _instance;

  final TRes Function(Input$ContentInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? applicationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? body = _undefined,
    Object? contentTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? authorId = _undefined,
    Object? data = _undefined,
    Object? version = _undefined,
    Object? isApproved = _undefined,
    Object? approvedAt = _undefined,
    Object? publicationStateId = _undefined,
    Object? coverUrl = _undefined,
    Object? contentTemplateId = _undefined,
    Object? publicationUrl = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (body != _undefined) 'body': (body as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (authorId != _undefined) 'authorId': (authorId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (version != _undefined) 'version': (version as int?),
        if (isApproved != _undefined) 'isApproved': (isApproved as bool?),
        if (approvedAt != _undefined) 'approvedAt': (approvedAt as DateTime?),
        if (publicationStateId != _undefined)
          'publicationStateId': (publicationStateId as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as String?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as String?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentInsertInput<TRes>
    implements CopyWith$Input$ContentInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  }) =>
      _res;
}

class Input$ContentOrderBy {
  factory Input$ContentOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? authorId,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publicationStateId,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? bodyMarkdown,
  }) =>
      Input$ContentOrderBy._({
        if (id != null) r'id': id,
        if (applicationId != null) r'applicationId': applicationId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (body != null) r'body': body,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (authorId != null) r'authorId': authorId,
        if (version != null) r'version': version,
        if (isApproved != null) r'isApproved': isApproved,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publicationStateId != null)
          r'publicationStateId': publicationStateId,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentOrderBy._(this._$data);

  factory Input$ContentOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : fromJson$Enum$OrderByDirection((l$body as String));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentTypeId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('authorId')) {
      final l$authorId = data['authorId'];
      result$data['authorId'] = l$authorId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$authorId as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderByDirection((l$version as String));
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = l$isApproved == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isApproved as String));
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$approvedAt as String));
    }
    if (data.containsKey('publicationStateId')) {
      final l$publicationStateId = data['publicationStateId'];
      result$data['publicationStateId'] = l$publicationStateId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$publicationStateId as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentTemplateId as String));
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$publicationUrl as String));
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection((l$bodyMarkdown as String));
    }
    return Input$ContentOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get body => (_$data['body'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentTypeId =>
      (_$data['contentTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get authorId =>
      (_$data['authorId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get version =>
      (_$data['version'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isApproved =>
      (_$data['isApproved'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get approvedAt =>
      (_$data['approvedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get publicationStateId =>
      (_$data['publicationStateId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentTemplateId =>
      (_$data['contentTemplateId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get publicationUrl =>
      (_$data['publicationUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get bodyMarkdown =>
      (_$data['bodyMarkdown'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] =
          l$body == null ? null : toJson$Enum$OrderByDirection(l$body);
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentTypeId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('authorId')) {
      final l$authorId = authorId;
      result$data['authorId'] =
          l$authorId == null ? null : toJson$Enum$OrderByDirection(l$authorId);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderByDirection(l$version);
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved == null
          ? null
          : toJson$Enum$OrderByDirection(l$isApproved);
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$approvedAt);
    }
    if (_$data.containsKey('publicationStateId')) {
      final l$publicationStateId = publicationStateId;
      result$data['publicationStateId'] = l$publicationStateId == null
          ? null
          : toJson$Enum$OrderByDirection(l$publicationStateId);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentTemplateId);
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$publicationUrl);
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$bodyMarkdown);
    }
    return result$data;
  }

  CopyWith$Input$ContentOrderBy<Input$ContentOrderBy> get copyWith =>
      CopyWith$Input$ContentOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (_$data.containsKey('authorId') !=
        other._$data.containsKey('authorId')) {
      return false;
    }
    if (l$authorId != lOther$authorId) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publicationStateId = publicationStateId;
    final lOther$publicationStateId = other.publicationStateId;
    if (_$data.containsKey('publicationStateId') !=
        other._$data.containsKey('publicationStateId')) {
      return false;
    }
    if (l$publicationStateId != lOther$publicationStateId) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$applicationId = applicationId;
    final l$title = title;
    final l$description = description;
    final l$body = body;
    final l$contentTypeId = contentTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$version = version;
    final l$isApproved = isApproved;
    final l$approvedAt = approvedAt;
    final l$publicationStateId = publicationStateId;
    final l$coverUrl = coverUrl;
    final l$contentTemplateId = contentTemplateId;
    final l$publicationUrl = publicationUrl;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('authorId') ? l$authorId : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publicationStateId')
          ? l$publicationStateId
          : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentOrderBy<TRes> {
  factory CopyWith$Input$ContentOrderBy(
    Input$ContentOrderBy instance,
    TRes Function(Input$ContentOrderBy) then,
  ) = _CopyWithImpl$Input$ContentOrderBy;

  factory CopyWith$Input$ContentOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? authorId,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publicationStateId,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentOrderBy<TRes>
    implements CopyWith$Input$ContentOrderBy<TRes> {
  _CopyWithImpl$Input$ContentOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentOrderBy _instance;

  final TRes Function(Input$ContentOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? applicationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? body = _undefined,
    Object? contentTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? authorId = _undefined,
    Object? version = _undefined,
    Object? isApproved = _undefined,
    Object? approvedAt = _undefined,
    Object? publicationStateId = _undefined,
    Object? coverUrl = _undefined,
    Object? contentTemplateId = _undefined,
    Object? publicationUrl = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (body != _undefined) 'body': (body as Enum$OrderByDirection?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (authorId != _undefined)
          'authorId': (authorId as Enum$OrderByDirection?),
        if (version != _undefined)
          'version': (version as Enum$OrderByDirection?),
        if (isApproved != _undefined)
          'isApproved': (isApproved as Enum$OrderByDirection?),
        if (approvedAt != _undefined)
          'approvedAt': (approvedAt as Enum$OrderByDirection?),
        if (publicationStateId != _undefined)
          'publicationStateId': (publicationStateId as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as Enum$OrderByDirection?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as Enum$OrderByDirection?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentOrderBy<TRes>
    implements CopyWith$Input$ContentOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? authorId,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? isApproved,
    Enum$OrderByDirection? approvedAt,
    Enum$OrderByDirection? publicationStateId,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? publicationUrl,
    Enum$OrderByDirection? bodyMarkdown,
  }) =>
      _res;
}

class Input$ContentPartContentPartFilter {
  factory Input$ContentPartContentPartFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? parentContentPartId,
    Input$UUIDFilter? childContentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentPartContentPartFilter>? and,
    List<Input$ContentPartContentPartFilter>? or,
    Input$ContentPartContentPartFilter? not,
  }) =>
      Input$ContentPartContentPartFilter._({
        if (id != null) r'id': id,
        if (parentContentPartId != null)
          r'parentContentPartId': parentContentPartId,
        if (childContentPartId != null)
          r'childContentPartId': childContentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentPartContentPartFilter._(this._$data);

  factory Input$ContentPartContentPartFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = data['parentContentPartId'];
      result$data['parentContentPartId'] = l$parentContentPartId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$parentContentPartId as Map<String, dynamic>));
    }
    if (data.containsKey('childContentPartId')) {
      final l$childContentPartId = data['childContentPartId'];
      result$data['childContentPartId'] = l$childContentPartId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$childContentPartId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ContentPartContentPartFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ContentPartContentPartFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentPartContentPartFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ContentPartContentPartFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get parentContentPartId =>
      (_$data['parentContentPartId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get childContentPartId =>
      (_$data['childContentPartId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentPartContentPartFilter>? get and =>
      (_$data['and'] as List<Input$ContentPartContentPartFilter>?);

  List<Input$ContentPartContentPartFilter>? get or =>
      (_$data['or'] as List<Input$ContentPartContentPartFilter>?);

  Input$ContentPartContentPartFilter? get not =>
      (_$data['not'] as Input$ContentPartContentPartFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = parentContentPartId;
      result$data['parentContentPartId'] = l$parentContentPartId?.toJson();
    }
    if (_$data.containsKey('childContentPartId')) {
      final l$childContentPartId = childContentPartId;
      result$data['childContentPartId'] = l$childContentPartId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentPartContentPartFilter<
          Input$ContentPartContentPartFilter>
      get copyWith => CopyWith$Input$ContentPartContentPartFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartContentPartFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$parentContentPartId = parentContentPartId;
    final lOther$parentContentPartId = other.parentContentPartId;
    if (_$data.containsKey('parentContentPartId') !=
        other._$data.containsKey('parentContentPartId')) {
      return false;
    }
    if (l$parentContentPartId != lOther$parentContentPartId) {
      return false;
    }
    final l$childContentPartId = childContentPartId;
    final lOther$childContentPartId = other.childContentPartId;
    if (_$data.containsKey('childContentPartId') !=
        other._$data.containsKey('childContentPartId')) {
      return false;
    }
    if (l$childContentPartId != lOther$childContentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$parentContentPartId = parentContentPartId;
    final l$childContentPartId = childContentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('parentContentPartId')
          ? l$parentContentPartId
          : const {},
      _$data.containsKey('childContentPartId')
          ? l$childContentPartId
          : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartContentPartFilter<TRes> {
  factory CopyWith$Input$ContentPartContentPartFilter(
    Input$ContentPartContentPartFilter instance,
    TRes Function(Input$ContentPartContentPartFilter) then,
  ) = _CopyWithImpl$Input$ContentPartContentPartFilter;

  factory CopyWith$Input$ContentPartContentPartFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartContentPartFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? parentContentPartId,
    Input$UUIDFilter? childContentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentPartContentPartFilter>? and,
    List<Input$ContentPartContentPartFilter>? or,
    Input$ContentPartContentPartFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get parentContentPartId;
  CopyWith$Input$UUIDFilter<TRes> get childContentPartId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentPartContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentPartContentPartFilter<
                      Input$ContentPartContentPartFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentPartContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentPartContentPartFilter<
                      Input$ContentPartContentPartFilter>>?)
          _fn);
  CopyWith$Input$ContentPartContentPartFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentPartContentPartFilter<TRes>
    implements CopyWith$Input$ContentPartContentPartFilter<TRes> {
  _CopyWithImpl$Input$ContentPartContentPartFilter(
    this._instance,
    this._then,
  );

  final Input$ContentPartContentPartFilter _instance;

  final TRes Function(Input$ContentPartContentPartFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? parentContentPartId = _undefined,
    Object? childContentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentPartContentPartFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (parentContentPartId != _undefined)
          'parentContentPartId': (parentContentPartId as Input$UUIDFilter?),
        if (childContentPartId != _undefined)
          'childContentPartId': (childContentPartId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ContentPartContentPartFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$ContentPartContentPartFilter>?),
        if (not != _undefined)
          'not': (not as Input$ContentPartContentPartFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get parentContentPartId {
    final local$parentContentPartId = _instance.parentContentPartId;
    return local$parentContentPartId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$parentContentPartId, (e) => call(parentContentPartId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get childContentPartId {
    final local$childContentPartId = _instance.childContentPartId;
    return local$childContentPartId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$childContentPartId, (e) => call(childContentPartId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentPartContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentPartContentPartFilter<
                          Input$ContentPartContentPartFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ContentPartContentPartFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ContentPartContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentPartContentPartFilter<
                          Input$ContentPartContentPartFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$ContentPartContentPartFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ContentPartContentPartFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentPartContentPartFilter.stub(_then(_instance))
        : CopyWith$Input$ContentPartContentPartFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentPartContentPartFilter<TRes>
    implements CopyWith$Input$ContentPartContentPartFilter<TRes> {
  _CopyWithStubImpl$Input$ContentPartContentPartFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? parentContentPartId,
    Input$UUIDFilter? childContentPartId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentPartContentPartFilter>? and,
    List<Input$ContentPartContentPartFilter>? or,
    Input$ContentPartContentPartFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get parentContentPartId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get childContentPartId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentPartContentPartFilter<TRes> get not =>
      CopyWith$Input$ContentPartContentPartFilter.stub(_res);
}

class Input$ContentPartContentPartInsertInput {
  factory Input$ContentPartContentPartInsertInput({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$ContentPartContentPartInsertInput._({
        if (id != null) r'id': id,
        if (parentContentPartId != null)
          r'parentContentPartId': parentContentPartId,
        if (childContentPartId != null)
          r'childContentPartId': childContentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentPartContentPartInsertInput._(this._$data);

  factory Input$ContentPartContentPartInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = data['parentContentPartId'];
      result$data['parentContentPartId'] = (l$parentContentPartId as String?);
    }
    if (data.containsKey('childContentPartId')) {
      final l$childContentPartId = data['childContentPartId'];
      result$data['childContentPartId'] = (l$childContentPartId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ContentPartContentPartInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get parentContentPartId => (_$data['parentContentPartId'] as String?);

  String? get childContentPartId => (_$data['childContentPartId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = parentContentPartId;
      result$data['parentContentPartId'] = l$parentContentPartId;
    }
    if (_$data.containsKey('childContentPartId')) {
      final l$childContentPartId = childContentPartId;
      result$data['childContentPartId'] = l$childContentPartId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentPartContentPartInsertInput<
          Input$ContentPartContentPartInsertInput>
      get copyWith => CopyWith$Input$ContentPartContentPartInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartContentPartInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$parentContentPartId = parentContentPartId;
    final lOther$parentContentPartId = other.parentContentPartId;
    if (_$data.containsKey('parentContentPartId') !=
        other._$data.containsKey('parentContentPartId')) {
      return false;
    }
    if (l$parentContentPartId != lOther$parentContentPartId) {
      return false;
    }
    final l$childContentPartId = childContentPartId;
    final lOther$childContentPartId = other.childContentPartId;
    if (_$data.containsKey('childContentPartId') !=
        other._$data.containsKey('childContentPartId')) {
      return false;
    }
    if (l$childContentPartId != lOther$childContentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$parentContentPartId = parentContentPartId;
    final l$childContentPartId = childContentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('parentContentPartId')
          ? l$parentContentPartId
          : const {},
      _$data.containsKey('childContentPartId')
          ? l$childContentPartId
          : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartContentPartInsertInput<TRes> {
  factory CopyWith$Input$ContentPartContentPartInsertInput(
    Input$ContentPartContentPartInsertInput instance,
    TRes Function(Input$ContentPartContentPartInsertInput) then,
  ) = _CopyWithImpl$Input$ContentPartContentPartInsertInput;

  factory CopyWith$Input$ContentPartContentPartInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartContentPartInsertInput;

  TRes call({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ContentPartContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentPartContentPartInsertInput<TRes> {
  _CopyWithImpl$Input$ContentPartContentPartInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentPartContentPartInsertInput _instance;

  final TRes Function(Input$ContentPartContentPartInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? parentContentPartId = _undefined,
    Object? childContentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentPartContentPartInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (parentContentPartId != _undefined)
          'parentContentPartId': (parentContentPartId as String?),
        if (childContentPartId != _undefined)
          'childContentPartId': (childContentPartId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentPartContentPartInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentPartContentPartInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ContentPartContentPartOrderBy {
  factory Input$ContentPartContentPartOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? parentContentPartId,
    Enum$OrderByDirection? childContentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ContentPartContentPartOrderBy._({
        if (id != null) r'id': id,
        if (parentContentPartId != null)
          r'parentContentPartId': parentContentPartId,
        if (childContentPartId != null)
          r'childContentPartId': childContentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentPartContentPartOrderBy._(this._$data);

  factory Input$ContentPartContentPartOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = data['parentContentPartId'];
      result$data['parentContentPartId'] = l$parentContentPartId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$parentContentPartId as String));
    }
    if (data.containsKey('childContentPartId')) {
      final l$childContentPartId = data['childContentPartId'];
      result$data['childContentPartId'] = l$childContentPartId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$childContentPartId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ContentPartContentPartOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get parentContentPartId =>
      (_$data['parentContentPartId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get childContentPartId =>
      (_$data['childContentPartId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = parentContentPartId;
      result$data['parentContentPartId'] = l$parentContentPartId == null
          ? null
          : toJson$Enum$OrderByDirection(l$parentContentPartId);
    }
    if (_$data.containsKey('childContentPartId')) {
      final l$childContentPartId = childContentPartId;
      result$data['childContentPartId'] = l$childContentPartId == null
          ? null
          : toJson$Enum$OrderByDirection(l$childContentPartId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ContentPartContentPartOrderBy<
          Input$ContentPartContentPartOrderBy>
      get copyWith => CopyWith$Input$ContentPartContentPartOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartContentPartOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$parentContentPartId = parentContentPartId;
    final lOther$parentContentPartId = other.parentContentPartId;
    if (_$data.containsKey('parentContentPartId') !=
        other._$data.containsKey('parentContentPartId')) {
      return false;
    }
    if (l$parentContentPartId != lOther$parentContentPartId) {
      return false;
    }
    final l$childContentPartId = childContentPartId;
    final lOther$childContentPartId = other.childContentPartId;
    if (_$data.containsKey('childContentPartId') !=
        other._$data.containsKey('childContentPartId')) {
      return false;
    }
    if (l$childContentPartId != lOther$childContentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$parentContentPartId = parentContentPartId;
    final l$childContentPartId = childContentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('parentContentPartId')
          ? l$parentContentPartId
          : const {},
      _$data.containsKey('childContentPartId')
          ? l$childContentPartId
          : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartContentPartOrderBy<TRes> {
  factory CopyWith$Input$ContentPartContentPartOrderBy(
    Input$ContentPartContentPartOrderBy instance,
    TRes Function(Input$ContentPartContentPartOrderBy) then,
  ) = _CopyWithImpl$Input$ContentPartContentPartOrderBy;

  factory CopyWith$Input$ContentPartContentPartOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartContentPartOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? parentContentPartId,
    Enum$OrderByDirection? childContentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ContentPartContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentPartContentPartOrderBy<TRes> {
  _CopyWithImpl$Input$ContentPartContentPartOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentPartContentPartOrderBy _instance;

  final TRes Function(Input$ContentPartContentPartOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? parentContentPartId = _undefined,
    Object? childContentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentPartContentPartOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (parentContentPartId != _undefined)
          'parentContentPartId':
              (parentContentPartId as Enum$OrderByDirection?),
        if (childContentPartId != _undefined)
          'childContentPartId': (childContentPartId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentPartContentPartOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentPartContentPartOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? parentContentPartId,
    Enum$OrderByDirection? childContentPartId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ContentPartContentPartUpdateInput {
  factory Input$ContentPartContentPartUpdateInput({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$ContentPartContentPartUpdateInput._({
        if (id != null) r'id': id,
        if (parentContentPartId != null)
          r'parentContentPartId': parentContentPartId,
        if (childContentPartId != null)
          r'childContentPartId': childContentPartId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentPartContentPartUpdateInput._(this._$data);

  factory Input$ContentPartContentPartUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = data['parentContentPartId'];
      result$data['parentContentPartId'] = (l$parentContentPartId as String?);
    }
    if (data.containsKey('childContentPartId')) {
      final l$childContentPartId = data['childContentPartId'];
      result$data['childContentPartId'] = (l$childContentPartId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ContentPartContentPartUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get parentContentPartId => (_$data['parentContentPartId'] as String?);

  String? get childContentPartId => (_$data['childContentPartId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('parentContentPartId')) {
      final l$parentContentPartId = parentContentPartId;
      result$data['parentContentPartId'] = l$parentContentPartId;
    }
    if (_$data.containsKey('childContentPartId')) {
      final l$childContentPartId = childContentPartId;
      result$data['childContentPartId'] = l$childContentPartId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentPartContentPartUpdateInput<
          Input$ContentPartContentPartUpdateInput>
      get copyWith => CopyWith$Input$ContentPartContentPartUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartContentPartUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$parentContentPartId = parentContentPartId;
    final lOther$parentContentPartId = other.parentContentPartId;
    if (_$data.containsKey('parentContentPartId') !=
        other._$data.containsKey('parentContentPartId')) {
      return false;
    }
    if (l$parentContentPartId != lOther$parentContentPartId) {
      return false;
    }
    final l$childContentPartId = childContentPartId;
    final lOther$childContentPartId = other.childContentPartId;
    if (_$data.containsKey('childContentPartId') !=
        other._$data.containsKey('childContentPartId')) {
      return false;
    }
    if (l$childContentPartId != lOther$childContentPartId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$parentContentPartId = parentContentPartId;
    final l$childContentPartId = childContentPartId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('parentContentPartId')
          ? l$parentContentPartId
          : const {},
      _$data.containsKey('childContentPartId')
          ? l$childContentPartId
          : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartContentPartUpdateInput<TRes> {
  factory CopyWith$Input$ContentPartContentPartUpdateInput(
    Input$ContentPartContentPartUpdateInput instance,
    TRes Function(Input$ContentPartContentPartUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentPartContentPartUpdateInput;

  factory CopyWith$Input$ContentPartContentPartUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartContentPartUpdateInput;

  TRes call({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ContentPartContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentPartContentPartUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentPartContentPartUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentPartContentPartUpdateInput _instance;

  final TRes Function(Input$ContentPartContentPartUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? parentContentPartId = _undefined,
    Object? childContentPartId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentPartContentPartUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (parentContentPartId != _undefined)
          'parentContentPartId': (parentContentPartId as String?),
        if (childContentPartId != _undefined)
          'childContentPartId': (childContentPartId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentPartContentPartUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentPartContentPartUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? parentContentPartId,
    String? childContentPartId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ContentPartFilter {
  factory Input$ContentPartFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$IntFilter? version,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? aiContext,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentPartFilter>? and,
    List<Input$ContentPartFilter>? or,
    Input$ContentPartFilter? not,
  }) =>
      Input$ContentPartFilter._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (version != null) r'version': version,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (aiContext != null) r'aiContext': aiContext,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentPartFilter._(this._$data);

  factory Input$ContentPartFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : Input$StringFilter.fromJson((l$body as Map<String, dynamic>));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$IntFilter.fromJson((l$version as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('aiContext')) {
      final l$aiContext = data['aiContext'];
      result$data['aiContext'] = l$aiContext == null
          ? null
          : Input$StringFilter.fromJson((l$aiContext as Map<String, dynamic>));
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$bodyMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ContentPartFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ContentPartFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentPartFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ContentPartFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentTypeId =>
      (_$data['contentTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get body => (_$data['body'] as Input$StringFilter?);

  Input$IntFilter? get version => (_$data['version'] as Input$IntFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get aiContext =>
      (_$data['aiContext'] as Input$StringFilter?);

  Input$StringFilter? get bodyMarkdown =>
      (_$data['bodyMarkdown'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentPartFilter>? get and =>
      (_$data['and'] as List<Input$ContentPartFilter>?);

  List<Input$ContentPartFilter>? get or =>
      (_$data['or'] as List<Input$ContentPartFilter>?);

  Input$ContentPartFilter? get not =>
      (_$data['not'] as Input$ContentPartFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('aiContext')) {
      final l$aiContext = aiContext;
      result$data['aiContext'] = l$aiContext?.toJson();
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentPartFilter<Input$ContentPartFilter> get copyWith =>
      CopyWith$Input$ContentPartFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$aiContext = aiContext;
    final lOther$aiContext = other.aiContext;
    if (_$data.containsKey('aiContext') !=
        other._$data.containsKey('aiContext')) {
      return false;
    }
    if (l$aiContext != lOther$aiContext) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$version = version;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$aiContext = aiContext;
    final l$bodyMarkdown = bodyMarkdown;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('aiContext') ? l$aiContext : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartFilter<TRes> {
  factory CopyWith$Input$ContentPartFilter(
    Input$ContentPartFilter instance,
    TRes Function(Input$ContentPartFilter) then,
  ) = _CopyWithImpl$Input$ContentPartFilter;

  factory CopyWith$Input$ContentPartFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$IntFilter? version,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? aiContext,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentPartFilter>? and,
    List<Input$ContentPartFilter>? or,
    Input$ContentPartFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get contentTypeId;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get body;
  CopyWith$Input$IntFilter<TRes> get version;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringFilter<TRes> get aiContext;
  CopyWith$Input$StringFilter<TRes> get bodyMarkdown;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentPartFilter<Input$ContentPartFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentPartFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentPartFilter<Input$ContentPartFilter>>?)
          _fn);
  CopyWith$Input$ContentPartFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentPartFilter<TRes>
    implements CopyWith$Input$ContentPartFilter<TRes> {
  _CopyWithImpl$Input$ContentPartFilter(
    this._instance,
    this._then,
  );

  final Input$ContentPartFilter _instance;

  final TRes Function(Input$ContentPartFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? version = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? aiContext = _undefined,
    Object? bodyMarkdown = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentPartFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Input$UUIDFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (body != _undefined) 'body': (body as Input$StringFilter?),
        if (version != _undefined) 'version': (version as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (aiContext != _undefined)
          'aiContext': (aiContext as Input$StringFilter?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ContentPartFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ContentPartFilter>?),
        if (not != _undefined) 'not': (not as Input$ContentPartFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId {
    final local$contentTypeId = _instance.contentTypeId;
    return local$contentTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentTypeId, (e) => call(contentTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get body {
    final local$body = _instance.body;
    return local$body == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$body, (e) => call(body: e));
  }

  CopyWith$Input$IntFilter<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$version, (e) => call(version: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get aiContext {
    final local$aiContext = _instance.aiContext;
    return local$aiContext == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$aiContext, (e) => call(aiContext: e));
  }

  CopyWith$Input$StringFilter<TRes> get bodyMarkdown {
    final local$bodyMarkdown = _instance.bodyMarkdown;
    return local$bodyMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$bodyMarkdown, (e) => call(bodyMarkdown: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentPartFilter<
                          Input$ContentPartFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ContentPartFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ContentPartFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentPartFilter<
                          Input$ContentPartFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ContentPartFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ContentPartFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentPartFilter.stub(_then(_instance))
        : CopyWith$Input$ContentPartFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentPartFilter<TRes>
    implements CopyWith$Input$ContentPartFilter<TRes> {
  _CopyWithStubImpl$Input$ContentPartFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$IntFilter? version,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? aiContext,
    Input$StringFilter? bodyMarkdown,
    Input$IDFilter? nodeId,
    List<Input$ContentPartFilter>? and,
    List<Input$ContentPartFilter>? or,
    Input$ContentPartFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get body =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get version =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get aiContext =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get bodyMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentPartFilter<TRes> get not =>
      CopyWith$Input$ContentPartFilter.stub(_res);
}

class Input$ContentPartInsertInput {
  factory Input$ContentPartInsertInput({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  }) =>
      Input$ContentPartInsertInput._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (version != null) r'version': version,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (aiContext != null) r'aiContext': aiContext,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentPartInsertInput._(this._$data);

  factory Input$ContentPartInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('aiContext')) {
      final l$aiContext = data['aiContext'];
      result$data['aiContext'] = (l$aiContext as String?);
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = (l$bodyMarkdown as String?);
    }
    return Input$ContentPartInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  int? get version => (_$data['version'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get aiContext => (_$data['aiContext'] as String?);

  String? get bodyMarkdown => (_$data['bodyMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('aiContext')) {
      final l$aiContext = aiContext;
      result$data['aiContext'] = l$aiContext;
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$ContentPartInsertInput<Input$ContentPartInsertInput>
      get copyWith => CopyWith$Input$ContentPartInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$aiContext = aiContext;
    final lOther$aiContext = other.aiContext;
    if (_$data.containsKey('aiContext') !=
        other._$data.containsKey('aiContext')) {
      return false;
    }
    if (l$aiContext != lOther$aiContext) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$version = version;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$aiContext = aiContext;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('aiContext') ? l$aiContext : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartInsertInput<TRes> {
  factory CopyWith$Input$ContentPartInsertInput(
    Input$ContentPartInsertInput instance,
    TRes Function(Input$ContentPartInsertInput) then,
  ) = _CopyWithImpl$Input$ContentPartInsertInput;

  factory CopyWith$Input$ContentPartInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartInsertInput;

  TRes call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentPartInsertInput<TRes> {
  _CopyWithImpl$Input$ContentPartInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentPartInsertInput _instance;

  final TRes Function(Input$ContentPartInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? version = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? aiContext = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentPartInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (version != _undefined) 'version': (version as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (aiContext != _undefined) 'aiContext': (aiContext as String?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartInsertInput<TRes>
    implements CopyWith$Input$ContentPartInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentPartInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  }) =>
      _res;
}

class Input$ContentPartOrderBy {
  factory Input$ContentPartOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? aiContext,
    Enum$OrderByDirection? bodyMarkdown,
  }) =>
      Input$ContentPartOrderBy._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (version != null) r'version': version,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (aiContext != null) r'aiContext': aiContext,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentPartOrderBy._(this._$data);

  factory Input$ContentPartOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentTypeId as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : fromJson$Enum$OrderByDirection((l$body as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderByDirection((l$version as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('aiContext')) {
      final l$aiContext = data['aiContext'];
      result$data['aiContext'] = l$aiContext == null
          ? null
          : fromJson$Enum$OrderByDirection((l$aiContext as String));
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection((l$bodyMarkdown as String));
    }
    return Input$ContentPartOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentTypeId =>
      (_$data['contentTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get body => (_$data['body'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get version =>
      (_$data['version'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get aiContext =>
      (_$data['aiContext'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get bodyMarkdown =>
      (_$data['bodyMarkdown'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentTypeId);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] =
          l$body == null ? null : toJson$Enum$OrderByDirection(l$body);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderByDirection(l$version);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('aiContext')) {
      final l$aiContext = aiContext;
      result$data['aiContext'] = l$aiContext == null
          ? null
          : toJson$Enum$OrderByDirection(l$aiContext);
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$bodyMarkdown);
    }
    return result$data;
  }

  CopyWith$Input$ContentPartOrderBy<Input$ContentPartOrderBy> get copyWith =>
      CopyWith$Input$ContentPartOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$aiContext = aiContext;
    final lOther$aiContext = other.aiContext;
    if (_$data.containsKey('aiContext') !=
        other._$data.containsKey('aiContext')) {
      return false;
    }
    if (l$aiContext != lOther$aiContext) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$version = version;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$aiContext = aiContext;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('aiContext') ? l$aiContext : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartOrderBy<TRes> {
  factory CopyWith$Input$ContentPartOrderBy(
    Input$ContentPartOrderBy instance,
    TRes Function(Input$ContentPartOrderBy) then,
  ) = _CopyWithImpl$Input$ContentPartOrderBy;

  factory CopyWith$Input$ContentPartOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? aiContext,
    Enum$OrderByDirection? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentPartOrderBy<TRes> {
  _CopyWithImpl$Input$ContentPartOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentPartOrderBy _instance;

  final TRes Function(Input$ContentPartOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? version = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? aiContext = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentPartOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (body != _undefined) 'body': (body as Enum$OrderByDirection?),
        if (version != _undefined)
          'version': (version as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (aiContext != _undefined)
          'aiContext': (aiContext as Enum$OrderByDirection?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartOrderBy<TRes>
    implements CopyWith$Input$ContentPartOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentPartOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? version,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? aiContext,
    Enum$OrderByDirection? bodyMarkdown,
  }) =>
      _res;
}

class Input$ContentPartUpdateInput {
  factory Input$ContentPartUpdateInput({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  }) =>
      Input$ContentPartUpdateInput._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (version != null) r'version': version,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (aiContext != null) r'aiContext': aiContext,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentPartUpdateInput._(this._$data);

  factory Input$ContentPartUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('aiContext')) {
      final l$aiContext = data['aiContext'];
      result$data['aiContext'] = (l$aiContext as String?);
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = (l$bodyMarkdown as String?);
    }
    return Input$ContentPartUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  int? get version => (_$data['version'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get aiContext => (_$data['aiContext'] as String?);

  String? get bodyMarkdown => (_$data['bodyMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('aiContext')) {
      final l$aiContext = aiContext;
      result$data['aiContext'] = l$aiContext;
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$ContentPartUpdateInput<Input$ContentPartUpdateInput>
      get copyWith => CopyWith$Input$ContentPartUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentPartUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$aiContext = aiContext;
    final lOther$aiContext = other.aiContext;
    if (_$data.containsKey('aiContext') !=
        other._$data.containsKey('aiContext')) {
      return false;
    }
    if (l$aiContext != lOther$aiContext) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$version = version;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$aiContext = aiContext;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('aiContext') ? l$aiContext : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentPartUpdateInput<TRes> {
  factory CopyWith$Input$ContentPartUpdateInput(
    Input$ContentPartUpdateInput instance,
    TRes Function(Input$ContentPartUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentPartUpdateInput;

  factory CopyWith$Input$ContentPartUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentPartUpdateInput;

  TRes call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentPartUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentPartUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentPartUpdateInput _instance;

  final TRes Function(Input$ContentPartUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? version = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? aiContext = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentPartUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (version != _undefined) 'version': (version as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (aiContext != _undefined) 'aiContext': (aiContext as String?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentPartUpdateInput<TRes>
    implements CopyWith$Input$ContentPartUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentPartUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    int? version,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? aiContext,
    String? bodyMarkdown,
  }) =>
      _res;
}

class Input$ContentTemplateFilter {
  factory Input$ContentTemplateFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isActive,
    Input$DatetimeFilter? activatedAt,
    Input$DatetimeFilter? deactivatedAt,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateFilter>? and,
    List<Input$ContentTemplateFilter>? or,
    Input$ContentTemplateFilter? not,
  }) =>
      Input$ContentTemplateFilter._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isActive != null) r'isActive': isActive,
        if (activatedAt != null) r'activatedAt': activatedAt,
        if (deactivatedAt != null) r'deactivatedAt': deactivatedAt,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (ownerId != null) r'ownerId': ownerId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentTemplateFilter._(this._$data);

  factory Input$ContentTemplateFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : Input$StringFilter.fromJson((l$body as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : Input$BooleanFilter.fromJson((l$isActive as Map<String, dynamic>));
    }
    if (data.containsKey('activatedAt')) {
      final l$activatedAt = data['activatedAt'];
      result$data['activatedAt'] = l$activatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$activatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = data['deactivatedAt'];
      result$data['deactivatedAt'] = l$deactivatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$deactivatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = l$isArchived == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isArchived as Map<String, dynamic>));
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$archivedAt as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ContentTemplateFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ContentTemplateFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentTemplateFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ContentTemplateFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentTypeId =>
      (_$data['contentTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get body => (_$data['body'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$BooleanFilter? get isActive =>
      (_$data['isActive'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get activatedAt =>
      (_$data['activatedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get deactivatedAt =>
      (_$data['deactivatedAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isArchived =>
      (_$data['isArchived'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get archivedAt =>
      (_$data['archivedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentTemplateFilter>? get and =>
      (_$data['and'] as List<Input$ContentTemplateFilter>?);

  List<Input$ContentTemplateFilter>? get or =>
      (_$data['or'] as List<Input$ContentTemplateFilter>?);

  Input$ContentTemplateFilter? get not =>
      (_$data['not'] as Input$ContentTemplateFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive?.toJson();
    }
    if (_$data.containsKey('activatedAt')) {
      final l$activatedAt = activatedAt;
      result$data['activatedAt'] = l$activatedAt?.toJson();
    }
    if (_$data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = deactivatedAt;
      result$data['deactivatedAt'] = l$deactivatedAt?.toJson();
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived?.toJson();
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateFilter<Input$ContentTemplateFilter>
      get copyWith => CopyWith$Input$ContentTemplateFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$activatedAt = activatedAt;
    final lOther$activatedAt = other.activatedAt;
    if (_$data.containsKey('activatedAt') !=
        other._$data.containsKey('activatedAt')) {
      return false;
    }
    if (l$activatedAt != lOther$activatedAt) {
      return false;
    }
    final l$deactivatedAt = deactivatedAt;
    final lOther$deactivatedAt = other.deactivatedAt;
    if (_$data.containsKey('deactivatedAt') !=
        other._$data.containsKey('deactivatedAt')) {
      return false;
    }
    if (l$deactivatedAt != lOther$deactivatedAt) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$isActive = isActive;
    final l$activatedAt = activatedAt;
    final l$deactivatedAt = deactivatedAt;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$ownerId = ownerId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('activatedAt') ? l$activatedAt : const {},
      _$data.containsKey('deactivatedAt') ? l$deactivatedAt : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateFilter<TRes> {
  factory CopyWith$Input$ContentTemplateFilter(
    Input$ContentTemplateFilter instance,
    TRes Function(Input$ContentTemplateFilter) then,
  ) = _CopyWithImpl$Input$ContentTemplateFilter;

  factory CopyWith$Input$ContentTemplateFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isActive,
    Input$DatetimeFilter? activatedAt,
    Input$DatetimeFilter? deactivatedAt,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateFilter>? and,
    List<Input$ContentTemplateFilter>? or,
    Input$ContentTemplateFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get contentTypeId;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get body;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$BooleanFilter<TRes> get isActive;
  CopyWith$Input$DatetimeFilter<TRes> get activatedAt;
  CopyWith$Input$DatetimeFilter<TRes> get deactivatedAt;
  CopyWith$Input$BooleanFilter<TRes> get isArchived;
  CopyWith$Input$DatetimeFilter<TRes> get archivedAt;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateFilter<
                      Input$ContentTemplateFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateFilter<
                      Input$ContentTemplateFilter>>?)
          _fn);
  CopyWith$Input$ContentTemplateFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentTemplateFilter<TRes>
    implements CopyWith$Input$ContentTemplateFilter<TRes> {
  _CopyWithImpl$Input$ContentTemplateFilter(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateFilter _instance;

  final TRes Function(Input$ContentTemplateFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isActive = _undefined,
    Object? activatedAt = _undefined,
    Object? deactivatedAt = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? ownerId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentTemplateFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Input$UUIDFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (body != _undefined) 'body': (body as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (isActive != _undefined)
          'isActive': (isActive as Input$BooleanFilter?),
        if (activatedAt != _undefined)
          'activatedAt': (activatedAt as Input$DatetimeFilter?),
        if (deactivatedAt != _undefined)
          'deactivatedAt': (deactivatedAt as Input$DatetimeFilter?),
        if (isArchived != _undefined)
          'isArchived': (isArchived as Input$BooleanFilter?),
        if (archivedAt != _undefined)
          'archivedAt': (archivedAt as Input$DatetimeFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ContentTemplateFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ContentTemplateFilter>?),
        if (not != _undefined) 'not': (not as Input$ContentTemplateFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId {
    final local$contentTypeId = _instance.contentTypeId;
    return local$contentTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentTypeId, (e) => call(contentTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get body {
    final local$body = _instance.body;
    return local$body == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$body, (e) => call(body: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isActive {
    final local$isActive = _instance.isActive;
    return local$isActive == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isActive, (e) => call(isActive: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get activatedAt {
    final local$activatedAt = _instance.activatedAt;
    return local$activatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$activatedAt, (e) => call(activatedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get deactivatedAt {
    final local$deactivatedAt = _instance.deactivatedAt;
    return local$deactivatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$deactivatedAt, (e) => call(deactivatedAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isArchived {
    final local$isArchived = _instance.isArchived;
    return local$isArchived == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isArchived, (e) => call(isArchived: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get archivedAt {
    final local$archivedAt = _instance.archivedAt;
    return local$archivedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$archivedAt, (e) => call(archivedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateFilter<
                          Input$ContentTemplateFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ContentTemplateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ContentTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateFilter<
                          Input$ContentTemplateFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ContentTemplateFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ContentTemplateFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentTemplateFilter.stub(_then(_instance))
        : CopyWith$Input$ContentTemplateFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentTemplateFilter<TRes>
    implements CopyWith$Input$ContentTemplateFilter<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentTypeId,
    Input$StringFilter? title,
    Input$StringFilter? body,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$BooleanFilter? isActive,
    Input$DatetimeFilter? activatedAt,
    Input$DatetimeFilter? deactivatedAt,
    Input$BooleanFilter? isArchived,
    Input$DatetimeFilter? archivedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateFilter>? and,
    List<Input$ContentTemplateFilter>? or,
    Input$ContentTemplateFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get body =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isActive =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get activatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get deactivatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isArchived =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get archivedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentTemplateFilter<TRes> get not =>
      CopyWith$Input$ContentTemplateFilter.stub(_res);
}

class Input$ContentTemplateInsertInput {
  factory Input$ContentTemplateInsertInput({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  }) =>
      Input$ContentTemplateInsertInput._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isActive != null) r'isActive': isActive,
        if (activatedAt != null) r'activatedAt': activatedAt,
        if (deactivatedAt != null) r'deactivatedAt': deactivatedAt,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$ContentTemplateInsertInput._(this._$data);

  factory Input$ContentTemplateInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('activatedAt')) {
      final l$activatedAt = data['activatedAt'];
      result$data['activatedAt'] = l$activatedAt == null
          ? null
          : DateTime.parse((l$activatedAt as String));
    }
    if (data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = data['deactivatedAt'];
      result$data['deactivatedAt'] = l$deactivatedAt == null
          ? null
          : DateTime.parse((l$deactivatedAt as String));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : DateTime.parse((l$archivedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    return Input$ContentTemplateInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  DateTime? get activatedAt => (_$data['activatedAt'] as DateTime?);

  DateTime? get deactivatedAt => (_$data['deactivatedAt'] as DateTime?);

  bool? get isArchived => (_$data['isArchived'] as bool?);

  DateTime? get archivedAt => (_$data['archivedAt'] as DateTime?);

  String? get ownerId => (_$data['ownerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('activatedAt')) {
      final l$activatedAt = activatedAt;
      result$data['activatedAt'] = l$activatedAt?.toIso8601String();
    }
    if (_$data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = deactivatedAt;
      result$data['deactivatedAt'] = l$deactivatedAt?.toIso8601String();
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toIso8601String();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateInsertInput<Input$ContentTemplateInsertInput>
      get copyWith => CopyWith$Input$ContentTemplateInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$activatedAt = activatedAt;
    final lOther$activatedAt = other.activatedAt;
    if (_$data.containsKey('activatedAt') !=
        other._$data.containsKey('activatedAt')) {
      return false;
    }
    if (l$activatedAt != lOther$activatedAt) {
      return false;
    }
    final l$deactivatedAt = deactivatedAt;
    final lOther$deactivatedAt = other.deactivatedAt;
    if (_$data.containsKey('deactivatedAt') !=
        other._$data.containsKey('deactivatedAt')) {
      return false;
    }
    if (l$deactivatedAt != lOther$deactivatedAt) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$updatedAt = updatedAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$isActive = isActive;
    final l$activatedAt = activatedAt;
    final l$deactivatedAt = deactivatedAt;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('activatedAt') ? l$activatedAt : const {},
      _$data.containsKey('deactivatedAt') ? l$deactivatedAt : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateInsertInput<TRes> {
  factory CopyWith$Input$ContentTemplateInsertInput(
    Input$ContentTemplateInsertInput instance,
    TRes Function(Input$ContentTemplateInsertInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateInsertInput;

  factory CopyWith$Input$ContentTemplateInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateInsertInput;

  TRes call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$ContentTemplateInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateInsertInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateInsertInput _instance;

  final TRes Function(Input$ContentTemplateInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? updatedAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isActive = _undefined,
    Object? activatedAt = _undefined,
    Object? deactivatedAt = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$ContentTemplateInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (activatedAt != _undefined)
          'activatedAt': (activatedAt as DateTime?),
        if (deactivatedAt != _undefined)
          'deactivatedAt': (deactivatedAt as DateTime?),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (archivedAt != _undefined) 'archivedAt': (archivedAt as DateTime?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  }) =>
      _res;
}

class Input$ContentTemplateOrderBy {
  factory Input$ContentTemplateOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isActive,
    Enum$OrderByDirection? activatedAt,
    Enum$OrderByDirection? deactivatedAt,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? ownerId,
  }) =>
      Input$ContentTemplateOrderBy._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isActive != null) r'isActive': isActive,
        if (activatedAt != null) r'activatedAt': activatedAt,
        if (deactivatedAt != null) r'deactivatedAt': deactivatedAt,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$ContentTemplateOrderBy._(this._$data);

  factory Input$ContentTemplateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentTypeId as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = l$body == null
          ? null
          : fromJson$Enum$OrderByDirection((l$body as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isActive as String));
    }
    if (data.containsKey('activatedAt')) {
      final l$activatedAt = data['activatedAt'];
      result$data['activatedAt'] = l$activatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$activatedAt as String));
    }
    if (data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = data['deactivatedAt'];
      result$data['deactivatedAt'] = l$deactivatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$deactivatedAt as String));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = l$isArchived == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isArchived as String));
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$archivedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    return Input$ContentTemplateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentTypeId =>
      (_$data['contentTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get body => (_$data['body'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isActive =>
      (_$data['isActive'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get activatedAt =>
      (_$data['activatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get deactivatedAt =>
      (_$data['deactivatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isArchived =>
      (_$data['isArchived'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get archivedAt =>
      (_$data['archivedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentTypeId);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] =
          l$body == null ? null : toJson$Enum$OrderByDirection(l$body);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] =
          l$isActive == null ? null : toJson$Enum$OrderByDirection(l$isActive);
    }
    if (_$data.containsKey('activatedAt')) {
      final l$activatedAt = activatedAt;
      result$data['activatedAt'] = l$activatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$activatedAt);
    }
    if (_$data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = deactivatedAt;
      result$data['deactivatedAt'] = l$deactivatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$deactivatedAt);
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived == null
          ? null
          : toJson$Enum$OrderByDirection(l$isArchived);
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$archivedAt);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateOrderBy<Input$ContentTemplateOrderBy>
      get copyWith => CopyWith$Input$ContentTemplateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$activatedAt = activatedAt;
    final lOther$activatedAt = other.activatedAt;
    if (_$data.containsKey('activatedAt') !=
        other._$data.containsKey('activatedAt')) {
      return false;
    }
    if (l$activatedAt != lOther$activatedAt) {
      return false;
    }
    final l$deactivatedAt = deactivatedAt;
    final lOther$deactivatedAt = other.deactivatedAt;
    if (_$data.containsKey('deactivatedAt') !=
        other._$data.containsKey('deactivatedAt')) {
      return false;
    }
    if (l$deactivatedAt != lOther$deactivatedAt) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$isActive = isActive;
    final l$activatedAt = activatedAt;
    final l$deactivatedAt = deactivatedAt;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('activatedAt') ? l$activatedAt : const {},
      _$data.containsKey('deactivatedAt') ? l$deactivatedAt : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateOrderBy<TRes> {
  factory CopyWith$Input$ContentTemplateOrderBy(
    Input$ContentTemplateOrderBy instance,
    TRes Function(Input$ContentTemplateOrderBy) then,
  ) = _CopyWithImpl$Input$ContentTemplateOrderBy;

  factory CopyWith$Input$ContentTemplateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isActive,
    Enum$OrderByDirection? activatedAt,
    Enum$OrderByDirection? deactivatedAt,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? ownerId,
  });
}

class _CopyWithImpl$Input$ContentTemplateOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateOrderBy<TRes> {
  _CopyWithImpl$Input$ContentTemplateOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateOrderBy _instance;

  final TRes Function(Input$ContentTemplateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isActive = _undefined,
    Object? activatedAt = _undefined,
    Object? deactivatedAt = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$ContentTemplateOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (body != _undefined) 'body': (body as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
        if (isActive != _undefined)
          'isActive': (isActive as Enum$OrderByDirection?),
        if (activatedAt != _undefined)
          'activatedAt': (activatedAt as Enum$OrderByDirection?),
        if (deactivatedAt != _undefined)
          'deactivatedAt': (deactivatedAt as Enum$OrderByDirection?),
        if (isArchived != _undefined)
          'isArchived': (isArchived as Enum$OrderByDirection?),
        if (archivedAt != _undefined)
          'archivedAt': (archivedAt as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? body,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? isActive,
    Enum$OrderByDirection? activatedAt,
    Enum$OrderByDirection? deactivatedAt,
    Enum$OrderByDirection? isArchived,
    Enum$OrderByDirection? archivedAt,
    Enum$OrderByDirection? ownerId,
  }) =>
      _res;
}

class Input$ContentTemplateUpdateInput {
  factory Input$ContentTemplateUpdateInput({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  }) =>
      Input$ContentTemplateUpdateInput._({
        if (id != null) r'id': id,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (isActive != null) r'isActive': isActive,
        if (activatedAt != null) r'activatedAt': activatedAt,
        if (deactivatedAt != null) r'deactivatedAt': deactivatedAt,
        if (isArchived != null) r'isArchived': isArchived,
        if (archivedAt != null) r'archivedAt': archivedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$ContentTemplateUpdateInput._(this._$data);

  factory Input$ContentTemplateUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('activatedAt')) {
      final l$activatedAt = data['activatedAt'];
      result$data['activatedAt'] = l$activatedAt == null
          ? null
          : DateTime.parse((l$activatedAt as String));
    }
    if (data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = data['deactivatedAt'];
      result$data['deactivatedAt'] = l$deactivatedAt == null
          ? null
          : DateTime.parse((l$deactivatedAt as String));
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('archivedAt')) {
      final l$archivedAt = data['archivedAt'];
      result$data['archivedAt'] = l$archivedAt == null
          ? null
          : DateTime.parse((l$archivedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    return Input$ContentTemplateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  DateTime? get activatedAt => (_$data['activatedAt'] as DateTime?);

  DateTime? get deactivatedAt => (_$data['deactivatedAt'] as DateTime?);

  bool? get isArchived => (_$data['isArchived'] as bool?);

  DateTime? get archivedAt => (_$data['archivedAt'] as DateTime?);

  String? get ownerId => (_$data['ownerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('activatedAt')) {
      final l$activatedAt = activatedAt;
      result$data['activatedAt'] = l$activatedAt?.toIso8601String();
    }
    if (_$data.containsKey('deactivatedAt')) {
      final l$deactivatedAt = deactivatedAt;
      result$data['deactivatedAt'] = l$deactivatedAt?.toIso8601String();
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('archivedAt')) {
      final l$archivedAt = archivedAt;
      result$data['archivedAt'] = l$archivedAt?.toIso8601String();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateUpdateInput<Input$ContentTemplateUpdateInput>
      get copyWith => CopyWith$Input$ContentTemplateUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$activatedAt = activatedAt;
    final lOther$activatedAt = other.activatedAt;
    if (_$data.containsKey('activatedAt') !=
        other._$data.containsKey('activatedAt')) {
      return false;
    }
    if (l$activatedAt != lOther$activatedAt) {
      return false;
    }
    final l$deactivatedAt = deactivatedAt;
    final lOther$deactivatedAt = other.deactivatedAt;
    if (_$data.containsKey('deactivatedAt') !=
        other._$data.containsKey('deactivatedAt')) {
      return false;
    }
    if (l$deactivatedAt != lOther$deactivatedAt) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$archivedAt = archivedAt;
    final lOther$archivedAt = other.archivedAt;
    if (_$data.containsKey('archivedAt') !=
        other._$data.containsKey('archivedAt')) {
      return false;
    }
    if (l$archivedAt != lOther$archivedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentTypeId = contentTypeId;
    final l$title = title;
    final l$body = body;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$updatedAt = updatedAt;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$isActive = isActive;
    final l$activatedAt = activatedAt;
    final l$deactivatedAt = deactivatedAt;
    final l$isArchived = isArchived;
    final l$archivedAt = archivedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('activatedAt') ? l$activatedAt : const {},
      _$data.containsKey('deactivatedAt') ? l$deactivatedAt : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('archivedAt') ? l$archivedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateUpdateInput<TRes> {
  factory CopyWith$Input$ContentTemplateUpdateInput(
    Input$ContentTemplateUpdateInput instance,
    TRes Function(Input$ContentTemplateUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateUpdateInput;

  factory CopyWith$Input$ContentTemplateUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateUpdateInput;

  TRes call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$ContentTemplateUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateUpdateInput _instance;

  final TRes Function(Input$ContentTemplateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentTypeId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? updatedAt = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? isActive = _undefined,
    Object? activatedAt = _undefined,
    Object? deactivatedAt = _undefined,
    Object? isArchived = _undefined,
    Object? archivedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$ContentTemplateUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (activatedAt != _undefined)
          'activatedAt': (activatedAt as DateTime?),
        if (deactivatedAt != _undefined)
          'deactivatedAt': (deactivatedAt as DateTime?),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (archivedAt != _undefined) 'archivedAt': (archivedAt as DateTime?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentTypeId,
    String? title,
    String? body,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? iconUrl,
    String? coverUrl,
    bool? isActive,
    DateTime? activatedAt,
    DateTime? deactivatedAt,
    bool? isArchived,
    DateTime? archivedAt,
    String? ownerId,
  }) =>
      _res;
}

class Input$ContentTemplateVariableFilter {
  factory Input$ContentTemplateVariableFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableTypeId,
    Input$UUIDFilter? contentTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableFilter>? and,
    List<Input$ContentTemplateVariableFilter>? or,
    Input$ContentTemplateVariableFilter? not,
  }) =>
      Input$ContentTemplateVariableFilter._({
        if (id != null) r'id': id,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentTemplateVariableFilter._(this._$data);

  factory Input$ContentTemplateVariableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$templateVariableTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$contentTemplateId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ContentTemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ContentTemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentTemplateVariableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ContentTemplateVariableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentTemplateId =>
      (_$data['contentTemplateId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentTemplateVariableFilter>? get and =>
      (_$data['and'] as List<Input$ContentTemplateVariableFilter>?);

  List<Input$ContentTemplateVariableFilter>? get or =>
      (_$data['or'] as List<Input$ContentTemplateVariableFilter>?);

  Input$ContentTemplateVariableFilter? get not =>
      (_$data['not'] as Input$ContentTemplateVariableFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] =
          l$templateVariableTypeId?.toJson();
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableFilter<
          Input$ContentTemplateVariableFilter>
      get copyWith => CopyWith$Input$ContentTemplateVariableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$contentTemplateId = contentTemplateId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableFilter<TRes> {
  factory CopyWith$Input$ContentTemplateVariableFilter(
    Input$ContentTemplateVariableFilter instance,
    TRes Function(Input$ContentTemplateVariableFilter) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableFilter;

  factory CopyWith$Input$ContentTemplateVariableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableTypeId,
    Input$UUIDFilter? contentTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableFilter>? and,
    List<Input$ContentTemplateVariableFilter>? or,
    Input$ContentTemplateVariableFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId;
  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentTemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateVariableFilter<
                      Input$ContentTemplateVariableFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentTemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateVariableFilter<
                      Input$ContentTemplateVariableFilter>>?)
          _fn);
  CopyWith$Input$ContentTemplateVariableFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentTemplateVariableFilter<TRes>
    implements CopyWith$Input$ContentTemplateVariableFilter<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableFilter(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableFilter _instance;

  final TRes Function(Input$ContentTemplateVariableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? contentTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId':
              (templateVariableTypeId as Input$UUIDFilter?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ContentTemplateVariableFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$ContentTemplateVariableFilter>?),
        if (not != _undefined)
          'not': (not as Input$ContentTemplateVariableFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId {
    final local$templateVariableTypeId = _instance.templateVariableTypeId;
    return local$templateVariableTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$templateVariableTypeId,
            (e) => call(templateVariableTypeId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId {
    final local$contentTemplateId = _instance.contentTemplateId;
    return local$contentTemplateId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$contentTemplateId, (e) => call(contentTemplateId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentTemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateVariableFilter<
                          Input$ContentTemplateVariableFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ContentTemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ContentTemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateVariableFilter<
                          Input$ContentTemplateVariableFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$ContentTemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ContentTemplateVariableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentTemplateVariableFilter.stub(_then(_instance))
        : CopyWith$Input$ContentTemplateVariableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentTemplateVariableFilter<TRes>
    implements CopyWith$Input$ContentTemplateVariableFilter<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableTypeId,
    Input$UUIDFilter? contentTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableFilter>? and,
    List<Input$ContentTemplateVariableFilter>? or,
    Input$ContentTemplateVariableFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentTemplateId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentTemplateVariableFilter<TRes> get not =>
      CopyWith$Input$ContentTemplateVariableFilter.stub(_res);
}

class Input$ContentTemplateVariableInsertInput {
  factory Input$ContentTemplateVariableInsertInput({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$ContentTemplateVariableInsertInput._({
        if (id != null) r'id': id,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$ContentTemplateVariableInsertInput._(this._$data);

  factory Input$ContentTemplateVariableInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] =
          (l$templateVariableTypeId as String?);
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = (l$contentTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$ContentTemplateVariableInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as String?);

  String? get contentTemplateId => (_$data['contentTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId;
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableInsertInput<
          Input$ContentTemplateVariableInsertInput>
      get copyWith => CopyWith$Input$ContentTemplateVariableInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$contentTemplateId = contentTemplateId;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableInsertInput<TRes> {
  factory CopyWith$Input$ContentTemplateVariableInsertInput(
    Input$ContentTemplateVariableInsertInput instance,
    TRes Function(Input$ContentTemplateVariableInsertInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableInsertInput;

  factory CopyWith$Input$ContentTemplateVariableInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableInsertInput;

  TRes call({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableInsertInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableInsertInput _instance;

  final TRes Function(Input$ContentTemplateVariableInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? contentTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId': (templateVariableTypeId as String?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$ContentTemplateVariableOrderBy {
  factory Input$ContentTemplateVariableOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ContentTemplateVariableOrderBy._({
        if (id != null) r'id': id,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ContentTemplateVariableOrderBy._(this._$data);

  factory Input$ContentTemplateVariableOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$templateVariableTypeId as String));
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentTemplateId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ContentTemplateVariableOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentTemplateId =>
      (_$data['contentTemplateId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$templateVariableTypeId);
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentTemplateId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableOrderBy<
          Input$ContentTemplateVariableOrderBy>
      get copyWith => CopyWith$Input$ContentTemplateVariableOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$contentTemplateId = contentTemplateId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableOrderBy<TRes> {
  factory CopyWith$Input$ContentTemplateVariableOrderBy(
    Input$ContentTemplateVariableOrderBy instance,
    TRes Function(Input$ContentTemplateVariableOrderBy) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableOrderBy;

  factory CopyWith$Input$ContentTemplateVariableOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateVariableOrderBy<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableOrderBy _instance;

  final TRes Function(Input$ContentTemplateVariableOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? contentTemplateId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId':
              (templateVariableTypeId as Enum$OrderByDirection?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateVariableOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? contentTemplateId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ContentTemplateVariableUpdateInput {
  factory Input$ContentTemplateVariableUpdateInput({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$ContentTemplateVariableUpdateInput._({
        if (id != null) r'id': id,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$ContentTemplateVariableUpdateInput._(this._$data);

  factory Input$ContentTemplateVariableUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] =
          (l$templateVariableTypeId as String?);
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = (l$contentTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$ContentTemplateVariableUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as String?);

  String? get contentTemplateId => (_$data['contentTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId;
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableUpdateInput<
          Input$ContentTemplateVariableUpdateInput>
      get copyWith => CopyWith$Input$ContentTemplateVariableUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$contentTemplateId = contentTemplateId;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableUpdateInput<TRes> {
  factory CopyWith$Input$ContentTemplateVariableUpdateInput(
    Input$ContentTemplateVariableUpdateInput instance,
    TRes Function(Input$ContentTemplateVariableUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableUpdateInput;

  factory CopyWith$Input$ContentTemplateVariableUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableUpdateInput;

  TRes call({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableUpdateInput _instance;

  final TRes Function(Input$ContentTemplateVariableUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? contentTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId': (templateVariableTypeId as String?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? templateVariableTypeId,
    String? contentTemplateId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$ContentTemplateVariableValueFilter {
  factory Input$ContentTemplateVariableValueFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$StringFilter? valueString,
    Input$BigFloatFilter? valueNumber,
    Input$DatetimeFilter? valueDate,
    Input$BooleanFilter? valueBool,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableValueFilter>? and,
    List<Input$ContentTemplateVariableValueFilter>? or,
    Input$ContentTemplateVariableValueFilter? not,
  }) =>
      Input$ContentTemplateVariableValueFilter._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (valueString != null) r'valueString': valueString,
        if (valueNumber != null) r'valueNumber': valueNumber,
        if (valueDate != null) r'valueDate': valueDate,
        if (valueBool != null) r'valueBool': valueBool,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentTemplateVariableValueFilter._(this._$data);

  factory Input$ContentTemplateVariableValueFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = l$contentId == null
          ? null
          : Input$UUIDFilter.fromJson((l$contentId as Map<String, dynamic>));
    }
    if (data.containsKey('valueString')) {
      final l$valueString = data['valueString'];
      result$data['valueString'] = l$valueString == null
          ? null
          : Input$StringFilter.fromJson(
              (l$valueString as Map<String, dynamic>));
    }
    if (data.containsKey('valueNumber')) {
      final l$valueNumber = data['valueNumber'];
      result$data['valueNumber'] = l$valueNumber == null
          ? null
          : Input$BigFloatFilter.fromJson(
              (l$valueNumber as Map<String, dynamic>));
    }
    if (data.containsKey('valueDate')) {
      final l$valueDate = data['valueDate'];
      result$data['valueDate'] = l$valueDate == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$valueDate as Map<String, dynamic>));
    }
    if (data.containsKey('valueBool')) {
      final l$valueBool = data['valueBool'];
      result$data['valueBool'] = l$valueBool == null
          ? null
          : Input$BooleanFilter.fromJson((l$valueBool as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ContentTemplateVariableValueFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ContentTemplateVariableValueFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentTemplateVariableValueFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$ContentTemplateVariableValueFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get contentId => (_$data['contentId'] as Input$UUIDFilter?);

  Input$StringFilter? get valueString =>
      (_$data['valueString'] as Input$StringFilter?);

  Input$BigFloatFilter? get valueNumber =>
      (_$data['valueNumber'] as Input$BigFloatFilter?);

  Input$DatetimeFilter? get valueDate =>
      (_$data['valueDate'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get valueBool =>
      (_$data['valueBool'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentTemplateVariableValueFilter>? get and =>
      (_$data['and'] as List<Input$ContentTemplateVariableValueFilter>?);

  List<Input$ContentTemplateVariableValueFilter>? get or =>
      (_$data['or'] as List<Input$ContentTemplateVariableValueFilter>?);

  Input$ContentTemplateVariableValueFilter? get not =>
      (_$data['not'] as Input$ContentTemplateVariableValueFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId?.toJson();
    }
    if (_$data.containsKey('valueString')) {
      final l$valueString = valueString;
      result$data['valueString'] = l$valueString?.toJson();
    }
    if (_$data.containsKey('valueNumber')) {
      final l$valueNumber = valueNumber;
      result$data['valueNumber'] = l$valueNumber?.toJson();
    }
    if (_$data.containsKey('valueDate')) {
      final l$valueDate = valueDate;
      result$data['valueDate'] = l$valueDate?.toJson();
    }
    if (_$data.containsKey('valueBool')) {
      final l$valueBool = valueBool;
      result$data['valueBool'] = l$valueBool?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableValueFilter<
          Input$ContentTemplateVariableValueFilter>
      get copyWith => CopyWith$Input$ContentTemplateVariableValueFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableValueFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$valueString = valueString;
    final lOther$valueString = other.valueString;
    if (_$data.containsKey('valueString') !=
        other._$data.containsKey('valueString')) {
      return false;
    }
    if (l$valueString != lOther$valueString) {
      return false;
    }
    final l$valueNumber = valueNumber;
    final lOther$valueNumber = other.valueNumber;
    if (_$data.containsKey('valueNumber') !=
        other._$data.containsKey('valueNumber')) {
      return false;
    }
    if (l$valueNumber != lOther$valueNumber) {
      return false;
    }
    final l$valueDate = valueDate;
    final lOther$valueDate = other.valueDate;
    if (_$data.containsKey('valueDate') !=
        other._$data.containsKey('valueDate')) {
      return false;
    }
    if (l$valueDate != lOther$valueDate) {
      return false;
    }
    final l$valueBool = valueBool;
    final lOther$valueBool = other.valueBool;
    if (_$data.containsKey('valueBool') !=
        other._$data.containsKey('valueBool')) {
      return false;
    }
    if (l$valueBool != lOther$valueBool) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$valueString = valueString;
    final l$valueNumber = valueNumber;
    final l$valueDate = valueDate;
    final l$valueBool = valueBool;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('valueString') ? l$valueString : const {},
      _$data.containsKey('valueNumber') ? l$valueNumber : const {},
      _$data.containsKey('valueDate') ? l$valueDate : const {},
      _$data.containsKey('valueBool') ? l$valueBool : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableValueFilter<TRes> {
  factory CopyWith$Input$ContentTemplateVariableValueFilter(
    Input$ContentTemplateVariableValueFilter instance,
    TRes Function(Input$ContentTemplateVariableValueFilter) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableValueFilter;

  factory CopyWith$Input$ContentTemplateVariableValueFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableValueFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$StringFilter? valueString,
    Input$BigFloatFilter? valueNumber,
    Input$DatetimeFilter? valueDate,
    Input$BooleanFilter? valueBool,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableValueFilter>? and,
    List<Input$ContentTemplateVariableValueFilter>? or,
    Input$ContentTemplateVariableValueFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get contentId;
  CopyWith$Input$StringFilter<TRes> get valueString;
  CopyWith$Input$BigFloatFilter<TRes> get valueNumber;
  CopyWith$Input$DatetimeFilter<TRes> get valueDate;
  CopyWith$Input$BooleanFilter<TRes> get valueBool;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentTemplateVariableValueFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateVariableValueFilter<
                      Input$ContentTemplateVariableValueFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentTemplateVariableValueFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTemplateVariableValueFilter<
                      Input$ContentTemplateVariableValueFilter>>?)
          _fn);
  CopyWith$Input$ContentTemplateVariableValueFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentTemplateVariableValueFilter<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueFilter<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableValueFilter(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableValueFilter _instance;

  final TRes Function(Input$ContentTemplateVariableValueFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? valueString = _undefined,
    Object? valueNumber = _undefined,
    Object? valueDate = _undefined,
    Object? valueBool = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableValueFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (contentId != _undefined)
          'contentId': (contentId as Input$UUIDFilter?),
        if (valueString != _undefined)
          'valueString': (valueString as Input$StringFilter?),
        if (valueNumber != _undefined)
          'valueNumber': (valueNumber as Input$BigFloatFilter?),
        if (valueDate != _undefined)
          'valueDate': (valueDate as Input$DatetimeFilter?),
        if (valueBool != _undefined)
          'valueBool': (valueBool as Input$BooleanFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$ContentTemplateVariableValueFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$ContentTemplateVariableValueFilter>?),
        if (not != _undefined)
          'not': (not as Input$ContentTemplateVariableValueFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get contentId {
    final local$contentId = _instance.contentId;
    return local$contentId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$contentId, (e) => call(contentId: e));
  }

  CopyWith$Input$StringFilter<TRes> get valueString {
    final local$valueString = _instance.valueString;
    return local$valueString == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$valueString, (e) => call(valueString: e));
  }

  CopyWith$Input$BigFloatFilter<TRes> get valueNumber {
    final local$valueNumber = _instance.valueNumber;
    return local$valueNumber == null
        ? CopyWith$Input$BigFloatFilter.stub(_then(_instance))
        : CopyWith$Input$BigFloatFilter(
            local$valueNumber, (e) => call(valueNumber: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get valueDate {
    final local$valueDate = _instance.valueDate;
    return local$valueDate == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$valueDate, (e) => call(valueDate: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get valueBool {
    final local$valueBool = _instance.valueBool;
    return local$valueBool == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$valueBool, (e) => call(valueBool: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentTemplateVariableValueFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateVariableValueFilter<
                          Input$ContentTemplateVariableValueFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ContentTemplateVariableValueFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$ContentTemplateVariableValueFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTemplateVariableValueFilter<
                          Input$ContentTemplateVariableValueFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$ContentTemplateVariableValueFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ContentTemplateVariableValueFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentTemplateVariableValueFilter.stub(
            _then(_instance))
        : CopyWith$Input$ContentTemplateVariableValueFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentTemplateVariableValueFilter<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueFilter<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableValueFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? contentId,
    Input$StringFilter? valueString,
    Input$BigFloatFilter? valueNumber,
    Input$DatetimeFilter? valueDate,
    Input$BooleanFilter? valueBool,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ContentTemplateVariableValueFilter>? and,
    List<Input$ContentTemplateVariableValueFilter>? or,
    Input$ContentTemplateVariableValueFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get contentId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get valueString =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$BigFloatFilter<TRes> get valueNumber =>
      CopyWith$Input$BigFloatFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get valueDate =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get valueBool =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentTemplateVariableValueFilter<TRes> get not =>
      CopyWith$Input$ContentTemplateVariableValueFilter.stub(_res);
}

class Input$ContentTemplateVariableValueInsertInput {
  factory Input$ContentTemplateVariableValueInsertInput({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$ContentTemplateVariableValueInsertInput._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (data != null) r'data': data,
        if (valueString != null) r'valueString': valueString,
        if (valueNumber != null) r'valueNumber': valueNumber,
        if (valueDate != null) r'valueDate': valueDate,
        if (valueBool != null) r'valueBool': valueBool,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ContentTemplateVariableValueInsertInput._(this._$data);

  factory Input$ContentTemplateVariableValueInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('valueString')) {
      final l$valueString = data['valueString'];
      result$data['valueString'] = (l$valueString as String?);
    }
    if (data.containsKey('valueNumber')) {
      final l$valueNumber = data['valueNumber'];
      result$data['valueNumber'] = (l$valueNumber as num?)?.toDouble();
    }
    if (data.containsKey('valueDate')) {
      final l$valueDate = data['valueDate'];
      result$data['valueDate'] =
          l$valueDate == null ? null : DateTime.parse((l$valueDate as String));
    }
    if (data.containsKey('valueBool')) {
      final l$valueBool = data['valueBool'];
      result$data['valueBool'] = (l$valueBool as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$ContentTemplateVariableValueInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentId => (_$data['contentId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get valueString => (_$data['valueString'] as String?);

  double? get valueNumber => (_$data['valueNumber'] as double?);

  DateTime? get valueDate => (_$data['valueDate'] as DateTime?);

  bool? get valueBool => (_$data['valueBool'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('valueString')) {
      final l$valueString = valueString;
      result$data['valueString'] = l$valueString;
    }
    if (_$data.containsKey('valueNumber')) {
      final l$valueNumber = valueNumber;
      result$data['valueNumber'] = l$valueNumber;
    }
    if (_$data.containsKey('valueDate')) {
      final l$valueDate = valueDate;
      result$data['valueDate'] = l$valueDate?.toIso8601String();
    }
    if (_$data.containsKey('valueBool')) {
      final l$valueBool = valueBool;
      result$data['valueBool'] = l$valueBool;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableValueInsertInput<
          Input$ContentTemplateVariableValueInsertInput>
      get copyWith => CopyWith$Input$ContentTemplateVariableValueInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableValueInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$valueString = valueString;
    final lOther$valueString = other.valueString;
    if (_$data.containsKey('valueString') !=
        other._$data.containsKey('valueString')) {
      return false;
    }
    if (l$valueString != lOther$valueString) {
      return false;
    }
    final l$valueNumber = valueNumber;
    final lOther$valueNumber = other.valueNumber;
    if (_$data.containsKey('valueNumber') !=
        other._$data.containsKey('valueNumber')) {
      return false;
    }
    if (l$valueNumber != lOther$valueNumber) {
      return false;
    }
    final l$valueDate = valueDate;
    final lOther$valueDate = other.valueDate;
    if (_$data.containsKey('valueDate') !=
        other._$data.containsKey('valueDate')) {
      return false;
    }
    if (l$valueDate != lOther$valueDate) {
      return false;
    }
    final l$valueBool = valueBool;
    final lOther$valueBool = other.valueBool;
    if (_$data.containsKey('valueBool') !=
        other._$data.containsKey('valueBool')) {
      return false;
    }
    if (l$valueBool != lOther$valueBool) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$data = data;
    final l$valueString = valueString;
    final l$valueNumber = valueNumber;
    final l$valueDate = valueDate;
    final l$valueBool = valueBool;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('valueString') ? l$valueString : const {},
      _$data.containsKey('valueNumber') ? l$valueNumber : const {},
      _$data.containsKey('valueDate') ? l$valueDate : const {},
      _$data.containsKey('valueBool') ? l$valueBool : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableValueInsertInput<TRes> {
  factory CopyWith$Input$ContentTemplateVariableValueInsertInput(
    Input$ContentTemplateVariableValueInsertInput instance,
    TRes Function(Input$ContentTemplateVariableValueInsertInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableValueInsertInput;

  factory CopyWith$Input$ContentTemplateVariableValueInsertInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableValueInsertInput;

  TRes call({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableValueInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueInsertInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableValueInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableValueInsertInput _instance;

  final TRes Function(Input$ContentTemplateVariableValueInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? data = _undefined,
    Object? valueString = _undefined,
    Object? valueNumber = _undefined,
    Object? valueDate = _undefined,
    Object? valueBool = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableValueInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (valueString != _undefined) 'valueString': (valueString as String?),
        if (valueNumber != _undefined) 'valueNumber': (valueNumber as double?),
        if (valueDate != _undefined) 'valueDate': (valueDate as DateTime?),
        if (valueBool != _undefined) 'valueBool': (valueBool as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableValueInsertInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableValueInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$ContentTemplateVariableValueOrderBy {
  factory Input$ContentTemplateVariableValueOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? valueString,
    Enum$OrderByDirection? valueNumber,
    Enum$OrderByDirection? valueDate,
    Enum$OrderByDirection? valueBool,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$ContentTemplateVariableValueOrderBy._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (valueString != null) r'valueString': valueString,
        if (valueNumber != null) r'valueNumber': valueNumber,
        if (valueDate != null) r'valueDate': valueDate,
        if (valueBool != null) r'valueBool': valueBool,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ContentTemplateVariableValueOrderBy._(this._$data);

  factory Input$ContentTemplateVariableValueOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = l$contentId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentId as String));
    }
    if (data.containsKey('valueString')) {
      final l$valueString = data['valueString'];
      result$data['valueString'] = l$valueString == null
          ? null
          : fromJson$Enum$OrderByDirection((l$valueString as String));
    }
    if (data.containsKey('valueNumber')) {
      final l$valueNumber = data['valueNumber'];
      result$data['valueNumber'] = l$valueNumber == null
          ? null
          : fromJson$Enum$OrderByDirection((l$valueNumber as String));
    }
    if (data.containsKey('valueDate')) {
      final l$valueDate = data['valueDate'];
      result$data['valueDate'] = l$valueDate == null
          ? null
          : fromJson$Enum$OrderByDirection((l$valueDate as String));
    }
    if (data.containsKey('valueBool')) {
      final l$valueBool = data['valueBool'];
      result$data['valueBool'] = l$valueBool == null
          ? null
          : fromJson$Enum$OrderByDirection((l$valueBool as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$ContentTemplateVariableValueOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentId =>
      (_$data['contentId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get valueString =>
      (_$data['valueString'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get valueNumber =>
      (_$data['valueNumber'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get valueDate =>
      (_$data['valueDate'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get valueBool =>
      (_$data['valueBool'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentId);
    }
    if (_$data.containsKey('valueString')) {
      final l$valueString = valueString;
      result$data['valueString'] = l$valueString == null
          ? null
          : toJson$Enum$OrderByDirection(l$valueString);
    }
    if (_$data.containsKey('valueNumber')) {
      final l$valueNumber = valueNumber;
      result$data['valueNumber'] = l$valueNumber == null
          ? null
          : toJson$Enum$OrderByDirection(l$valueNumber);
    }
    if (_$data.containsKey('valueDate')) {
      final l$valueDate = valueDate;
      result$data['valueDate'] = l$valueDate == null
          ? null
          : toJson$Enum$OrderByDirection(l$valueDate);
    }
    if (_$data.containsKey('valueBool')) {
      final l$valueBool = valueBool;
      result$data['valueBool'] = l$valueBool == null
          ? null
          : toJson$Enum$OrderByDirection(l$valueBool);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableValueOrderBy<
          Input$ContentTemplateVariableValueOrderBy>
      get copyWith => CopyWith$Input$ContentTemplateVariableValueOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableValueOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$valueString = valueString;
    final lOther$valueString = other.valueString;
    if (_$data.containsKey('valueString') !=
        other._$data.containsKey('valueString')) {
      return false;
    }
    if (l$valueString != lOther$valueString) {
      return false;
    }
    final l$valueNumber = valueNumber;
    final lOther$valueNumber = other.valueNumber;
    if (_$data.containsKey('valueNumber') !=
        other._$data.containsKey('valueNumber')) {
      return false;
    }
    if (l$valueNumber != lOther$valueNumber) {
      return false;
    }
    final l$valueDate = valueDate;
    final lOther$valueDate = other.valueDate;
    if (_$data.containsKey('valueDate') !=
        other._$data.containsKey('valueDate')) {
      return false;
    }
    if (l$valueDate != lOther$valueDate) {
      return false;
    }
    final l$valueBool = valueBool;
    final lOther$valueBool = other.valueBool;
    if (_$data.containsKey('valueBool') !=
        other._$data.containsKey('valueBool')) {
      return false;
    }
    if (l$valueBool != lOther$valueBool) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$valueString = valueString;
    final l$valueNumber = valueNumber;
    final l$valueDate = valueDate;
    final l$valueBool = valueBool;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('valueString') ? l$valueString : const {},
      _$data.containsKey('valueNumber') ? l$valueNumber : const {},
      _$data.containsKey('valueDate') ? l$valueDate : const {},
      _$data.containsKey('valueBool') ? l$valueBool : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableValueOrderBy<TRes> {
  factory CopyWith$Input$ContentTemplateVariableValueOrderBy(
    Input$ContentTemplateVariableValueOrderBy instance,
    TRes Function(Input$ContentTemplateVariableValueOrderBy) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableValueOrderBy;

  factory CopyWith$Input$ContentTemplateVariableValueOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableValueOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? valueString,
    Enum$OrderByDirection? valueNumber,
    Enum$OrderByDirection? valueDate,
    Enum$OrderByDirection? valueBool,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableValueOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueOrderBy<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableValueOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableValueOrderBy _instance;

  final TRes Function(Input$ContentTemplateVariableValueOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? valueString = _undefined,
    Object? valueNumber = _undefined,
    Object? valueDate = _undefined,
    Object? valueBool = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableValueOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (contentId != _undefined)
          'contentId': (contentId as Enum$OrderByDirection?),
        if (valueString != _undefined)
          'valueString': (valueString as Enum$OrderByDirection?),
        if (valueNumber != _undefined)
          'valueNumber': (valueNumber as Enum$OrderByDirection?),
        if (valueDate != _undefined)
          'valueDate': (valueDate as Enum$OrderByDirection?),
        if (valueBool != _undefined)
          'valueBool': (valueBool as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableValueOrderBy<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableValueOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? contentId,
    Enum$OrderByDirection? valueString,
    Enum$OrderByDirection? valueNumber,
    Enum$OrderByDirection? valueDate,
    Enum$OrderByDirection? valueBool,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$ContentTemplateVariableValueUpdateInput {
  factory Input$ContentTemplateVariableValueUpdateInput({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$ContentTemplateVariableValueUpdateInput._({
        if (id != null) r'id': id,
        if (contentId != null) r'contentId': contentId,
        if (data != null) r'data': data,
        if (valueString != null) r'valueString': valueString,
        if (valueNumber != null) r'valueNumber': valueNumber,
        if (valueDate != null) r'valueDate': valueDate,
        if (valueBool != null) r'valueBool': valueBool,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ContentTemplateVariableValueUpdateInput._(this._$data);

  factory Input$ContentTemplateVariableValueUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('valueString')) {
      final l$valueString = data['valueString'];
      result$data['valueString'] = (l$valueString as String?);
    }
    if (data.containsKey('valueNumber')) {
      final l$valueNumber = data['valueNumber'];
      result$data['valueNumber'] = (l$valueNumber as num?)?.toDouble();
    }
    if (data.containsKey('valueDate')) {
      final l$valueDate = data['valueDate'];
      result$data['valueDate'] =
          l$valueDate == null ? null : DateTime.parse((l$valueDate as String));
    }
    if (data.containsKey('valueBool')) {
      final l$valueBool = data['valueBool'];
      result$data['valueBool'] = (l$valueBool as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$ContentTemplateVariableValueUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get contentId => (_$data['contentId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get valueString => (_$data['valueString'] as String?);

  double? get valueNumber => (_$data['valueNumber'] as double?);

  DateTime? get valueDate => (_$data['valueDate'] as DateTime?);

  bool? get valueBool => (_$data['valueBool'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('valueString')) {
      final l$valueString = valueString;
      result$data['valueString'] = l$valueString;
    }
    if (_$data.containsKey('valueNumber')) {
      final l$valueNumber = valueNumber;
      result$data['valueNumber'] = l$valueNumber;
    }
    if (_$data.containsKey('valueDate')) {
      final l$valueDate = valueDate;
      result$data['valueDate'] = l$valueDate?.toIso8601String();
    }
    if (_$data.containsKey('valueBool')) {
      final l$valueBool = valueBool;
      result$data['valueBool'] = l$valueBool;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ContentTemplateVariableValueUpdateInput<
          Input$ContentTemplateVariableValueUpdateInput>
      get copyWith => CopyWith$Input$ContentTemplateVariableValueUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTemplateVariableValueUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$valueString = valueString;
    final lOther$valueString = other.valueString;
    if (_$data.containsKey('valueString') !=
        other._$data.containsKey('valueString')) {
      return false;
    }
    if (l$valueString != lOther$valueString) {
      return false;
    }
    final l$valueNumber = valueNumber;
    final lOther$valueNumber = other.valueNumber;
    if (_$data.containsKey('valueNumber') !=
        other._$data.containsKey('valueNumber')) {
      return false;
    }
    if (l$valueNumber != lOther$valueNumber) {
      return false;
    }
    final l$valueDate = valueDate;
    final lOther$valueDate = other.valueDate;
    if (_$data.containsKey('valueDate') !=
        other._$data.containsKey('valueDate')) {
      return false;
    }
    if (l$valueDate != lOther$valueDate) {
      return false;
    }
    final l$valueBool = valueBool;
    final lOther$valueBool = other.valueBool;
    if (_$data.containsKey('valueBool') !=
        other._$data.containsKey('valueBool')) {
      return false;
    }
    if (l$valueBool != lOther$valueBool) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$contentId = contentId;
    final l$data = data;
    final l$valueString = valueString;
    final l$valueNumber = valueNumber;
    final l$valueDate = valueDate;
    final l$valueBool = valueBool;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('valueString') ? l$valueString : const {},
      _$data.containsKey('valueNumber') ? l$valueNumber : const {},
      _$data.containsKey('valueDate') ? l$valueDate : const {},
      _$data.containsKey('valueBool') ? l$valueBool : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTemplateVariableValueUpdateInput<TRes> {
  factory CopyWith$Input$ContentTemplateVariableValueUpdateInput(
    Input$ContentTemplateVariableValueUpdateInput instance,
    TRes Function(Input$ContentTemplateVariableValueUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentTemplateVariableValueUpdateInput;

  factory CopyWith$Input$ContentTemplateVariableValueUpdateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ContentTemplateVariableValueUpdateInput;

  TRes call({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$ContentTemplateVariableValueUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentTemplateVariableValueUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentTemplateVariableValueUpdateInput _instance;

  final TRes Function(Input$ContentTemplateVariableValueUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? contentId = _undefined,
    Object? data = _undefined,
    Object? valueString = _undefined,
    Object? valueNumber = _undefined,
    Object? valueDate = _undefined,
    Object? valueBool = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ContentTemplateVariableValueUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (valueString != _undefined) 'valueString': (valueString as String?),
        if (valueNumber != _undefined) 'valueNumber': (valueNumber as double?),
        if (valueDate != _undefined) 'valueDate': (valueDate as DateTime?),
        if (valueBool != _undefined) 'valueBool': (valueBool as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ContentTemplateVariableValueUpdateInput<TRes>
    implements CopyWith$Input$ContentTemplateVariableValueUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentTemplateVariableValueUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? contentId,
    Map<String, dynamic>? data,
    String? valueString,
    double? valueNumber,
    DateTime? valueDate,
    bool? valueBool,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$ContentTypeFilter {
  factory Input$ContentTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$ContentTypeFilter>? and,
    List<Input$ContentTypeFilter>? or,
    Input$ContentTypeFilter? not,
  }) =>
      Input$ContentTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ContentTypeFilter._(this._$data);

  factory Input$ContentTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$requiresApproval as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ContentTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ContentTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ContentTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ContentTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get requiresApproval =>
      (_$data['requiresApproval'] as Input$BooleanFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ContentTypeFilter>? get and =>
      (_$data['and'] as List<Input$ContentTypeFilter>?);

  List<Input$ContentTypeFilter>? get or =>
      (_$data['or'] as List<Input$ContentTypeFilter>?);

  Input$ContentTypeFilter? get not =>
      (_$data['not'] as Input$ContentTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContentTypeFilter<Input$ContentTypeFilter> get copyWith =>
      CopyWith$Input$ContentTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTypeFilter<TRes> {
  factory CopyWith$Input$ContentTypeFilter(
    Input$ContentTypeFilter instance,
    TRes Function(Input$ContentTypeFilter) then,
  ) = _CopyWithImpl$Input$ContentTypeFilter;

  factory CopyWith$Input$ContentTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$ContentTypeFilter>? and,
    List<Input$ContentTypeFilter>? or,
    Input$ContentTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$BooleanFilter<TRes> get requiresApproval;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ContentTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTypeFilter<Input$ContentTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ContentTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ContentTypeFilter<Input$ContentTypeFilter>>?)
          _fn);
  CopyWith$Input$ContentTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$ContentTypeFilter<TRes>
    implements CopyWith$Input$ContentTypeFilter<TRes> {
  _CopyWithImpl$Input$ContentTypeFilter(
    this._instance,
    this._then,
  );

  final Input$ContentTypeFilter _instance;

  final TRes Function(Input$ContentTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ContentTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as Input$BooleanFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ContentTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ContentTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$ContentTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get requiresApproval {
    final local$requiresApproval = _instance.requiresApproval;
    return local$requiresApproval == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$requiresApproval, (e) => call(requiresApproval: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ContentTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTypeFilter<
                          Input$ContentTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ContentTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ContentTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ContentTypeFilter<
                          Input$ContentTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ContentTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ContentTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ContentTypeFilter.stub(_then(_instance))
        : CopyWith$Input$ContentTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ContentTypeFilter<TRes>
    implements CopyWith$Input$ContentTypeFilter<TRes> {
  _CopyWithStubImpl$Input$ContentTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$ContentTypeFilter>? and,
    List<Input$ContentTypeFilter>? or,
    Input$ContentTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get requiresApproval =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ContentTypeFilter<TRes> get not =>
      CopyWith$Input$ContentTypeFilter.stub(_res);
}

class Input$ContentTypeInsertInput {
  factory Input$ContentTypeInsertInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  }) =>
      Input$ContentTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
      });

  Input$ContentTypeInsertInput._(this._$data);

  factory Input$ContentTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = (l$requiresApproval as bool?);
    }
    return Input$ContentTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get requiresApproval => (_$data['requiresApproval'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval;
    }
    return result$data;
  }

  CopyWith$Input$ContentTypeInsertInput<Input$ContentTypeInsertInput>
      get copyWith => CopyWith$Input$ContentTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTypeInsertInput<TRes> {
  factory CopyWith$Input$ContentTypeInsertInput(
    Input$ContentTypeInsertInput instance,
    TRes Function(Input$ContentTypeInsertInput) then,
  ) = _CopyWithImpl$Input$ContentTypeInsertInput;

  factory CopyWith$Input$ContentTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  });
}

class _CopyWithImpl$Input$ContentTypeInsertInput<TRes>
    implements CopyWith$Input$ContentTypeInsertInput<TRes> {
  _CopyWithImpl$Input$ContentTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$ContentTypeInsertInput _instance;

  final TRes Function(Input$ContentTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
  }) =>
      _then(Input$ContentTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as bool?),
      }));
}

class _CopyWithStubImpl$Input$ContentTypeInsertInput<TRes>
    implements CopyWith$Input$ContentTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$ContentTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  }) =>
      _res;
}

class Input$ContentTypeOrderBy {
  factory Input$ContentTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  }) =>
      Input$ContentTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
      });

  Input$ContentTypeOrderBy._(this._$data);

  factory Input$ContentTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : fromJson$Enum$OrderByDirection((l$requiresApproval as String));
    }
    return Input$ContentTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get requiresApproval =>
      (_$data['requiresApproval'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : toJson$Enum$OrderByDirection(l$requiresApproval);
    }
    return result$data;
  }

  CopyWith$Input$ContentTypeOrderBy<Input$ContentTypeOrderBy> get copyWith =>
      CopyWith$Input$ContentTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTypeOrderBy<TRes> {
  factory CopyWith$Input$ContentTypeOrderBy(
    Input$ContentTypeOrderBy instance,
    TRes Function(Input$ContentTypeOrderBy) then,
  ) = _CopyWithImpl$Input$ContentTypeOrderBy;

  factory CopyWith$Input$ContentTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  });
}

class _CopyWithImpl$Input$ContentTypeOrderBy<TRes>
    implements CopyWith$Input$ContentTypeOrderBy<TRes> {
  _CopyWithImpl$Input$ContentTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$ContentTypeOrderBy _instance;

  final TRes Function(Input$ContentTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
  }) =>
      _then(Input$ContentTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ContentTypeOrderBy<TRes>
    implements CopyWith$Input$ContentTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$ContentTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  }) =>
      _res;
}

class Input$ContentTypeUpdateInput {
  factory Input$ContentTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  }) =>
      Input$ContentTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
      });

  Input$ContentTypeUpdateInput._(this._$data);

  factory Input$ContentTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = (l$requiresApproval as bool?);
    }
    return Input$ContentTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get requiresApproval => (_$data['requiresApproval'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval;
    }
    return result$data;
  }

  CopyWith$Input$ContentTypeUpdateInput<Input$ContentTypeUpdateInput>
      get copyWith => CopyWith$Input$ContentTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentTypeUpdateInput<TRes> {
  factory CopyWith$Input$ContentTypeUpdateInput(
    Input$ContentTypeUpdateInput instance,
    TRes Function(Input$ContentTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentTypeUpdateInput;

  factory CopyWith$Input$ContentTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  });
}

class _CopyWithImpl$Input$ContentTypeUpdateInput<TRes>
    implements CopyWith$Input$ContentTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentTypeUpdateInput _instance;

  final TRes Function(Input$ContentTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
  }) =>
      _then(Input$ContentTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as bool?),
      }));
}

class _CopyWithStubImpl$Input$ContentTypeUpdateInput<TRes>
    implements CopyWith$Input$ContentTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
  }) =>
      _res;
}

class Input$ContentUpdateInput {
  factory Input$ContentUpdateInput({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  }) =>
      Input$ContentUpdateInput._({
        if (id != null) r'id': id,
        if (applicationId != null) r'applicationId': applicationId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (body != null) r'body': body,
        if (contentTypeId != null) r'contentTypeId': contentTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (authorId != null) r'authorId': authorId,
        if (data != null) r'data': data,
        if (version != null) r'version': version,
        if (isApproved != null) r'isApproved': isApproved,
        if (approvedAt != null) r'approvedAt': approvedAt,
        if (publicationStateId != null)
          r'publicationStateId': publicationStateId,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (contentTemplateId != null) r'contentTemplateId': contentTemplateId,
        if (publicationUrl != null) r'publicationUrl': publicationUrl,
        if (bodyMarkdown != null) r'bodyMarkdown': bodyMarkdown,
      });

  Input$ContentUpdateInput._(this._$data);

  factory Input$ContentUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('contentTypeId')) {
      final l$contentTypeId = data['contentTypeId'];
      result$data['contentTypeId'] = (l$contentTypeId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('authorId')) {
      final l$authorId = data['authorId'];
      result$data['authorId'] = (l$authorId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as int?);
    }
    if (data.containsKey('isApproved')) {
      final l$isApproved = data['isApproved'];
      result$data['isApproved'] = (l$isApproved as bool?);
    }
    if (data.containsKey('approvedAt')) {
      final l$approvedAt = data['approvedAt'];
      result$data['approvedAt'] = l$approvedAt == null
          ? null
          : DateTime.parse((l$approvedAt as String));
    }
    if (data.containsKey('publicationStateId')) {
      final l$publicationStateId = data['publicationStateId'];
      result$data['publicationStateId'] = (l$publicationStateId as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = data['contentTemplateId'];
      result$data['contentTemplateId'] = (l$contentTemplateId as String?);
    }
    if (data.containsKey('publicationUrl')) {
      final l$publicationUrl = data['publicationUrl'];
      result$data['publicationUrl'] = (l$publicationUrl as String?);
    }
    if (data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = data['bodyMarkdown'];
      result$data['bodyMarkdown'] = (l$bodyMarkdown as String?);
    }
    return Input$ContentUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get body => (_$data['body'] as String?);

  String? get contentTypeId => (_$data['contentTypeId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get authorId => (_$data['authorId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  int? get version => (_$data['version'] as int?);

  bool? get isApproved => (_$data['isApproved'] as bool?);

  DateTime? get approvedAt => (_$data['approvedAt'] as DateTime?);

  String? get publicationStateId => (_$data['publicationStateId'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  String? get contentTemplateId => (_$data['contentTemplateId'] as String?);

  String? get publicationUrl => (_$data['publicationUrl'] as String?);

  String? get bodyMarkdown => (_$data['bodyMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('contentTypeId')) {
      final l$contentTypeId = contentTypeId;
      result$data['contentTypeId'] = l$contentTypeId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('authorId')) {
      final l$authorId = authorId;
      result$data['authorId'] = l$authorId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('isApproved')) {
      final l$isApproved = isApproved;
      result$data['isApproved'] = l$isApproved;
    }
    if (_$data.containsKey('approvedAt')) {
      final l$approvedAt = approvedAt;
      result$data['approvedAt'] = l$approvedAt?.toIso8601String();
    }
    if (_$data.containsKey('publicationStateId')) {
      final l$publicationStateId = publicationStateId;
      result$data['publicationStateId'] = l$publicationStateId;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('contentTemplateId')) {
      final l$contentTemplateId = contentTemplateId;
      result$data['contentTemplateId'] = l$contentTemplateId;
    }
    if (_$data.containsKey('publicationUrl')) {
      final l$publicationUrl = publicationUrl;
      result$data['publicationUrl'] = l$publicationUrl;
    }
    if (_$data.containsKey('bodyMarkdown')) {
      final l$bodyMarkdown = bodyMarkdown;
      result$data['bodyMarkdown'] = l$bodyMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$ContentUpdateInput<Input$ContentUpdateInput> get copyWith =>
      CopyWith$Input$ContentUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContentUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$contentTypeId = contentTypeId;
    final lOther$contentTypeId = other.contentTypeId;
    if (_$data.containsKey('contentTypeId') !=
        other._$data.containsKey('contentTypeId')) {
      return false;
    }
    if (l$contentTypeId != lOther$contentTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (_$data.containsKey('authorId') !=
        other._$data.containsKey('authorId')) {
      return false;
    }
    if (l$authorId != lOther$authorId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$isApproved = isApproved;
    final lOther$isApproved = other.isApproved;
    if (_$data.containsKey('isApproved') !=
        other._$data.containsKey('isApproved')) {
      return false;
    }
    if (l$isApproved != lOther$isApproved) {
      return false;
    }
    final l$approvedAt = approvedAt;
    final lOther$approvedAt = other.approvedAt;
    if (_$data.containsKey('approvedAt') !=
        other._$data.containsKey('approvedAt')) {
      return false;
    }
    if (l$approvedAt != lOther$approvedAt) {
      return false;
    }
    final l$publicationStateId = publicationStateId;
    final lOther$publicationStateId = other.publicationStateId;
    if (_$data.containsKey('publicationStateId') !=
        other._$data.containsKey('publicationStateId')) {
      return false;
    }
    if (l$publicationStateId != lOther$publicationStateId) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$contentTemplateId = contentTemplateId;
    final lOther$contentTemplateId = other.contentTemplateId;
    if (_$data.containsKey('contentTemplateId') !=
        other._$data.containsKey('contentTemplateId')) {
      return false;
    }
    if (l$contentTemplateId != lOther$contentTemplateId) {
      return false;
    }
    final l$publicationUrl = publicationUrl;
    final lOther$publicationUrl = other.publicationUrl;
    if (_$data.containsKey('publicationUrl') !=
        other._$data.containsKey('publicationUrl')) {
      return false;
    }
    if (l$publicationUrl != lOther$publicationUrl) {
      return false;
    }
    final l$bodyMarkdown = bodyMarkdown;
    final lOther$bodyMarkdown = other.bodyMarkdown;
    if (_$data.containsKey('bodyMarkdown') !=
        other._$data.containsKey('bodyMarkdown')) {
      return false;
    }
    if (l$bodyMarkdown != lOther$bodyMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$applicationId = applicationId;
    final l$title = title;
    final l$description = description;
    final l$body = body;
    final l$contentTypeId = contentTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$data = data;
    final l$version = version;
    final l$isApproved = isApproved;
    final l$approvedAt = approvedAt;
    final l$publicationStateId = publicationStateId;
    final l$coverUrl = coverUrl;
    final l$contentTemplateId = contentTemplateId;
    final l$publicationUrl = publicationUrl;
    final l$bodyMarkdown = bodyMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('contentTypeId') ? l$contentTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('authorId') ? l$authorId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('isApproved') ? l$isApproved : const {},
      _$data.containsKey('approvedAt') ? l$approvedAt : const {},
      _$data.containsKey('publicationStateId')
          ? l$publicationStateId
          : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('contentTemplateId') ? l$contentTemplateId : const {},
      _$data.containsKey('publicationUrl') ? l$publicationUrl : const {},
      _$data.containsKey('bodyMarkdown') ? l$bodyMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContentUpdateInput<TRes> {
  factory CopyWith$Input$ContentUpdateInput(
    Input$ContentUpdateInput instance,
    TRes Function(Input$ContentUpdateInput) then,
  ) = _CopyWithImpl$Input$ContentUpdateInput;

  factory CopyWith$Input$ContentUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContentUpdateInput;

  TRes call({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  });
}

class _CopyWithImpl$Input$ContentUpdateInput<TRes>
    implements CopyWith$Input$ContentUpdateInput<TRes> {
  _CopyWithImpl$Input$ContentUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ContentUpdateInput _instance;

  final TRes Function(Input$ContentUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? applicationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? body = _undefined,
    Object? contentTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? authorId = _undefined,
    Object? data = _undefined,
    Object? version = _undefined,
    Object? isApproved = _undefined,
    Object? approvedAt = _undefined,
    Object? publicationStateId = _undefined,
    Object? coverUrl = _undefined,
    Object? contentTemplateId = _undefined,
    Object? publicationUrl = _undefined,
    Object? bodyMarkdown = _undefined,
  }) =>
      _then(Input$ContentUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (body != _undefined) 'body': (body as String?),
        if (contentTypeId != _undefined)
          'contentTypeId': (contentTypeId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (authorId != _undefined) 'authorId': (authorId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (version != _undefined) 'version': (version as int?),
        if (isApproved != _undefined) 'isApproved': (isApproved as bool?),
        if (approvedAt != _undefined) 'approvedAt': (approvedAt as DateTime?),
        if (publicationStateId != _undefined)
          'publicationStateId': (publicationStateId as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (contentTemplateId != _undefined)
          'contentTemplateId': (contentTemplateId as String?),
        if (publicationUrl != _undefined)
          'publicationUrl': (publicationUrl as String?),
        if (bodyMarkdown != _undefined)
          'bodyMarkdown': (bodyMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$ContentUpdateInput<TRes>
    implements CopyWith$Input$ContentUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ContentUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? applicationId,
    String? title,
    String? description,
    String? body,
    String? contentTypeId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? authorId,
    Map<String, dynamic>? data,
    int? version,
    bool? isApproved,
    DateTime? approvedAt,
    String? publicationStateId,
    String? coverUrl,
    String? contentTemplateId,
    String? publicationUrl,
    String? bodyMarkdown,
  }) =>
      _res;
}

class Input$CreationTypeFilter {
  factory Input$CreationTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$CreationTypeFilter>? and,
    List<Input$CreationTypeFilter>? or,
    Input$CreationTypeFilter? not,
  }) =>
      Input$CreationTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$CreationTypeFilter._(this._$data);

  factory Input$CreationTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$CreationTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$CreationTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$CreationTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$CreationTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$CreationTypeFilter>? get and =>
      (_$data['and'] as List<Input$CreationTypeFilter>?);

  List<Input$CreationTypeFilter>? get or =>
      (_$data['or'] as List<Input$CreationTypeFilter>?);

  Input$CreationTypeFilter? get not =>
      (_$data['not'] as Input$CreationTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CreationTypeFilter<Input$CreationTypeFilter> get copyWith =>
      CopyWith$Input$CreationTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreationTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreationTypeFilter<TRes> {
  factory CopyWith$Input$CreationTypeFilter(
    Input$CreationTypeFilter instance,
    TRes Function(Input$CreationTypeFilter) then,
  ) = _CopyWithImpl$Input$CreationTypeFilter;

  factory CopyWith$Input$CreationTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CreationTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$CreationTypeFilter>? and,
    List<Input$CreationTypeFilter>? or,
    Input$CreationTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$CreationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$CreationTypeFilter<Input$CreationTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$CreationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$CreationTypeFilter<Input$CreationTypeFilter>>?)
          _fn);
  CopyWith$Input$CreationTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$CreationTypeFilter<TRes>
    implements CopyWith$Input$CreationTypeFilter<TRes> {
  _CopyWithImpl$Input$CreationTypeFilter(
    this._instance,
    this._then,
  );

  final Input$CreationTypeFilter _instance;

  final TRes Function(Input$CreationTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$CreationTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$CreationTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$CreationTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$CreationTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$CreationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$CreationTypeFilter<
                          Input$CreationTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$CreationTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$CreationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$CreationTypeFilter<
                          Input$CreationTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$CreationTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$CreationTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$CreationTypeFilter.stub(_then(_instance))
        : CopyWith$Input$CreationTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$CreationTypeFilter<TRes>
    implements CopyWith$Input$CreationTypeFilter<TRes> {
  _CopyWithStubImpl$Input$CreationTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$CreationTypeFilter>? and,
    List<Input$CreationTypeFilter>? or,
    Input$CreationTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$CreationTypeFilter<TRes> get not =>
      CopyWith$Input$CreationTypeFilter.stub(_res);
}

class Input$CreationTypeInsertInput {
  factory Input$CreationTypeInsertInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$CreationTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$CreationTypeInsertInput._(this._$data);

  factory Input$CreationTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$CreationTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$CreationTypeInsertInput<Input$CreationTypeInsertInput>
      get copyWith => CopyWith$Input$CreationTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreationTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreationTypeInsertInput<TRes> {
  factory CopyWith$Input$CreationTypeInsertInput(
    Input$CreationTypeInsertInput instance,
    TRes Function(Input$CreationTypeInsertInput) then,
  ) = _CopyWithImpl$Input$CreationTypeInsertInput;

  factory CopyWith$Input$CreationTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreationTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$CreationTypeInsertInput<TRes>
    implements CopyWith$Input$CreationTypeInsertInput<TRes> {
  _CopyWithImpl$Input$CreationTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$CreationTypeInsertInput _instance;

  final TRes Function(Input$CreationTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$CreationTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$CreationTypeInsertInput<TRes>
    implements CopyWith$Input$CreationTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$CreationTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$CreationTypeOrderBy {
  factory Input$CreationTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$CreationTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$CreationTypeOrderBy._(this._$data);

  factory Input$CreationTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$CreationTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$CreationTypeOrderBy<Input$CreationTypeOrderBy> get copyWith =>
      CopyWith$Input$CreationTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreationTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreationTypeOrderBy<TRes> {
  factory CopyWith$Input$CreationTypeOrderBy(
    Input$CreationTypeOrderBy instance,
    TRes Function(Input$CreationTypeOrderBy) then,
  ) = _CopyWithImpl$Input$CreationTypeOrderBy;

  factory CopyWith$Input$CreationTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CreationTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$CreationTypeOrderBy<TRes>
    implements CopyWith$Input$CreationTypeOrderBy<TRes> {
  _CopyWithImpl$Input$CreationTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$CreationTypeOrderBy _instance;

  final TRes Function(Input$CreationTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$CreationTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$CreationTypeOrderBy<TRes>
    implements CopyWith$Input$CreationTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$CreationTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$CreationTypeUpdateInput {
  factory Input$CreationTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      Input$CreationTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$CreationTypeUpdateInput._(this._$data);

  factory Input$CreationTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$CreationTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$CreationTypeUpdateInput<Input$CreationTypeUpdateInput>
      get copyWith => CopyWith$Input$CreationTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreationTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreationTypeUpdateInput<TRes> {
  factory CopyWith$Input$CreationTypeUpdateInput(
    Input$CreationTypeUpdateInput instance,
    TRes Function(Input$CreationTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$CreationTypeUpdateInput;

  factory CopyWith$Input$CreationTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreationTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$CreationTypeUpdateInput<TRes>
    implements CopyWith$Input$CreationTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$CreationTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CreationTypeUpdateInput _instance;

  final TRes Function(Input$CreationTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$CreationTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$CreationTypeUpdateInput<TRes>
    implements CopyWith$Input$CreationTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CreationTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$DateFilter {
  factory Input$DateFilter({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      Input$DateFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$DateFilter._(this._$data);

  factory Input$DateFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : DateTime.parse((l$eq as String));
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] =
          l$gt == null ? null : DateTime.parse((l$gt as String));
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] =
          l$gte == null ? null : DateTime.parse((l$gte as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] =
          l$lt == null ? null : DateTime.parse((l$lt as String));
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] =
          l$lte == null ? null : DateTime.parse((l$lte as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : DateTime.parse((l$neq as String));
    }
    return Input$DateFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get eq => (_$data['eq'] as DateTime?);

  DateTime? get gt => (_$data['gt'] as DateTime?);

  DateTime? get gte => (_$data['gte'] as DateTime?);

  List<DateTime>? get $in => (_$data['in'] as List<DateTime>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  DateTime? get lt => (_$data['lt'] as DateTime?);

  DateTime? get lte => (_$data['lte'] as DateTime?);

  DateTime? get neq => (_$data['neq'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq?.toIso8601String();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt?.toIso8601String();
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte?.toIso8601String();
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e.toIso8601String()).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt?.toIso8601String();
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte?.toIso8601String();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$DateFilter<Input$DateFilter> get copyWith =>
      CopyWith$Input$DateFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateFilter<TRes> {
  factory CopyWith$Input$DateFilter(
    Input$DateFilter instance,
    TRes Function(Input$DateFilter) then,
  ) = _CopyWithImpl$Input$DateFilter;

  factory CopyWith$Input$DateFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateFilter;

  TRes call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  });
}

class _CopyWithImpl$Input$DateFilter<TRes>
    implements CopyWith$Input$DateFilter<TRes> {
  _CopyWithImpl$Input$DateFilter(
    this._instance,
    this._then,
  );

  final Input$DateFilter _instance;

  final TRes Function(Input$DateFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$DateFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as DateTime?),
        if (gt != _undefined) 'gt': (gt as DateTime?),
        if (gte != _undefined) 'gte': (gte as DateTime?),
        if ($in != _undefined) 'in': ($in as List<DateTime>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as DateTime?),
        if (lte != _undefined) 'lte': (lte as DateTime?),
        if (neq != _undefined) 'neq': (neq as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$DateFilter<TRes>
    implements CopyWith$Input$DateFilter<TRes> {
  _CopyWithStubImpl$Input$DateFilter(this._res);

  TRes _res;

  call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      _res;
}

class Input$DatetimeFilter {
  factory Input$DatetimeFilter({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      Input$DatetimeFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$DatetimeFilter._(this._$data);

  factory Input$DatetimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : DateTime.parse((l$eq as String));
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] =
          l$gt == null ? null : DateTime.parse((l$gt as String));
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] =
          l$gte == null ? null : DateTime.parse((l$gte as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] =
          l$lt == null ? null : DateTime.parse((l$lt as String));
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] =
          l$lte == null ? null : DateTime.parse((l$lte as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : DateTime.parse((l$neq as String));
    }
    return Input$DatetimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get eq => (_$data['eq'] as DateTime?);

  DateTime? get gt => (_$data['gt'] as DateTime?);

  DateTime? get gte => (_$data['gte'] as DateTime?);

  List<DateTime>? get $in => (_$data['in'] as List<DateTime>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  DateTime? get lt => (_$data['lt'] as DateTime?);

  DateTime? get lte => (_$data['lte'] as DateTime?);

  DateTime? get neq => (_$data['neq'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq?.toIso8601String();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt?.toIso8601String();
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte?.toIso8601String();
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e.toIso8601String()).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt?.toIso8601String();
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte?.toIso8601String();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$DatetimeFilter<Input$DatetimeFilter> get copyWith =>
      CopyWith$Input$DatetimeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DatetimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$DatetimeFilter<TRes> {
  factory CopyWith$Input$DatetimeFilter(
    Input$DatetimeFilter instance,
    TRes Function(Input$DatetimeFilter) then,
  ) = _CopyWithImpl$Input$DatetimeFilter;

  factory CopyWith$Input$DatetimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DatetimeFilter;

  TRes call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  });
}

class _CopyWithImpl$Input$DatetimeFilter<TRes>
    implements CopyWith$Input$DatetimeFilter<TRes> {
  _CopyWithImpl$Input$DatetimeFilter(
    this._instance,
    this._then,
  );

  final Input$DatetimeFilter _instance;

  final TRes Function(Input$DatetimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$DatetimeFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as DateTime?),
        if (gt != _undefined) 'gt': (gt as DateTime?),
        if (gte != _undefined) 'gte': (gte as DateTime?),
        if ($in != _undefined) 'in': ($in as List<DateTime>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as DateTime?),
        if (lte != _undefined) 'lte': (lte as DateTime?),
        if (neq != _undefined) 'neq': (neq as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$DatetimeFilter<TRes>
    implements CopyWith$Input$DatetimeFilter<TRes> {
  _CopyWithStubImpl$Input$DatetimeFilter(this._res);

  TRes _res;

  call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      _res;
}

class Input$DocumentFilter {
  factory Input$DocumentFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$UUIDFilter? mimeTypeId,
    Input$StringFilter? fileName,
    Input$StringFilter? content,
    Input$StringFilter? originalFileUrl,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? contentMarkdown,
    Input$IDFilter? nodeId,
    List<Input$DocumentFilter>? and,
    List<Input$DocumentFilter>? or,
    Input$DocumentFilter? not,
  }) =>
      Input$DocumentFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (fileName != null) r'fileName': fileName,
        if (content != null) r'content': content,
        if (originalFileUrl != null) r'originalFileUrl': originalFileUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$DocumentFilter._(this._$data);

  factory Input$DocumentFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$mimeTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = l$fileName == null
          ? null
          : Input$StringFilter.fromJson((l$fileName as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringFilter.fromJson((l$content as Map<String, dynamic>));
    }
    if (data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = data['originalFileUrl'];
      result$data['originalFileUrl'] = l$originalFileUrl == null
          ? null
          : Input$StringFilter.fromJson(
              (l$originalFileUrl as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$documentTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$contentMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$DocumentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$DocumentFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$DocumentFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$DocumentFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$UUIDFilter? get mimeTypeId =>
      (_$data['mimeTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get fileName =>
      (_$data['fileName'] as Input$StringFilter?);

  Input$StringFilter? get content => (_$data['content'] as Input$StringFilter?);

  Input$StringFilter? get originalFileUrl =>
      (_$data['originalFileUrl'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get documentTypeId =>
      (_$data['documentTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get contentMarkdown =>
      (_$data['contentMarkdown'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$DocumentFilter>? get and =>
      (_$data['and'] as List<Input$DocumentFilter>?);

  List<Input$DocumentFilter>? get or =>
      (_$data['or'] as List<Input$DocumentFilter>?);

  Input$DocumentFilter? get not => (_$data['not'] as Input$DocumentFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId?.toJson();
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = originalFileUrl;
      result$data['originalFileUrl'] = l$originalFileUrl?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId?.toJson();
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DocumentFilter<Input$DocumentFilter> get copyWith =>
      CopyWith$Input$DocumentFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$originalFileUrl = originalFileUrl;
    final lOther$originalFileUrl = other.originalFileUrl;
    if (_$data.containsKey('originalFileUrl') !=
        other._$data.containsKey('originalFileUrl')) {
      return false;
    }
    if (l$originalFileUrl != lOther$originalFileUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$mimeTypeId = mimeTypeId;
    final l$fileName = fileName;
    final l$content = content;
    final l$originalFileUrl = originalFileUrl;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    final l$documentTypeId = documentTypeId;
    final l$contentMarkdown = contentMarkdown;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('originalFileUrl') ? l$originalFileUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentFilter<TRes> {
  factory CopyWith$Input$DocumentFilter(
    Input$DocumentFilter instance,
    TRes Function(Input$DocumentFilter) then,
  ) = _CopyWithImpl$Input$DocumentFilter;

  factory CopyWith$Input$DocumentFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$UUIDFilter? mimeTypeId,
    Input$StringFilter? fileName,
    Input$StringFilter? content,
    Input$StringFilter? originalFileUrl,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? contentMarkdown,
    Input$IDFilter? nodeId,
    List<Input$DocumentFilter>? and,
    List<Input$DocumentFilter>? or,
    Input$DocumentFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId;
  CopyWith$Input$StringFilter<TRes> get fileName;
  CopyWith$Input$StringFilter<TRes> get content;
  CopyWith$Input$StringFilter<TRes> get originalFileUrl;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get documentTypeId;
  CopyWith$Input$StringFilter<TRes> get contentMarkdown;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$DocumentFilter>? Function(
              Iterable<CopyWith$Input$DocumentFilter<Input$DocumentFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$DocumentFilter>? Function(
              Iterable<CopyWith$Input$DocumentFilter<Input$DocumentFilter>>?)
          _fn);
  CopyWith$Input$DocumentFilter<TRes> get not;
}

class _CopyWithImpl$Input$DocumentFilter<TRes>
    implements CopyWith$Input$DocumentFilter<TRes> {
  _CopyWithImpl$Input$DocumentFilter(
    this._instance,
    this._then,
  );

  final Input$DocumentFilter _instance;

  final TRes Function(Input$DocumentFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? mimeTypeId = _undefined,
    Object? fileName = _undefined,
    Object? content = _undefined,
    Object? originalFileUrl = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
    Object? documentTypeId = _undefined,
    Object? contentMarkdown = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DocumentFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Input$UUIDFilter?),
        if (fileName != _undefined)
          'fileName': (fileName as Input$StringFilter?),
        if (content != _undefined) 'content': (content as Input$StringFilter?),
        if (originalFileUrl != _undefined)
          'originalFileUrl': (originalFileUrl as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as Input$UUIDFilter?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$DocumentFilter>?),
        if (or != _undefined) 'or': (or as List<Input$DocumentFilter>?),
        if (not != _undefined) 'not': (not as Input$DocumentFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId {
    final local$mimeTypeId = _instance.mimeTypeId;
    return local$mimeTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$mimeTypeId, (e) => call(mimeTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get fileName {
    final local$fileName = _instance.fileName;
    return local$fileName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fileName, (e) => call(fileName: e));
  }

  CopyWith$Input$StringFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$content, (e) => call(content: e));
  }

  CopyWith$Input$StringFilter<TRes> get originalFileUrl {
    final local$originalFileUrl = _instance.originalFileUrl;
    return local$originalFileUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$originalFileUrl, (e) => call(originalFileUrl: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get documentTypeId {
    final local$documentTypeId = _instance.documentTypeId;
    return local$documentTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$documentTypeId, (e) => call(documentTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get contentMarkdown {
    final local$contentMarkdown = _instance.contentMarkdown;
    return local$contentMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$contentMarkdown, (e) => call(contentMarkdown: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$DocumentFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentFilter<Input$DocumentFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$DocumentFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$DocumentFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentFilter<Input$DocumentFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$DocumentFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$DocumentFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$DocumentFilter.stub(_then(_instance))
        : CopyWith$Input$DocumentFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DocumentFilter<TRes>
    implements CopyWith$Input$DocumentFilter<TRes> {
  _CopyWithStubImpl$Input$DocumentFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$UUIDFilter? mimeTypeId,
    Input$StringFilter? fileName,
    Input$StringFilter? content,
    Input$StringFilter? originalFileUrl,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? contentMarkdown,
    Input$IDFilter? nodeId,
    List<Input$DocumentFilter>? and,
    List<Input$DocumentFilter>? or,
    Input$DocumentFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get mimeTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get fileName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get content =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get originalFileUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get documentTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get contentMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$DocumentFilter<TRes> get not =>
      CopyWith$Input$DocumentFilter.stub(_res);
}

class Input$DocumentInsertInput {
  factory Input$DocumentInsertInput({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  }) =>
      Input$DocumentInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (fileName != null) r'fileName': fileName,
        if (content != null) r'content': content,
        if (originalFileUrl != null) r'originalFileUrl': originalFileUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
      });

  Input$DocumentInsertInput._(this._$data);

  factory Input$DocumentInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = (l$fileName as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = data['originalFileUrl'];
      result$data['originalFileUrl'] = (l$originalFileUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = (l$documentTypeId as String?);
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = (l$contentMarkdown as String?);
    }
    return Input$DocumentInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  String? get fileName => (_$data['fileName'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get originalFileUrl => (_$data['originalFileUrl'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get userId => (_$data['userId'] as String?);

  String? get documentTypeId => (_$data['documentTypeId'] as String?);

  String? get contentMarkdown => (_$data['contentMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = originalFileUrl;
      result$data['originalFileUrl'] = l$originalFileUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId;
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$DocumentInsertInput<Input$DocumentInsertInput> get copyWith =>
      CopyWith$Input$DocumentInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$originalFileUrl = originalFileUrl;
    final lOther$originalFileUrl = other.originalFileUrl;
    if (_$data.containsKey('originalFileUrl') !=
        other._$data.containsKey('originalFileUrl')) {
      return false;
    }
    if (l$originalFileUrl != lOther$originalFileUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$mimeTypeId = mimeTypeId;
    final l$fileName = fileName;
    final l$content = content;
    final l$originalFileUrl = originalFileUrl;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    final l$documentTypeId = documentTypeId;
    final l$contentMarkdown = contentMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('originalFileUrl') ? l$originalFileUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentInsertInput<TRes> {
  factory CopyWith$Input$DocumentInsertInput(
    Input$DocumentInsertInput instance,
    TRes Function(Input$DocumentInsertInput) then,
  ) = _CopyWithImpl$Input$DocumentInsertInput;

  factory CopyWith$Input$DocumentInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentInsertInput;

  TRes call({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  });
}

class _CopyWithImpl$Input$DocumentInsertInput<TRes>
    implements CopyWith$Input$DocumentInsertInput<TRes> {
  _CopyWithImpl$Input$DocumentInsertInput(
    this._instance,
    this._then,
  );

  final Input$DocumentInsertInput _instance;

  final TRes Function(Input$DocumentInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? mimeTypeId = _undefined,
    Object? fileName = _undefined,
    Object? content = _undefined,
    Object? originalFileUrl = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
    Object? documentTypeId = _undefined,
    Object? contentMarkdown = _undefined,
  }) =>
      _then(Input$DocumentInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (fileName != _undefined) 'fileName': (fileName as String?),
        if (content != _undefined) 'content': (content as String?),
        if (originalFileUrl != _undefined)
          'originalFileUrl': (originalFileUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as String?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$DocumentInsertInput<TRes>
    implements CopyWith$Input$DocumentInsertInput<TRes> {
  _CopyWithStubImpl$Input$DocumentInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  }) =>
      _res;
}

class Input$DocumentOrderBy {
  factory Input$DocumentOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? originalFileUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? contentMarkdown,
  }) =>
      Input$DocumentOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (fileName != null) r'fileName': fileName,
        if (content != null) r'content': content,
        if (originalFileUrl != null) r'originalFileUrl': originalFileUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
      });

  Input$DocumentOrderBy._(this._$data);

  factory Input$DocumentOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$mimeTypeId as String));
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = l$fileName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$fileName as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$OrderByDirection((l$content as String));
    }
    if (data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = data['originalFileUrl'];
      result$data['originalFileUrl'] = l$originalFileUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$originalFileUrl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$documentTypeId as String));
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentMarkdown as String));
    }
    return Input$DocumentOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get mimeTypeId =>
      (_$data['mimeTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get fileName =>
      (_$data['fileName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get content =>
      (_$data['content'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get originalFileUrl =>
      (_$data['originalFileUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get documentTypeId =>
      (_$data['documentTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentMarkdown =>
      (_$data['contentMarkdown'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$mimeTypeId);
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] =
          l$fileName == null ? null : toJson$Enum$OrderByDirection(l$fileName);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$OrderByDirection(l$content);
    }
    if (_$data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = originalFileUrl;
      result$data['originalFileUrl'] = l$originalFileUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$originalFileUrl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$documentTypeId);
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentMarkdown);
    }
    return result$data;
  }

  CopyWith$Input$DocumentOrderBy<Input$DocumentOrderBy> get copyWith =>
      CopyWith$Input$DocumentOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$originalFileUrl = originalFileUrl;
    final lOther$originalFileUrl = other.originalFileUrl;
    if (_$data.containsKey('originalFileUrl') !=
        other._$data.containsKey('originalFileUrl')) {
      return false;
    }
    if (l$originalFileUrl != lOther$originalFileUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$mimeTypeId = mimeTypeId;
    final l$fileName = fileName;
    final l$content = content;
    final l$originalFileUrl = originalFileUrl;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    final l$documentTypeId = documentTypeId;
    final l$contentMarkdown = contentMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('originalFileUrl') ? l$originalFileUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentOrderBy<TRes> {
  factory CopyWith$Input$DocumentOrderBy(
    Input$DocumentOrderBy instance,
    TRes Function(Input$DocumentOrderBy) then,
  ) = _CopyWithImpl$Input$DocumentOrderBy;

  factory CopyWith$Input$DocumentOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? originalFileUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? contentMarkdown,
  });
}

class _CopyWithImpl$Input$DocumentOrderBy<TRes>
    implements CopyWith$Input$DocumentOrderBy<TRes> {
  _CopyWithImpl$Input$DocumentOrderBy(
    this._instance,
    this._then,
  );

  final Input$DocumentOrderBy _instance;

  final TRes Function(Input$DocumentOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? mimeTypeId = _undefined,
    Object? fileName = _undefined,
    Object? content = _undefined,
    Object? originalFileUrl = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
    Object? documentTypeId = _undefined,
    Object? contentMarkdown = _undefined,
  }) =>
      _then(Input$DocumentOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (mimeTypeId != _undefined)
          'mimeTypeId': (mimeTypeId as Enum$OrderByDirection?),
        if (fileName != _undefined)
          'fileName': (fileName as Enum$OrderByDirection?),
        if (content != _undefined)
          'content': (content as Enum$OrderByDirection?),
        if (originalFileUrl != _undefined)
          'originalFileUrl': (originalFileUrl as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as Enum$OrderByDirection?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$DocumentOrderBy<TRes>
    implements CopyWith$Input$DocumentOrderBy<TRes> {
  _CopyWithStubImpl$Input$DocumentOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? mimeTypeId,
    Enum$OrderByDirection? fileName,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? originalFileUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? contentMarkdown,
  }) =>
      _res;
}

class Input$DocumentTemplateFilter {
  factory Input$DocumentTemplateFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? template,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$DocumentTemplateFilter>? and,
    List<Input$DocumentTemplateFilter>? or,
    Input$DocumentTemplateFilter? not,
  }) =>
      Input$DocumentTemplateFilter._({
        if (id != null) r'id': id,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (template != null) r'template': template,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$DocumentTemplateFilter._(this._$data);

  factory Input$DocumentTemplateFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$documentTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = l$template == null
          ? null
          : Input$StringFilter.fromJson((l$template as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$DocumentTemplateFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$DocumentTemplateFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$DocumentTemplateFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DocumentTemplateFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get documentTypeId =>
      (_$data['documentTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get template =>
      (_$data['template'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$DocumentTemplateFilter>? get and =>
      (_$data['and'] as List<Input$DocumentTemplateFilter>?);

  List<Input$DocumentTemplateFilter>? get or =>
      (_$data['or'] as List<Input$DocumentTemplateFilter>?);

  Input$DocumentTemplateFilter? get not =>
      (_$data['not'] as Input$DocumentTemplateFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId?.toJson();
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTemplateFilter<Input$DocumentTemplateFilter>
      get copyWith => CopyWith$Input$DocumentTemplateFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTemplateFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$documentTypeId = documentTypeId;
    final l$template = template;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTemplateFilter<TRes> {
  factory CopyWith$Input$DocumentTemplateFilter(
    Input$DocumentTemplateFilter instance,
    TRes Function(Input$DocumentTemplateFilter) then,
  ) = _CopyWithImpl$Input$DocumentTemplateFilter;

  factory CopyWith$Input$DocumentTemplateFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTemplateFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? template,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$DocumentTemplateFilter>? and,
    List<Input$DocumentTemplateFilter>? or,
    Input$DocumentTemplateFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get documentTypeId;
  CopyWith$Input$StringFilter<TRes> get template;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$DocumentTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$DocumentTemplateFilter<
                      Input$DocumentTemplateFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$DocumentTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$DocumentTemplateFilter<
                      Input$DocumentTemplateFilter>>?)
          _fn);
  CopyWith$Input$DocumentTemplateFilter<TRes> get not;
}

class _CopyWithImpl$Input$DocumentTemplateFilter<TRes>
    implements CopyWith$Input$DocumentTemplateFilter<TRes> {
  _CopyWithImpl$Input$DocumentTemplateFilter(
    this._instance,
    this._then,
  );

  final Input$DocumentTemplateFilter _instance;

  final TRes Function(Input$DocumentTemplateFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? documentTypeId = _undefined,
    Object? template = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DocumentTemplateFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as Input$UUIDFilter?),
        if (template != _undefined)
          'template': (template as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$DocumentTemplateFilter>?),
        if (or != _undefined) 'or': (or as List<Input$DocumentTemplateFilter>?),
        if (not != _undefined) 'not': (not as Input$DocumentTemplateFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get documentTypeId {
    final local$documentTypeId = _instance.documentTypeId;
    return local$documentTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$documentTypeId, (e) => call(documentTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get template {
    final local$template = _instance.template;
    return local$template == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$template, (e) => call(template: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$DocumentTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentTemplateFilter<
                          Input$DocumentTemplateFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$DocumentTemplateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$DocumentTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentTemplateFilter<
                          Input$DocumentTemplateFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$DocumentTemplateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DocumentTemplateFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$DocumentTemplateFilter.stub(_then(_instance))
        : CopyWith$Input$DocumentTemplateFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DocumentTemplateFilter<TRes>
    implements CopyWith$Input$DocumentTemplateFilter<TRes> {
  _CopyWithStubImpl$Input$DocumentTemplateFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? documentTypeId,
    Input$StringFilter? template,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$DocumentTemplateFilter>? and,
    List<Input$DocumentTemplateFilter>? or,
    Input$DocumentTemplateFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get documentTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get template =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$DocumentTemplateFilter<TRes> get not =>
      CopyWith$Input$DocumentTemplateFilter.stub(_res);
}

class Input$DocumentTemplateInsertInput {
  factory Input$DocumentTemplateInsertInput({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$DocumentTemplateInsertInput._({
        if (id != null) r'id': id,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (template != null) r'template': template,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$DocumentTemplateInsertInput._(this._$data);

  factory Input$DocumentTemplateInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = (l$documentTypeId as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$DocumentTemplateInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get documentTypeId => (_$data['documentTypeId'] as String?);

  String? get template => (_$data['template'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTemplateInsertInput<Input$DocumentTemplateInsertInput>
      get copyWith => CopyWith$Input$DocumentTemplateInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTemplateInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$documentTypeId = documentTypeId;
    final l$template = template;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTemplateInsertInput<TRes> {
  factory CopyWith$Input$DocumentTemplateInsertInput(
    Input$DocumentTemplateInsertInput instance,
    TRes Function(Input$DocumentTemplateInsertInput) then,
  ) = _CopyWithImpl$Input$DocumentTemplateInsertInput;

  factory CopyWith$Input$DocumentTemplateInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTemplateInsertInput;

  TRes call({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$DocumentTemplateInsertInput<TRes>
    implements CopyWith$Input$DocumentTemplateInsertInput<TRes> {
  _CopyWithImpl$Input$DocumentTemplateInsertInput(
    this._instance,
    this._then,
  );

  final Input$DocumentTemplateInsertInput _instance;

  final TRes Function(Input$DocumentTemplateInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? documentTypeId = _undefined,
    Object? template = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$DocumentTemplateInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as String?),
        if (template != _undefined) 'template': (template as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTemplateInsertInput<TRes>
    implements CopyWith$Input$DocumentTemplateInsertInput<TRes> {
  _CopyWithStubImpl$Input$DocumentTemplateInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$DocumentTemplateOrderBy {
  factory Input$DocumentTemplateOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? template,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$DocumentTemplateOrderBy._({
        if (id != null) r'id': id,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (template != null) r'template': template,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$DocumentTemplateOrderBy._(this._$data);

  factory Input$DocumentTemplateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$documentTypeId as String));
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = l$template == null
          ? null
          : fromJson$Enum$OrderByDirection((l$template as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$DocumentTemplateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get documentTypeId =>
      (_$data['documentTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get template =>
      (_$data['template'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$documentTypeId);
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] =
          l$template == null ? null : toJson$Enum$OrderByDirection(l$template);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$DocumentTemplateOrderBy<Input$DocumentTemplateOrderBy>
      get copyWith => CopyWith$Input$DocumentTemplateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTemplateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$documentTypeId = documentTypeId;
    final l$template = template;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTemplateOrderBy<TRes> {
  factory CopyWith$Input$DocumentTemplateOrderBy(
    Input$DocumentTemplateOrderBy instance,
    TRes Function(Input$DocumentTemplateOrderBy) then,
  ) = _CopyWithImpl$Input$DocumentTemplateOrderBy;

  factory CopyWith$Input$DocumentTemplateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTemplateOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? template,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$DocumentTemplateOrderBy<TRes>
    implements CopyWith$Input$DocumentTemplateOrderBy<TRes> {
  _CopyWithImpl$Input$DocumentTemplateOrderBy(
    this._instance,
    this._then,
  );

  final Input$DocumentTemplateOrderBy _instance;

  final TRes Function(Input$DocumentTemplateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? documentTypeId = _undefined,
    Object? template = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$DocumentTemplateOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as Enum$OrderByDirection?),
        if (template != _undefined)
          'template': (template as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTemplateOrderBy<TRes>
    implements CopyWith$Input$DocumentTemplateOrderBy<TRes> {
  _CopyWithStubImpl$Input$DocumentTemplateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? documentTypeId,
    Enum$OrderByDirection? template,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$DocumentTemplateUpdateInput {
  factory Input$DocumentTemplateUpdateInput({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$DocumentTemplateUpdateInput._({
        if (id != null) r'id': id,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (template != null) r'template': template,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$DocumentTemplateUpdateInput._(this._$data);

  factory Input$DocumentTemplateUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = (l$documentTypeId as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$DocumentTemplateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get documentTypeId => (_$data['documentTypeId'] as String?);

  String? get template => (_$data['template'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTemplateUpdateInput<Input$DocumentTemplateUpdateInput>
      get copyWith => CopyWith$Input$DocumentTemplateUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTemplateUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$documentTypeId = documentTypeId;
    final l$template = template;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTemplateUpdateInput<TRes> {
  factory CopyWith$Input$DocumentTemplateUpdateInput(
    Input$DocumentTemplateUpdateInput instance,
    TRes Function(Input$DocumentTemplateUpdateInput) then,
  ) = _CopyWithImpl$Input$DocumentTemplateUpdateInput;

  factory CopyWith$Input$DocumentTemplateUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTemplateUpdateInput;

  TRes call({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$DocumentTemplateUpdateInput<TRes>
    implements CopyWith$Input$DocumentTemplateUpdateInput<TRes> {
  _CopyWithImpl$Input$DocumentTemplateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DocumentTemplateUpdateInput _instance;

  final TRes Function(Input$DocumentTemplateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? documentTypeId = _undefined,
    Object? template = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$DocumentTemplateUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as String?),
        if (template != _undefined) 'template': (template as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTemplateUpdateInput<TRes>
    implements CopyWith$Input$DocumentTemplateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DocumentTemplateUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? documentTypeId,
    String? template,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$DocumentTypeFilter {
  factory Input$DocumentTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$DocumentTypeFilter>? and,
    List<Input$DocumentTypeFilter>? or,
    Input$DocumentTypeFilter? not,
  }) =>
      Input$DocumentTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$DocumentTypeFilter._(this._$data);

  factory Input$DocumentTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$requiresApproval as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$DocumentTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$DocumentTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$DocumentTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$DocumentTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get requiresApproval =>
      (_$data['requiresApproval'] as Input$BooleanFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$DocumentTypeFilter>? get and =>
      (_$data['and'] as List<Input$DocumentTypeFilter>?);

  List<Input$DocumentTypeFilter>? get or =>
      (_$data['or'] as List<Input$DocumentTypeFilter>?);

  Input$DocumentTypeFilter? get not =>
      (_$data['not'] as Input$DocumentTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTypeFilter<Input$DocumentTypeFilter> get copyWith =>
      CopyWith$Input$DocumentTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTypeFilter<TRes> {
  factory CopyWith$Input$DocumentTypeFilter(
    Input$DocumentTypeFilter instance,
    TRes Function(Input$DocumentTypeFilter) then,
  ) = _CopyWithImpl$Input$DocumentTypeFilter;

  factory CopyWith$Input$DocumentTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$DocumentTypeFilter>? and,
    List<Input$DocumentTypeFilter>? or,
    Input$DocumentTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$BooleanFilter<TRes> get requiresApproval;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$DocumentTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$DocumentTypeFilter<Input$DocumentTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$DocumentTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$DocumentTypeFilter<Input$DocumentTypeFilter>>?)
          _fn);
  CopyWith$Input$DocumentTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$DocumentTypeFilter<TRes>
    implements CopyWith$Input$DocumentTypeFilter<TRes> {
  _CopyWithImpl$Input$DocumentTypeFilter(
    this._instance,
    this._then,
  );

  final Input$DocumentTypeFilter _instance;

  final TRes Function(Input$DocumentTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DocumentTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as Input$BooleanFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$DocumentTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$DocumentTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$DocumentTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get requiresApproval {
    final local$requiresApproval = _instance.requiresApproval;
    return local$requiresApproval == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$requiresApproval, (e) => call(requiresApproval: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$DocumentTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentTypeFilter<
                          Input$DocumentTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$DocumentTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$DocumentTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$DocumentTypeFilter<
                          Input$DocumentTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$DocumentTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$DocumentTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$DocumentTypeFilter.stub(_then(_instance))
        : CopyWith$Input$DocumentTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DocumentTypeFilter<TRes>
    implements CopyWith$Input$DocumentTypeFilter<TRes> {
  _CopyWithStubImpl$Input$DocumentTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? requiresApproval,
    Input$IDFilter? nodeId,
    List<Input$DocumentTypeFilter>? and,
    List<Input$DocumentTypeFilter>? or,
    Input$DocumentTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get requiresApproval =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$DocumentTypeFilter<TRes> get not =>
      CopyWith$Input$DocumentTypeFilter.stub(_res);
}

class Input$DocumentTypeInsertInput {
  factory Input$DocumentTypeInsertInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  }) =>
      Input$DocumentTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
        if (intentKeywords != null) r'intentKeywords': intentKeywords,
      });

  Input$DocumentTypeInsertInput._(this._$data);

  factory Input$DocumentTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = (l$requiresApproval as bool?);
    }
    if (data.containsKey('intentKeywords')) {
      final l$intentKeywords = data['intentKeywords'];
      result$data['intentKeywords'] = (l$intentKeywords as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$DocumentTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get requiresApproval => (_$data['requiresApproval'] as bool?);

  List<String?>? get intentKeywords =>
      (_$data['intentKeywords'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval;
    }
    if (_$data.containsKey('intentKeywords')) {
      final l$intentKeywords = intentKeywords;
      result$data['intentKeywords'] = l$intentKeywords?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTypeInsertInput<Input$DocumentTypeInsertInput>
      get copyWith => CopyWith$Input$DocumentTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    final l$intentKeywords = intentKeywords;
    final lOther$intentKeywords = other.intentKeywords;
    if (_$data.containsKey('intentKeywords') !=
        other._$data.containsKey('intentKeywords')) {
      return false;
    }
    if (l$intentKeywords != null && lOther$intentKeywords != null) {
      if (l$intentKeywords.length != lOther$intentKeywords.length) {
        return false;
      }
      for (int i = 0; i < l$intentKeywords.length; i++) {
        final l$intentKeywords$entry = l$intentKeywords[i];
        final lOther$intentKeywords$entry = lOther$intentKeywords[i];
        if (l$intentKeywords$entry != lOther$intentKeywords$entry) {
          return false;
        }
      }
    } else if (l$intentKeywords != lOther$intentKeywords) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    final l$intentKeywords = intentKeywords;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
      _$data.containsKey('intentKeywords')
          ? l$intentKeywords == null
              ? null
              : Object.hashAll(l$intentKeywords.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTypeInsertInput<TRes> {
  factory CopyWith$Input$DocumentTypeInsertInput(
    Input$DocumentTypeInsertInput instance,
    TRes Function(Input$DocumentTypeInsertInput) then,
  ) = _CopyWithImpl$Input$DocumentTypeInsertInput;

  factory CopyWith$Input$DocumentTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  });
}

class _CopyWithImpl$Input$DocumentTypeInsertInput<TRes>
    implements CopyWith$Input$DocumentTypeInsertInput<TRes> {
  _CopyWithImpl$Input$DocumentTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$DocumentTypeInsertInput _instance;

  final TRes Function(Input$DocumentTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
    Object? intentKeywords = _undefined,
  }) =>
      _then(Input$DocumentTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as bool?),
        if (intentKeywords != _undefined)
          'intentKeywords': (intentKeywords as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTypeInsertInput<TRes>
    implements CopyWith$Input$DocumentTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$DocumentTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  }) =>
      _res;
}

class Input$DocumentTypeOrderBy {
  factory Input$DocumentTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  }) =>
      Input$DocumentTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
      });

  Input$DocumentTypeOrderBy._(this._$data);

  factory Input$DocumentTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : fromJson$Enum$OrderByDirection((l$requiresApproval as String));
    }
    return Input$DocumentTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get requiresApproval =>
      (_$data['requiresApproval'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval == null
          ? null
          : toJson$Enum$OrderByDirection(l$requiresApproval);
    }
    return result$data;
  }

  CopyWith$Input$DocumentTypeOrderBy<Input$DocumentTypeOrderBy> get copyWith =>
      CopyWith$Input$DocumentTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTypeOrderBy<TRes> {
  factory CopyWith$Input$DocumentTypeOrderBy(
    Input$DocumentTypeOrderBy instance,
    TRes Function(Input$DocumentTypeOrderBy) then,
  ) = _CopyWithImpl$Input$DocumentTypeOrderBy;

  factory CopyWith$Input$DocumentTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  });
}

class _CopyWithImpl$Input$DocumentTypeOrderBy<TRes>
    implements CopyWith$Input$DocumentTypeOrderBy<TRes> {
  _CopyWithImpl$Input$DocumentTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$DocumentTypeOrderBy _instance;

  final TRes Function(Input$DocumentTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
  }) =>
      _then(Input$DocumentTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTypeOrderBy<TRes>
    implements CopyWith$Input$DocumentTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$DocumentTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? requiresApproval,
  }) =>
      _res;
}

class Input$DocumentTypeUpdateInput {
  factory Input$DocumentTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  }) =>
      Input$DocumentTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (requiresApproval != null) r'requiresApproval': requiresApproval,
        if (intentKeywords != null) r'intentKeywords': intentKeywords,
      });

  Input$DocumentTypeUpdateInput._(this._$data);

  factory Input$DocumentTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('requiresApproval')) {
      final l$requiresApproval = data['requiresApproval'];
      result$data['requiresApproval'] = (l$requiresApproval as bool?);
    }
    if (data.containsKey('intentKeywords')) {
      final l$intentKeywords = data['intentKeywords'];
      result$data['intentKeywords'] = (l$intentKeywords as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$DocumentTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get requiresApproval => (_$data['requiresApproval'] as bool?);

  List<String?>? get intentKeywords =>
      (_$data['intentKeywords'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('requiresApproval')) {
      final l$requiresApproval = requiresApproval;
      result$data['requiresApproval'] = l$requiresApproval;
    }
    if (_$data.containsKey('intentKeywords')) {
      final l$intentKeywords = intentKeywords;
      result$data['intentKeywords'] = l$intentKeywords?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTypeUpdateInput<Input$DocumentTypeUpdateInput>
      get copyWith => CopyWith$Input$DocumentTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$requiresApproval = requiresApproval;
    final lOther$requiresApproval = other.requiresApproval;
    if (_$data.containsKey('requiresApproval') !=
        other._$data.containsKey('requiresApproval')) {
      return false;
    }
    if (l$requiresApproval != lOther$requiresApproval) {
      return false;
    }
    final l$intentKeywords = intentKeywords;
    final lOther$intentKeywords = other.intentKeywords;
    if (_$data.containsKey('intentKeywords') !=
        other._$data.containsKey('intentKeywords')) {
      return false;
    }
    if (l$intentKeywords != null && lOther$intentKeywords != null) {
      if (l$intentKeywords.length != lOther$intentKeywords.length) {
        return false;
      }
      for (int i = 0; i < l$intentKeywords.length; i++) {
        final l$intentKeywords$entry = l$intentKeywords[i];
        final lOther$intentKeywords$entry = lOther$intentKeywords[i];
        if (l$intentKeywords$entry != lOther$intentKeywords$entry) {
          return false;
        }
      }
    } else if (l$intentKeywords != lOther$intentKeywords) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$requiresApproval = requiresApproval;
    final l$intentKeywords = intentKeywords;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('requiresApproval') ? l$requiresApproval : const {},
      _$data.containsKey('intentKeywords')
          ? l$intentKeywords == null
              ? null
              : Object.hashAll(l$intentKeywords.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTypeUpdateInput<TRes> {
  factory CopyWith$Input$DocumentTypeUpdateInput(
    Input$DocumentTypeUpdateInput instance,
    TRes Function(Input$DocumentTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$DocumentTypeUpdateInput;

  factory CopyWith$Input$DocumentTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  });
}

class _CopyWithImpl$Input$DocumentTypeUpdateInput<TRes>
    implements CopyWith$Input$DocumentTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$DocumentTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DocumentTypeUpdateInput _instance;

  final TRes Function(Input$DocumentTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? requiresApproval = _undefined,
    Object? intentKeywords = _undefined,
  }) =>
      _then(Input$DocumentTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (requiresApproval != _undefined)
          'requiresApproval': (requiresApproval as bool?),
        if (intentKeywords != _undefined)
          'intentKeywords': (intentKeywords as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$DocumentTypeUpdateInput<TRes>
    implements CopyWith$Input$DocumentTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DocumentTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    bool? requiresApproval,
    List<String?>? intentKeywords,
  }) =>
      _res;
}

class Input$DocumentUpdateInput {
  factory Input$DocumentUpdateInput({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  }) =>
      Input$DocumentUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (mimeTypeId != null) r'mimeTypeId': mimeTypeId,
        if (fileName != null) r'fileName': fileName,
        if (content != null) r'content': content,
        if (originalFileUrl != null) r'originalFileUrl': originalFileUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
        if (documentTypeId != null) r'documentTypeId': documentTypeId,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
      });

  Input$DocumentUpdateInput._(this._$data);

  factory Input$DocumentUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = data['mimeTypeId'];
      result$data['mimeTypeId'] = (l$mimeTypeId as String?);
    }
    if (data.containsKey('fileName')) {
      final l$fileName = data['fileName'];
      result$data['fileName'] = (l$fileName as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = data['originalFileUrl'];
      result$data['originalFileUrl'] = (l$originalFileUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('documentTypeId')) {
      final l$documentTypeId = data['documentTypeId'];
      result$data['documentTypeId'] = (l$documentTypeId as String?);
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = (l$contentMarkdown as String?);
    }
    return Input$DocumentUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get mimeTypeId => (_$data['mimeTypeId'] as String?);

  String? get fileName => (_$data['fileName'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get originalFileUrl => (_$data['originalFileUrl'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get userId => (_$data['userId'] as String?);

  String? get documentTypeId => (_$data['documentTypeId'] as String?);

  String? get contentMarkdown => (_$data['contentMarkdown'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('mimeTypeId')) {
      final l$mimeTypeId = mimeTypeId;
      result$data['mimeTypeId'] = l$mimeTypeId;
    }
    if (_$data.containsKey('fileName')) {
      final l$fileName = fileName;
      result$data['fileName'] = l$fileName;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('originalFileUrl')) {
      final l$originalFileUrl = originalFileUrl;
      result$data['originalFileUrl'] = l$originalFileUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('documentTypeId')) {
      final l$documentTypeId = documentTypeId;
      result$data['documentTypeId'] = l$documentTypeId;
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown;
    }
    return result$data;
  }

  CopyWith$Input$DocumentUpdateInput<Input$DocumentUpdateInput> get copyWith =>
      CopyWith$Input$DocumentUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DocumentUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$mimeTypeId = mimeTypeId;
    final lOther$mimeTypeId = other.mimeTypeId;
    if (_$data.containsKey('mimeTypeId') !=
        other._$data.containsKey('mimeTypeId')) {
      return false;
    }
    if (l$mimeTypeId != lOther$mimeTypeId) {
      return false;
    }
    final l$fileName = fileName;
    final lOther$fileName = other.fileName;
    if (_$data.containsKey('fileName') !=
        other._$data.containsKey('fileName')) {
      return false;
    }
    if (l$fileName != lOther$fileName) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$originalFileUrl = originalFileUrl;
    final lOther$originalFileUrl = other.originalFileUrl;
    if (_$data.containsKey('originalFileUrl') !=
        other._$data.containsKey('originalFileUrl')) {
      return false;
    }
    if (l$originalFileUrl != lOther$originalFileUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$documentTypeId = documentTypeId;
    final lOther$documentTypeId = other.documentTypeId;
    if (_$data.containsKey('documentTypeId') !=
        other._$data.containsKey('documentTypeId')) {
      return false;
    }
    if (l$documentTypeId != lOther$documentTypeId) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$mimeTypeId = mimeTypeId;
    final l$fileName = fileName;
    final l$content = content;
    final l$originalFileUrl = originalFileUrl;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    final l$documentTypeId = documentTypeId;
    final l$contentMarkdown = contentMarkdown;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('mimeTypeId') ? l$mimeTypeId : const {},
      _$data.containsKey('fileName') ? l$fileName : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('originalFileUrl') ? l$originalFileUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('documentTypeId') ? l$documentTypeId : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentUpdateInput<TRes> {
  factory CopyWith$Input$DocumentUpdateInput(
    Input$DocumentUpdateInput instance,
    TRes Function(Input$DocumentUpdateInput) then,
  ) = _CopyWithImpl$Input$DocumentUpdateInput;

  factory CopyWith$Input$DocumentUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  });
}

class _CopyWithImpl$Input$DocumentUpdateInput<TRes>
    implements CopyWith$Input$DocumentUpdateInput<TRes> {
  _CopyWithImpl$Input$DocumentUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DocumentUpdateInput _instance;

  final TRes Function(Input$DocumentUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? mimeTypeId = _undefined,
    Object? fileName = _undefined,
    Object? content = _undefined,
    Object? originalFileUrl = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
    Object? documentTypeId = _undefined,
    Object? contentMarkdown = _undefined,
  }) =>
      _then(Input$DocumentUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (mimeTypeId != _undefined) 'mimeTypeId': (mimeTypeId as String?),
        if (fileName != _undefined) 'fileName': (fileName as String?),
        if (content != _undefined) 'content': (content as String?),
        if (originalFileUrl != _undefined)
          'originalFileUrl': (originalFileUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (documentTypeId != _undefined)
          'documentTypeId': (documentTypeId as String?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as String?),
      }));
}

class _CopyWithStubImpl$Input$DocumentUpdateInput<TRes>
    implements CopyWith$Input$DocumentUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DocumentUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? mimeTypeId,
    String? fileName,
    String? content,
    String? originalFileUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userId,
    String? documentTypeId,
    String? contentMarkdown,
  }) =>
      _res;
}

class Input$FeatureFilter {
  factory Input$FeatureFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$FeatureFilter>? and,
    List<Input$FeatureFilter>? or,
    Input$FeatureFilter? not,
  }) =>
      Input$FeatureFilter._({
        if (id != null) r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$FeatureFilter._(this._$data);

  factory Input$FeatureFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$FeatureFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$FeatureFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$FeatureFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$FeatureFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$FeatureFilter>? get and =>
      (_$data['and'] as List<Input$FeatureFilter>?);

  List<Input$FeatureFilter>? get or =>
      (_$data['or'] as List<Input$FeatureFilter>?);

  Input$FeatureFilter? get not => (_$data['not'] as Input$FeatureFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FeatureFilter<Input$FeatureFilter> get copyWith =>
      CopyWith$Input$FeatureFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FeatureFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FeatureFilter<TRes> {
  factory CopyWith$Input$FeatureFilter(
    Input$FeatureFilter instance,
    TRes Function(Input$FeatureFilter) then,
  ) = _CopyWithImpl$Input$FeatureFilter;

  factory CopyWith$Input$FeatureFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FeatureFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$FeatureFilter>? and,
    List<Input$FeatureFilter>? or,
    Input$FeatureFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$FeatureFilter>? Function(
              Iterable<CopyWith$Input$FeatureFilter<Input$FeatureFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$FeatureFilter>? Function(
              Iterable<CopyWith$Input$FeatureFilter<Input$FeatureFilter>>?)
          _fn);
  CopyWith$Input$FeatureFilter<TRes> get not;
}

class _CopyWithImpl$Input$FeatureFilter<TRes>
    implements CopyWith$Input$FeatureFilter<TRes> {
  _CopyWithImpl$Input$FeatureFilter(
    this._instance,
    this._then,
  );

  final Input$FeatureFilter _instance;

  final TRes Function(Input$FeatureFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FeatureFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$FeatureFilter>?),
        if (or != _undefined) 'or': (or as List<Input$FeatureFilter>?),
        if (not != _undefined) 'not': (not as Input$FeatureFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$FeatureFilter>? Function(
                  Iterable<CopyWith$Input$FeatureFilter<Input$FeatureFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$FeatureFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$FeatureFilter>? Function(
                  Iterable<CopyWith$Input$FeatureFilter<Input$FeatureFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$FeatureFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$FeatureFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$FeatureFilter.stub(_then(_instance))
        : CopyWith$Input$FeatureFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FeatureFilter<TRes>
    implements CopyWith$Input$FeatureFilter<TRes> {
  _CopyWithStubImpl$Input$FeatureFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? title,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$FeatureFilter>? and,
    List<Input$FeatureFilter>? or,
    Input$FeatureFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FeatureFilter<TRes> get not =>
      CopyWith$Input$FeatureFilter.stub(_res);
}

class Input$FeatureInsertInput {
  factory Input$FeatureInsertInput({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$FeatureInsertInput._({
        if (id != null) r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$FeatureInsertInput._(this._$data);

  factory Input$FeatureInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$FeatureInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$FeatureInsertInput<Input$FeatureInsertInput> get copyWith =>
      CopyWith$Input$FeatureInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FeatureInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$FeatureInsertInput<TRes> {
  factory CopyWith$Input$FeatureInsertInput(
    Input$FeatureInsertInput instance,
    TRes Function(Input$FeatureInsertInput) then,
  ) = _CopyWithImpl$Input$FeatureInsertInput;

  factory CopyWith$Input$FeatureInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FeatureInsertInput;

  TRes call({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$FeatureInsertInput<TRes>
    implements CopyWith$Input$FeatureInsertInput<TRes> {
  _CopyWithImpl$Input$FeatureInsertInput(
    this._instance,
    this._then,
  );

  final Input$FeatureInsertInput _instance;

  final TRes Function(Input$FeatureInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$FeatureInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$FeatureInsertInput<TRes>
    implements CopyWith$Input$FeatureInsertInput<TRes> {
  _CopyWithStubImpl$Input$FeatureInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

class Input$FeatureOrderBy {
  factory Input$FeatureOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      Input$FeatureOrderBy._({
        if (id != null) r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$FeatureOrderBy._(this._$data);

  factory Input$FeatureOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    return Input$FeatureOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    return result$data;
  }

  CopyWith$Input$FeatureOrderBy<Input$FeatureOrderBy> get copyWith =>
      CopyWith$Input$FeatureOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FeatureOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$FeatureOrderBy<TRes> {
  factory CopyWith$Input$FeatureOrderBy(
    Input$FeatureOrderBy instance,
    TRes Function(Input$FeatureOrderBy) then,
  ) = _CopyWithImpl$Input$FeatureOrderBy;

  factory CopyWith$Input$FeatureOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$FeatureOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  });
}

class _CopyWithImpl$Input$FeatureOrderBy<TRes>
    implements CopyWith$Input$FeatureOrderBy<TRes> {
  _CopyWithImpl$Input$FeatureOrderBy(
    this._instance,
    this._then,
  );

  final Input$FeatureOrderBy _instance;

  final TRes Function(Input$FeatureOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$FeatureOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$FeatureOrderBy<TRes>
    implements CopyWith$Input$FeatureOrderBy<TRes> {
  _CopyWithStubImpl$Input$FeatureOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      _res;
}

class Input$FeatureUpdateInput {
  factory Input$FeatureUpdateInput({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$FeatureUpdateInput._({
        if (id != null) r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$FeatureUpdateInput._(this._$data);

  factory Input$FeatureUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$FeatureUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$FeatureUpdateInput<Input$FeatureUpdateInput> get copyWith =>
      CopyWith$Input$FeatureUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FeatureUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$FeatureUpdateInput<TRes> {
  factory CopyWith$Input$FeatureUpdateInput(
    Input$FeatureUpdateInput instance,
    TRes Function(Input$FeatureUpdateInput) then,
  ) = _CopyWithImpl$Input$FeatureUpdateInput;

  factory CopyWith$Input$FeatureUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FeatureUpdateInput;

  TRes call({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$FeatureUpdateInput<TRes>
    implements CopyWith$Input$FeatureUpdateInput<TRes> {
  _CopyWithImpl$Input$FeatureUpdateInput(
    this._instance,
    this._then,
  );

  final Input$FeatureUpdateInput _instance;

  final TRes Function(Input$FeatureUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$FeatureUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$FeatureUpdateInput<TRes>
    implements CopyWith$Input$FeatureUpdateInput<TRes> {
  _CopyWithStubImpl$Input$FeatureUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? title,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

class Input$FirehouseFilter {
  factory Input$FirehouseFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? address,
    Input$StringFilter? address1,
    Input$StringFilter? city,
    Input$StringFilter? state,
    Input$StringFilter? zip,
    Input$DatetimeFilter? createdAt,
    Input$FloatFilter? latitude,
    Input$FloatFilter? longitude,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$DatetimeFilter? startedAt,
    Input$IDFilter? nodeId,
    List<Input$FirehouseFilter>? and,
    List<Input$FirehouseFilter>? or,
    Input$FirehouseFilter? not,
  }) =>
      Input$FirehouseFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (address1 != null) r'address1': address1,
        if (city != null) r'city': city,
        if (state != null) r'state': state,
        if (zip != null) r'zip': zip,
        if (createdAt != null) r'createdAt': createdAt,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$FirehouseFilter._(this._$data);

  factory Input$FirehouseFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFilter.fromJson((l$address as Map<String, dynamic>));
    }
    if (data.containsKey('address1')) {
      final l$address1 = data['address1'];
      result$data['address1'] = l$address1 == null
          ? null
          : Input$StringFilter.fromJson((l$address1 as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$StringFilter.fromJson((l$city as Map<String, dynamic>));
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : Input$StringFilter.fromJson((l$state as Map<String, dynamic>));
    }
    if (data.containsKey('zip')) {
      final l$zip = data['zip'];
      result$data['zip'] = l$zip == null
          ? null
          : Input$StringFilter.fromJson((l$zip as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = l$latitude == null
          ? null
          : Input$FloatFilter.fromJson((l$latitude as Map<String, dynamic>));
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = l$longitude == null
          ? null
          : Input$FloatFilter.fromJson((l$longitude as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$startedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$FirehouseFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$FirehouseFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$FirehouseFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$FirehouseFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get address => (_$data['address'] as Input$StringFilter?);

  Input$StringFilter? get address1 =>
      (_$data['address1'] as Input$StringFilter?);

  Input$StringFilter? get city => (_$data['city'] as Input$StringFilter?);

  Input$StringFilter? get state => (_$data['state'] as Input$StringFilter?);

  Input$StringFilter? get zip => (_$data['zip'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$FloatFilter? get latitude => (_$data['latitude'] as Input$FloatFilter?);

  Input$FloatFilter? get longitude =>
      (_$data['longitude'] as Input$FloatFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get startedAt =>
      (_$data['startedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$FirehouseFilter>? get and =>
      (_$data['and'] as List<Input$FirehouseFilter>?);

  List<Input$FirehouseFilter>? get or =>
      (_$data['or'] as List<Input$FirehouseFilter>?);

  Input$FirehouseFilter? get not => (_$data['not'] as Input$FirehouseFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('address1')) {
      final l$address1 = address1;
      result$data['address1'] = l$address1?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state?.toJson();
    }
    if (_$data.containsKey('zip')) {
      final l$zip = zip;
      result$data['zip'] = l$zip?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude?.toJson();
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FirehouseFilter<Input$FirehouseFilter> get copyWith =>
      CopyWith$Input$FirehouseFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehouseFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$address1 = address1;
    final lOther$address1 = other.address1;
    if (_$data.containsKey('address1') !=
        other._$data.containsKey('address1')) {
      return false;
    }
    if (l$address1 != lOther$address1) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$zip = zip;
    final lOther$zip = other.zip;
    if (_$data.containsKey('zip') != other._$data.containsKey('zip')) {
      return false;
    }
    if (l$zip != lOther$zip) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$address = address;
    final l$address1 = address1;
    final l$city = city;
    final l$state = state;
    final l$zip = zip;
    final l$createdAt = createdAt;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$startedAt = startedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('address1') ? l$address1 : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('zip') ? l$zip : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehouseFilter<TRes> {
  factory CopyWith$Input$FirehouseFilter(
    Input$FirehouseFilter instance,
    TRes Function(Input$FirehouseFilter) then,
  ) = _CopyWithImpl$Input$FirehouseFilter;

  factory CopyWith$Input$FirehouseFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehouseFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? address,
    Input$StringFilter? address1,
    Input$StringFilter? city,
    Input$StringFilter? state,
    Input$StringFilter? zip,
    Input$DatetimeFilter? createdAt,
    Input$FloatFilter? latitude,
    Input$FloatFilter? longitude,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$DatetimeFilter? startedAt,
    Input$IDFilter? nodeId,
    List<Input$FirehouseFilter>? and,
    List<Input$FirehouseFilter>? or,
    Input$FirehouseFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get address;
  CopyWith$Input$StringFilter<TRes> get address1;
  CopyWith$Input$StringFilter<TRes> get city;
  CopyWith$Input$StringFilter<TRes> get state;
  CopyWith$Input$StringFilter<TRes> get zip;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$FloatFilter<TRes> get latitude;
  CopyWith$Input$FloatFilter<TRes> get longitude;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$DatetimeFilter<TRes> get startedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$FirehouseFilter>? Function(
              Iterable<CopyWith$Input$FirehouseFilter<Input$FirehouseFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$FirehouseFilter>? Function(
              Iterable<CopyWith$Input$FirehouseFilter<Input$FirehouseFilter>>?)
          _fn);
  CopyWith$Input$FirehouseFilter<TRes> get not;
}

class _CopyWithImpl$Input$FirehouseFilter<TRes>
    implements CopyWith$Input$FirehouseFilter<TRes> {
  _CopyWithImpl$Input$FirehouseFilter(
    this._instance,
    this._then,
  );

  final Input$FirehouseFilter _instance;

  final TRes Function(Input$FirehouseFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? address1 = _undefined,
    Object? city = _undefined,
    Object? state = _undefined,
    Object? zip = _undefined,
    Object? createdAt = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? startedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FirehouseFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (address != _undefined) 'address': (address as Input$StringFilter?),
        if (address1 != _undefined)
          'address1': (address1 as Input$StringFilter?),
        if (city != _undefined) 'city': (city as Input$StringFilter?),
        if (state != _undefined) 'state': (state as Input$StringFilter?),
        if (zip != _undefined) 'zip': (zip as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (latitude != _undefined)
          'latitude': (latitude as Input$FloatFilter?),
        if (longitude != _undefined)
          'longitude': (longitude as Input$FloatFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$FirehouseFilter>?),
        if (or != _undefined) 'or': (or as List<Input$FirehouseFilter>?),
        if (not != _undefined) 'not': (not as Input$FirehouseFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$address, (e) => call(address: e));
  }

  CopyWith$Input$StringFilter<TRes> get address1 {
    final local$address1 = _instance.address1;
    return local$address1 == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$address1, (e) => call(address1: e));
  }

  CopyWith$Input$StringFilter<TRes> get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$city, (e) => call(city: e));
  }

  CopyWith$Input$StringFilter<TRes> get state {
    final local$state = _instance.state;
    return local$state == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$state, (e) => call(state: e));
  }

  CopyWith$Input$StringFilter<TRes> get zip {
    final local$zip = _instance.zip;
    return local$zip == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$zip, (e) => call(zip: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$FloatFilter<TRes> get latitude {
    final local$latitude = _instance.latitude;
    return local$latitude == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$latitude, (e) => call(latitude: e));
  }

  CopyWith$Input$FloatFilter<TRes> get longitude {
    final local$longitude = _instance.longitude;
    return local$longitude == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$longitude, (e) => call(longitude: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get startedAt {
    final local$startedAt = _instance.startedAt;
    return local$startedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$startedAt, (e) => call(startedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$FirehouseFilter>? Function(
                  Iterable<
                      CopyWith$Input$FirehouseFilter<Input$FirehouseFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$FirehouseFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$FirehouseFilter>? Function(
                  Iterable<
                      CopyWith$Input$FirehouseFilter<Input$FirehouseFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$FirehouseFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$FirehouseFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$FirehouseFilter.stub(_then(_instance))
        : CopyWith$Input$FirehouseFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FirehouseFilter<TRes>
    implements CopyWith$Input$FirehouseFilter<TRes> {
  _CopyWithStubImpl$Input$FirehouseFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? address,
    Input$StringFilter? address1,
    Input$StringFilter? city,
    Input$StringFilter? state,
    Input$StringFilter? zip,
    Input$DatetimeFilter? createdAt,
    Input$FloatFilter? latitude,
    Input$FloatFilter? longitude,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$DatetimeFilter? startedAt,
    Input$IDFilter? nodeId,
    List<Input$FirehouseFilter>? and,
    List<Input$FirehouseFilter>? or,
    Input$FirehouseFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get address =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get address1 =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get city =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get state =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get zip =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$FloatFilter<TRes> get latitude =>
      CopyWith$Input$FloatFilter.stub(_res);

  CopyWith$Input$FloatFilter<TRes> get longitude =>
      CopyWith$Input$FloatFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get startedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FirehouseFilter<TRes> get not =>
      CopyWith$Input$FirehouseFilter.stub(_res);
}

class Input$FirehouseInsertInput {
  factory Input$FirehouseInsertInput({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  }) =>
      Input$FirehouseInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (address1 != null) r'address1': address1,
        if (city != null) r'city': city,
        if (state != null) r'state': state,
        if (zip != null) r'zip': zip,
        if (createdAt != null) r'createdAt': createdAt,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (startedAt != null) r'startedAt': startedAt,
      });

  Input$FirehouseInsertInput._(this._$data);

  factory Input$FirehouseInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('address1')) {
      final l$address1 = data['address1'];
      result$data['address1'] = (l$address1 as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('zip')) {
      final l$zip = data['zip'];
      result$data['zip'] = (l$zip as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    return Input$FirehouseInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get address1 => (_$data['address1'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get zip => (_$data['zip'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('address1')) {
      final l$address1 = address1;
      result$data['address1'] = l$address1;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('zip')) {
      final l$zip = zip;
      result$data['zip'] = l$zip;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FirehouseInsertInput<Input$FirehouseInsertInput>
      get copyWith => CopyWith$Input$FirehouseInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehouseInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$address1 = address1;
    final lOther$address1 = other.address1;
    if (_$data.containsKey('address1') !=
        other._$data.containsKey('address1')) {
      return false;
    }
    if (l$address1 != lOther$address1) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$zip = zip;
    final lOther$zip = other.zip;
    if (_$data.containsKey('zip') != other._$data.containsKey('zip')) {
      return false;
    }
    if (l$zip != lOther$zip) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$address = address;
    final l$address1 = address1;
    final l$city = city;
    final l$state = state;
    final l$zip = zip;
    final l$createdAt = createdAt;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$startedAt = startedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('address1') ? l$address1 : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('zip') ? l$zip : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehouseInsertInput<TRes> {
  factory CopyWith$Input$FirehouseInsertInput(
    Input$FirehouseInsertInput instance,
    TRes Function(Input$FirehouseInsertInput) then,
  ) = _CopyWithImpl$Input$FirehouseInsertInput;

  factory CopyWith$Input$FirehouseInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehouseInsertInput;

  TRes call({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  });
}

class _CopyWithImpl$Input$FirehouseInsertInput<TRes>
    implements CopyWith$Input$FirehouseInsertInput<TRes> {
  _CopyWithImpl$Input$FirehouseInsertInput(
    this._instance,
    this._then,
  );

  final Input$FirehouseInsertInput _instance;

  final TRes Function(Input$FirehouseInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? address1 = _undefined,
    Object? city = _undefined,
    Object? state = _undefined,
    Object? zip = _undefined,
    Object? createdAt = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? startedAt = _undefined,
  }) =>
      _then(Input$FirehouseInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (address != _undefined) 'address': (address as String?),
        if (address1 != _undefined) 'address1': (address1 as String?),
        if (city != _undefined) 'city': (city as String?),
        if (state != _undefined) 'state': (state as String?),
        if (zip != _undefined) 'zip': (zip as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FirehouseInsertInput<TRes>
    implements CopyWith$Input$FirehouseInsertInput<TRes> {
  _CopyWithStubImpl$Input$FirehouseInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  }) =>
      _res;
}

class Input$FirehouseOrderBy {
  factory Input$FirehouseOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? address,
    Enum$OrderByDirection? address1,
    Enum$OrderByDirection? city,
    Enum$OrderByDirection? state,
    Enum$OrderByDirection? zip,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? latitude,
    Enum$OrderByDirection? longitude,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? startedAt,
  }) =>
      Input$FirehouseOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (address1 != null) r'address1': address1,
        if (city != null) r'city': city,
        if (state != null) r'state': state,
        if (zip != null) r'zip': zip,
        if (createdAt != null) r'createdAt': createdAt,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (startedAt != null) r'startedAt': startedAt,
      });

  Input$FirehouseOrderBy._(this._$data);

  factory Input$FirehouseOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$OrderByDirection((l$address as String));
    }
    if (data.containsKey('address1')) {
      final l$address1 = data['address1'];
      result$data['address1'] = l$address1 == null
          ? null
          : fromJson$Enum$OrderByDirection((l$address1 as String));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : fromJson$Enum$OrderByDirection((l$city as String));
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$OrderByDirection((l$state as String));
    }
    if (data.containsKey('zip')) {
      final l$zip = data['zip'];
      result$data['zip'] = l$zip == null
          ? null
          : fromJson$Enum$OrderByDirection((l$zip as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = l$latitude == null
          ? null
          : fromJson$Enum$OrderByDirection((l$latitude as String));
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = l$longitude == null
          ? null
          : fromJson$Enum$OrderByDirection((l$longitude as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$startedAt as String));
    }
    return Input$FirehouseOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get address =>
      (_$data['address'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get address1 =>
      (_$data['address1'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get city => (_$data['city'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get state =>
      (_$data['state'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get zip => (_$data['zip'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get latitude =>
      (_$data['latitude'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longitude =>
      (_$data['longitude'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get startedAt =>
      (_$data['startedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$OrderByDirection(l$address);
    }
    if (_$data.containsKey('address1')) {
      final l$address1 = address1;
      result$data['address1'] =
          l$address1 == null ? null : toJson$Enum$OrderByDirection(l$address1);
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] =
          l$city == null ? null : toJson$Enum$OrderByDirection(l$city);
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$OrderByDirection(l$state);
    }
    if (_$data.containsKey('zip')) {
      final l$zip = zip;
      result$data['zip'] =
          l$zip == null ? null : toJson$Enum$OrderByDirection(l$zip);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] =
          l$latitude == null ? null : toJson$Enum$OrderByDirection(l$latitude);
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude == null
          ? null
          : toJson$Enum$OrderByDirection(l$longitude);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$startedAt);
    }
    return result$data;
  }

  CopyWith$Input$FirehouseOrderBy<Input$FirehouseOrderBy> get copyWith =>
      CopyWith$Input$FirehouseOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehouseOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$address1 = address1;
    final lOther$address1 = other.address1;
    if (_$data.containsKey('address1') !=
        other._$data.containsKey('address1')) {
      return false;
    }
    if (l$address1 != lOther$address1) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$zip = zip;
    final lOther$zip = other.zip;
    if (_$data.containsKey('zip') != other._$data.containsKey('zip')) {
      return false;
    }
    if (l$zip != lOther$zip) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$address = address;
    final l$address1 = address1;
    final l$city = city;
    final l$state = state;
    final l$zip = zip;
    final l$createdAt = createdAt;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$startedAt = startedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('address1') ? l$address1 : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('zip') ? l$zip : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehouseOrderBy<TRes> {
  factory CopyWith$Input$FirehouseOrderBy(
    Input$FirehouseOrderBy instance,
    TRes Function(Input$FirehouseOrderBy) then,
  ) = _CopyWithImpl$Input$FirehouseOrderBy;

  factory CopyWith$Input$FirehouseOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehouseOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? address,
    Enum$OrderByDirection? address1,
    Enum$OrderByDirection? city,
    Enum$OrderByDirection? state,
    Enum$OrderByDirection? zip,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? latitude,
    Enum$OrderByDirection? longitude,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? startedAt,
  });
}

class _CopyWithImpl$Input$FirehouseOrderBy<TRes>
    implements CopyWith$Input$FirehouseOrderBy<TRes> {
  _CopyWithImpl$Input$FirehouseOrderBy(
    this._instance,
    this._then,
  );

  final Input$FirehouseOrderBy _instance;

  final TRes Function(Input$FirehouseOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? address1 = _undefined,
    Object? city = _undefined,
    Object? state = _undefined,
    Object? zip = _undefined,
    Object? createdAt = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? startedAt = _undefined,
  }) =>
      _then(Input$FirehouseOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (address != _undefined)
          'address': (address as Enum$OrderByDirection?),
        if (address1 != _undefined)
          'address1': (address1 as Enum$OrderByDirection?),
        if (city != _undefined) 'city': (city as Enum$OrderByDirection?),
        if (state != _undefined) 'state': (state as Enum$OrderByDirection?),
        if (zip != _undefined) 'zip': (zip as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (latitude != _undefined)
          'latitude': (latitude as Enum$OrderByDirection?),
        if (longitude != _undefined)
          'longitude': (longitude as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$FirehouseOrderBy<TRes>
    implements CopyWith$Input$FirehouseOrderBy<TRes> {
  _CopyWithStubImpl$Input$FirehouseOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? address,
    Enum$OrderByDirection? address1,
    Enum$OrderByDirection? city,
    Enum$OrderByDirection? state,
    Enum$OrderByDirection? zip,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? latitude,
    Enum$OrderByDirection? longitude,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? startedAt,
  }) =>
      _res;
}

class Input$FirehousePartnerFilter {
  factory Input$FirehousePartnerFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? firehouseId,
    Input$UUIDFilter? partnerId,
    Input$IDFilter? nodeId,
    List<Input$FirehousePartnerFilter>? and,
    List<Input$FirehousePartnerFilter>? or,
    Input$FirehousePartnerFilter? not,
  }) =>
      Input$FirehousePartnerFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (firehouseId != null) r'firehouseId': firehouseId,
        if (partnerId != null) r'partnerId': partnerId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$FirehousePartnerFilter._(this._$data);

  factory Input$FirehousePartnerFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('firehouseId')) {
      final l$firehouseId = data['firehouseId'];
      result$data['firehouseId'] = l$firehouseId == null
          ? null
          : Input$UUIDFilter.fromJson((l$firehouseId as Map<String, dynamic>));
    }
    if (data.containsKey('partnerId')) {
      final l$partnerId = data['partnerId'];
      result$data['partnerId'] = l$partnerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$partnerId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$FirehousePartnerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$FirehousePartnerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$FirehousePartnerFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$FirehousePartnerFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get firehouseId =>
      (_$data['firehouseId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get partnerId => (_$data['partnerId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$FirehousePartnerFilter>? get and =>
      (_$data['and'] as List<Input$FirehousePartnerFilter>?);

  List<Input$FirehousePartnerFilter>? get or =>
      (_$data['or'] as List<Input$FirehousePartnerFilter>?);

  Input$FirehousePartnerFilter? get not =>
      (_$data['not'] as Input$FirehousePartnerFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('firehouseId')) {
      final l$firehouseId = firehouseId;
      result$data['firehouseId'] = l$firehouseId?.toJson();
    }
    if (_$data.containsKey('partnerId')) {
      final l$partnerId = partnerId;
      result$data['partnerId'] = l$partnerId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FirehousePartnerFilter<Input$FirehousePartnerFilter>
      get copyWith => CopyWith$Input$FirehousePartnerFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehousePartnerFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$firehouseId = firehouseId;
    final lOther$firehouseId = other.firehouseId;
    if (_$data.containsKey('firehouseId') !=
        other._$data.containsKey('firehouseId')) {
      return false;
    }
    if (l$firehouseId != lOther$firehouseId) {
      return false;
    }
    final l$partnerId = partnerId;
    final lOther$partnerId = other.partnerId;
    if (_$data.containsKey('partnerId') !=
        other._$data.containsKey('partnerId')) {
      return false;
    }
    if (l$partnerId != lOther$partnerId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$firehouseId = firehouseId;
    final l$partnerId = partnerId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('firehouseId') ? l$firehouseId : const {},
      _$data.containsKey('partnerId') ? l$partnerId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehousePartnerFilter<TRes> {
  factory CopyWith$Input$FirehousePartnerFilter(
    Input$FirehousePartnerFilter instance,
    TRes Function(Input$FirehousePartnerFilter) then,
  ) = _CopyWithImpl$Input$FirehousePartnerFilter;

  factory CopyWith$Input$FirehousePartnerFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehousePartnerFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? firehouseId,
    Input$UUIDFilter? partnerId,
    Input$IDFilter? nodeId,
    List<Input$FirehousePartnerFilter>? and,
    List<Input$FirehousePartnerFilter>? or,
    Input$FirehousePartnerFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get firehouseId;
  CopyWith$Input$UUIDFilter<TRes> get partnerId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$FirehousePartnerFilter>? Function(
              Iterable<
                  CopyWith$Input$FirehousePartnerFilter<
                      Input$FirehousePartnerFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$FirehousePartnerFilter>? Function(
              Iterable<
                  CopyWith$Input$FirehousePartnerFilter<
                      Input$FirehousePartnerFilter>>?)
          _fn);
  CopyWith$Input$FirehousePartnerFilter<TRes> get not;
}

class _CopyWithImpl$Input$FirehousePartnerFilter<TRes>
    implements CopyWith$Input$FirehousePartnerFilter<TRes> {
  _CopyWithImpl$Input$FirehousePartnerFilter(
    this._instance,
    this._then,
  );

  final Input$FirehousePartnerFilter _instance;

  final TRes Function(Input$FirehousePartnerFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? firehouseId = _undefined,
    Object? partnerId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FirehousePartnerFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (firehouseId != _undefined)
          'firehouseId': (firehouseId as Input$UUIDFilter?),
        if (partnerId != _undefined)
          'partnerId': (partnerId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$FirehousePartnerFilter>?),
        if (or != _undefined) 'or': (or as List<Input$FirehousePartnerFilter>?),
        if (not != _undefined) 'not': (not as Input$FirehousePartnerFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get firehouseId {
    final local$firehouseId = _instance.firehouseId;
    return local$firehouseId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$firehouseId, (e) => call(firehouseId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get partnerId {
    final local$partnerId = _instance.partnerId;
    return local$partnerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$partnerId, (e) => call(partnerId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$FirehousePartnerFilter>? Function(
                  Iterable<
                      CopyWith$Input$FirehousePartnerFilter<
                          Input$FirehousePartnerFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$FirehousePartnerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$FirehousePartnerFilter>? Function(
                  Iterable<
                      CopyWith$Input$FirehousePartnerFilter<
                          Input$FirehousePartnerFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$FirehousePartnerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$FirehousePartnerFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$FirehousePartnerFilter.stub(_then(_instance))
        : CopyWith$Input$FirehousePartnerFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FirehousePartnerFilter<TRes>
    implements CopyWith$Input$FirehousePartnerFilter<TRes> {
  _CopyWithStubImpl$Input$FirehousePartnerFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? firehouseId,
    Input$UUIDFilter? partnerId,
    Input$IDFilter? nodeId,
    List<Input$FirehousePartnerFilter>? and,
    List<Input$FirehousePartnerFilter>? or,
    Input$FirehousePartnerFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get firehouseId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get partnerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FirehousePartnerFilter<TRes> get not =>
      CopyWith$Input$FirehousePartnerFilter.stub(_res);
}

class Input$FirehousePartnerInsertInput {
  factory Input$FirehousePartnerInsertInput({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  }) =>
      Input$FirehousePartnerInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (firehouseId != null) r'firehouseId': firehouseId,
        if (partnerId != null) r'partnerId': partnerId,
      });

  Input$FirehousePartnerInsertInput._(this._$data);

  factory Input$FirehousePartnerInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('firehouseId')) {
      final l$firehouseId = data['firehouseId'];
      result$data['firehouseId'] = (l$firehouseId as String?);
    }
    if (data.containsKey('partnerId')) {
      final l$partnerId = data['partnerId'];
      result$data['partnerId'] = (l$partnerId as String?);
    }
    return Input$FirehousePartnerInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get firehouseId => (_$data['firehouseId'] as String?);

  String? get partnerId => (_$data['partnerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('firehouseId')) {
      final l$firehouseId = firehouseId;
      result$data['firehouseId'] = l$firehouseId;
    }
    if (_$data.containsKey('partnerId')) {
      final l$partnerId = partnerId;
      result$data['partnerId'] = l$partnerId;
    }
    return result$data;
  }

  CopyWith$Input$FirehousePartnerInsertInput<Input$FirehousePartnerInsertInput>
      get copyWith => CopyWith$Input$FirehousePartnerInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehousePartnerInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$firehouseId = firehouseId;
    final lOther$firehouseId = other.firehouseId;
    if (_$data.containsKey('firehouseId') !=
        other._$data.containsKey('firehouseId')) {
      return false;
    }
    if (l$firehouseId != lOther$firehouseId) {
      return false;
    }
    final l$partnerId = partnerId;
    final lOther$partnerId = other.partnerId;
    if (_$data.containsKey('partnerId') !=
        other._$data.containsKey('partnerId')) {
      return false;
    }
    if (l$partnerId != lOther$partnerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$firehouseId = firehouseId;
    final l$partnerId = partnerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('firehouseId') ? l$firehouseId : const {},
      _$data.containsKey('partnerId') ? l$partnerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehousePartnerInsertInput<TRes> {
  factory CopyWith$Input$FirehousePartnerInsertInput(
    Input$FirehousePartnerInsertInput instance,
    TRes Function(Input$FirehousePartnerInsertInput) then,
  ) = _CopyWithImpl$Input$FirehousePartnerInsertInput;

  factory CopyWith$Input$FirehousePartnerInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehousePartnerInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  });
}

class _CopyWithImpl$Input$FirehousePartnerInsertInput<TRes>
    implements CopyWith$Input$FirehousePartnerInsertInput<TRes> {
  _CopyWithImpl$Input$FirehousePartnerInsertInput(
    this._instance,
    this._then,
  );

  final Input$FirehousePartnerInsertInput _instance;

  final TRes Function(Input$FirehousePartnerInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? firehouseId = _undefined,
    Object? partnerId = _undefined,
  }) =>
      _then(Input$FirehousePartnerInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (firehouseId != _undefined) 'firehouseId': (firehouseId as String?),
        if (partnerId != _undefined) 'partnerId': (partnerId as String?),
      }));
}

class _CopyWithStubImpl$Input$FirehousePartnerInsertInput<TRes>
    implements CopyWith$Input$FirehousePartnerInsertInput<TRes> {
  _CopyWithStubImpl$Input$FirehousePartnerInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  }) =>
      _res;
}

class Input$FirehousePartnerOrderBy {
  factory Input$FirehousePartnerOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? firehouseId,
    Enum$OrderByDirection? partnerId,
  }) =>
      Input$FirehousePartnerOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (firehouseId != null) r'firehouseId': firehouseId,
        if (partnerId != null) r'partnerId': partnerId,
      });

  Input$FirehousePartnerOrderBy._(this._$data);

  factory Input$FirehousePartnerOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('firehouseId')) {
      final l$firehouseId = data['firehouseId'];
      result$data['firehouseId'] = l$firehouseId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$firehouseId as String));
    }
    if (data.containsKey('partnerId')) {
      final l$partnerId = data['partnerId'];
      result$data['partnerId'] = l$partnerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$partnerId as String));
    }
    return Input$FirehousePartnerOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get firehouseId =>
      (_$data['firehouseId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get partnerId =>
      (_$data['partnerId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('firehouseId')) {
      final l$firehouseId = firehouseId;
      result$data['firehouseId'] = l$firehouseId == null
          ? null
          : toJson$Enum$OrderByDirection(l$firehouseId);
    }
    if (_$data.containsKey('partnerId')) {
      final l$partnerId = partnerId;
      result$data['partnerId'] = l$partnerId == null
          ? null
          : toJson$Enum$OrderByDirection(l$partnerId);
    }
    return result$data;
  }

  CopyWith$Input$FirehousePartnerOrderBy<Input$FirehousePartnerOrderBy>
      get copyWith => CopyWith$Input$FirehousePartnerOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehousePartnerOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$firehouseId = firehouseId;
    final lOther$firehouseId = other.firehouseId;
    if (_$data.containsKey('firehouseId') !=
        other._$data.containsKey('firehouseId')) {
      return false;
    }
    if (l$firehouseId != lOther$firehouseId) {
      return false;
    }
    final l$partnerId = partnerId;
    final lOther$partnerId = other.partnerId;
    if (_$data.containsKey('partnerId') !=
        other._$data.containsKey('partnerId')) {
      return false;
    }
    if (l$partnerId != lOther$partnerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$firehouseId = firehouseId;
    final l$partnerId = partnerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('firehouseId') ? l$firehouseId : const {},
      _$data.containsKey('partnerId') ? l$partnerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehousePartnerOrderBy<TRes> {
  factory CopyWith$Input$FirehousePartnerOrderBy(
    Input$FirehousePartnerOrderBy instance,
    TRes Function(Input$FirehousePartnerOrderBy) then,
  ) = _CopyWithImpl$Input$FirehousePartnerOrderBy;

  factory CopyWith$Input$FirehousePartnerOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehousePartnerOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? firehouseId,
    Enum$OrderByDirection? partnerId,
  });
}

class _CopyWithImpl$Input$FirehousePartnerOrderBy<TRes>
    implements CopyWith$Input$FirehousePartnerOrderBy<TRes> {
  _CopyWithImpl$Input$FirehousePartnerOrderBy(
    this._instance,
    this._then,
  );

  final Input$FirehousePartnerOrderBy _instance;

  final TRes Function(Input$FirehousePartnerOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? firehouseId = _undefined,
    Object? partnerId = _undefined,
  }) =>
      _then(Input$FirehousePartnerOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (firehouseId != _undefined)
          'firehouseId': (firehouseId as Enum$OrderByDirection?),
        if (partnerId != _undefined)
          'partnerId': (partnerId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$FirehousePartnerOrderBy<TRes>
    implements CopyWith$Input$FirehousePartnerOrderBy<TRes> {
  _CopyWithStubImpl$Input$FirehousePartnerOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? firehouseId,
    Enum$OrderByDirection? partnerId,
  }) =>
      _res;
}

class Input$FirehousePartnerUpdateInput {
  factory Input$FirehousePartnerUpdateInput({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  }) =>
      Input$FirehousePartnerUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (firehouseId != null) r'firehouseId': firehouseId,
        if (partnerId != null) r'partnerId': partnerId,
      });

  Input$FirehousePartnerUpdateInput._(this._$data);

  factory Input$FirehousePartnerUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('firehouseId')) {
      final l$firehouseId = data['firehouseId'];
      result$data['firehouseId'] = (l$firehouseId as String?);
    }
    if (data.containsKey('partnerId')) {
      final l$partnerId = data['partnerId'];
      result$data['partnerId'] = (l$partnerId as String?);
    }
    return Input$FirehousePartnerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get firehouseId => (_$data['firehouseId'] as String?);

  String? get partnerId => (_$data['partnerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('firehouseId')) {
      final l$firehouseId = firehouseId;
      result$data['firehouseId'] = l$firehouseId;
    }
    if (_$data.containsKey('partnerId')) {
      final l$partnerId = partnerId;
      result$data['partnerId'] = l$partnerId;
    }
    return result$data;
  }

  CopyWith$Input$FirehousePartnerUpdateInput<Input$FirehousePartnerUpdateInput>
      get copyWith => CopyWith$Input$FirehousePartnerUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehousePartnerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$firehouseId = firehouseId;
    final lOther$firehouseId = other.firehouseId;
    if (_$data.containsKey('firehouseId') !=
        other._$data.containsKey('firehouseId')) {
      return false;
    }
    if (l$firehouseId != lOther$firehouseId) {
      return false;
    }
    final l$partnerId = partnerId;
    final lOther$partnerId = other.partnerId;
    if (_$data.containsKey('partnerId') !=
        other._$data.containsKey('partnerId')) {
      return false;
    }
    if (l$partnerId != lOther$partnerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$firehouseId = firehouseId;
    final l$partnerId = partnerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('firehouseId') ? l$firehouseId : const {},
      _$data.containsKey('partnerId') ? l$partnerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehousePartnerUpdateInput<TRes> {
  factory CopyWith$Input$FirehousePartnerUpdateInput(
    Input$FirehousePartnerUpdateInput instance,
    TRes Function(Input$FirehousePartnerUpdateInput) then,
  ) = _CopyWithImpl$Input$FirehousePartnerUpdateInput;

  factory CopyWith$Input$FirehousePartnerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehousePartnerUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  });
}

class _CopyWithImpl$Input$FirehousePartnerUpdateInput<TRes>
    implements CopyWith$Input$FirehousePartnerUpdateInput<TRes> {
  _CopyWithImpl$Input$FirehousePartnerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$FirehousePartnerUpdateInput _instance;

  final TRes Function(Input$FirehousePartnerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? firehouseId = _undefined,
    Object? partnerId = _undefined,
  }) =>
      _then(Input$FirehousePartnerUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (firehouseId != _undefined) 'firehouseId': (firehouseId as String?),
        if (partnerId != _undefined) 'partnerId': (partnerId as String?),
      }));
}

class _CopyWithStubImpl$Input$FirehousePartnerUpdateInput<TRes>
    implements CopyWith$Input$FirehousePartnerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$FirehousePartnerUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? firehouseId,
    String? partnerId,
  }) =>
      _res;
}

class Input$FirehouseUpdateInput {
  factory Input$FirehouseUpdateInput({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  }) =>
      Input$FirehouseUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (address1 != null) r'address1': address1,
        if (city != null) r'city': city,
        if (state != null) r'state': state,
        if (zip != null) r'zip': zip,
        if (createdAt != null) r'createdAt': createdAt,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (startedAt != null) r'startedAt': startedAt,
      });

  Input$FirehouseUpdateInput._(this._$data);

  factory Input$FirehouseUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('address1')) {
      final l$address1 = data['address1'];
      result$data['address1'] = (l$address1 as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('zip')) {
      final l$zip = data['zip'];
      result$data['zip'] = (l$zip as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    return Input$FirehouseUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get address1 => (_$data['address1'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get zip => (_$data['zip'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('address1')) {
      final l$address1 = address1;
      result$data['address1'] = l$address1;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('zip')) {
      final l$zip = zip;
      result$data['zip'] = l$zip;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FirehouseUpdateInput<Input$FirehouseUpdateInput>
      get copyWith => CopyWith$Input$FirehouseUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FirehouseUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$address1 = address1;
    final lOther$address1 = other.address1;
    if (_$data.containsKey('address1') !=
        other._$data.containsKey('address1')) {
      return false;
    }
    if (l$address1 != lOther$address1) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$zip = zip;
    final lOther$zip = other.zip;
    if (_$data.containsKey('zip') != other._$data.containsKey('zip')) {
      return false;
    }
    if (l$zip != lOther$zip) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$address = address;
    final l$address1 = address1;
    final l$city = city;
    final l$state = state;
    final l$zip = zip;
    final l$createdAt = createdAt;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$startedAt = startedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('address1') ? l$address1 : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('zip') ? l$zip : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FirehouseUpdateInput<TRes> {
  factory CopyWith$Input$FirehouseUpdateInput(
    Input$FirehouseUpdateInput instance,
    TRes Function(Input$FirehouseUpdateInput) then,
  ) = _CopyWithImpl$Input$FirehouseUpdateInput;

  factory CopyWith$Input$FirehouseUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FirehouseUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  });
}

class _CopyWithImpl$Input$FirehouseUpdateInput<TRes>
    implements CopyWith$Input$FirehouseUpdateInput<TRes> {
  _CopyWithImpl$Input$FirehouseUpdateInput(
    this._instance,
    this._then,
  );

  final Input$FirehouseUpdateInput _instance;

  final TRes Function(Input$FirehouseUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? address1 = _undefined,
    Object? city = _undefined,
    Object? state = _undefined,
    Object? zip = _undefined,
    Object? createdAt = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? startedAt = _undefined,
  }) =>
      _then(Input$FirehouseUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (address != _undefined) 'address': (address as String?),
        if (address1 != _undefined) 'address1': (address1 as String?),
        if (city != _undefined) 'city': (city as String?),
        if (state != _undefined) 'state': (state as String?),
        if (zip != _undefined) 'zip': (zip as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FirehouseUpdateInput<TRes>
    implements CopyWith$Input$FirehouseUpdateInput<TRes> {
  _CopyWithStubImpl$Input$FirehouseUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? address,
    String? address1,
    String? city,
    String? state,
    String? zip,
    DateTime? createdAt,
    double? latitude,
    double? longitude,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? updatedAt,
    DateTime? startedAt,
  }) =>
      _res;
}

class Input$FloatFilter {
  factory Input$FloatFilter({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  }) =>
      Input$FloatFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$FloatFilter._(this._$data);

  factory Input$FloatFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as num?)?.toDouble();
    }
    return Input$FloatFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get eq => (_$data['eq'] as double?);

  double? get gt => (_$data['gt'] as double?);

  double? get gte => (_$data['gte'] as double?);

  List<double>? get $in => (_$data['in'] as List<double>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  double? get lt => (_$data['lt'] as double?);

  double? get lte => (_$data['lte'] as double?);

  double? get neq => (_$data['neq'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$FloatFilter<Input$FloatFilter> get copyWith =>
      CopyWith$Input$FloatFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FloatFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatFilter<TRes> {
  factory CopyWith$Input$FloatFilter(
    Input$FloatFilter instance,
    TRes Function(Input$FloatFilter) then,
  ) = _CopyWithImpl$Input$FloatFilter;

  factory CopyWith$Input$FloatFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatFilter;

  TRes call({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  });
}

class _CopyWithImpl$Input$FloatFilter<TRes>
    implements CopyWith$Input$FloatFilter<TRes> {
  _CopyWithImpl$Input$FloatFilter(
    this._instance,
    this._then,
  );

  final Input$FloatFilter _instance;

  final TRes Function(Input$FloatFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$FloatFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (neq != _undefined) 'neq': (neq as double?),
      }));
}

class _CopyWithStubImpl$Input$FloatFilter<TRes>
    implements CopyWith$Input$FloatFilter<TRes> {
  _CopyWithStubImpl$Input$FloatFilter(this._res);

  TRes _res;

  call({
    double? eq,
    double? gt,
    double? gte,
    List<double>? $in,
    Enum$FilterIs? $is,
    double? lt,
    double? lte,
    double? neq,
  }) =>
      _res;
}

class Input$FormFilter {
  factory Input$FormFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormFilter>? and,
    List<Input$FormFilter>? or,
    Input$FormFilter? not,
  }) =>
      Input$FormFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$FormFilter._(this._$data);

  factory Input$FormFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$FormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$FormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$FormFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$FormFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$FormFilter>? get and => (_$data['and'] as List<Input$FormFilter>?);

  List<Input$FormFilter>? get or => (_$data['or'] as List<Input$FormFilter>?);

  Input$FormFilter? get not => (_$data['not'] as Input$FormFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FormFilter<Input$FormFilter> get copyWith =>
      CopyWith$Input$FormFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormFilter<TRes> {
  factory CopyWith$Input$FormFilter(
    Input$FormFilter instance,
    TRes Function(Input$FormFilter) then,
  ) = _CopyWithImpl$Input$FormFilter;

  factory CopyWith$Input$FormFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FormFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormFilter>? and,
    List<Input$FormFilter>? or,
    Input$FormFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$FormFilter>? Function(
              Iterable<CopyWith$Input$FormFilter<Input$FormFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$FormFilter>? Function(
              Iterable<CopyWith$Input$FormFilter<Input$FormFilter>>?)
          _fn);
  CopyWith$Input$FormFilter<TRes> get not;
}

class _CopyWithImpl$Input$FormFilter<TRes>
    implements CopyWith$Input$FormFilter<TRes> {
  _CopyWithImpl$Input$FormFilter(
    this._instance,
    this._then,
  );

  final Input$FormFilter _instance;

  final TRes Function(Input$FormFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FormFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$FormFilter>?),
        if (or != _undefined) 'or': (or as List<Input$FormFilter>?),
        if (not != _undefined) 'not': (not as Input$FormFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$FormFilter>? Function(
                  Iterable<CopyWith$Input$FormFilter<Input$FormFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$FormFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$FormFilter>? Function(
                  Iterable<CopyWith$Input$FormFilter<Input$FormFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$FormFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$FormFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$FormFilter.stub(_then(_instance))
        : CopyWith$Input$FormFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FormFilter<TRes>
    implements CopyWith$Input$FormFilter<TRes> {
  _CopyWithStubImpl$Input$FormFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormFilter>? and,
    List<Input$FormFilter>? or,
    Input$FormFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FormFilter<TRes> get not =>
      CopyWith$Input$FormFilter.stub(_res);
}

class Input$FormInsertInput {
  factory Input$FormInsertInput({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  }) =>
      Input$FormInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormInsertInput._(this._$data);

  factory Input$FormInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$FormInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FormInsertInput<Input$FormInsertInput> get copyWith =>
      CopyWith$Input$FormInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormInsertInput<TRes> {
  factory CopyWith$Input$FormInsertInput(
    Input$FormInsertInput instance,
    TRes Function(Input$FormInsertInput) then,
  ) = _CopyWithImpl$Input$FormInsertInput;

  factory CopyWith$Input$FormInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FormInsertInput;

  TRes call({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$FormInsertInput<TRes>
    implements CopyWith$Input$FormInsertInput<TRes> {
  _CopyWithImpl$Input$FormInsertInput(
    this._instance,
    this._then,
  );

  final Input$FormInsertInput _instance;

  final TRes Function(Input$FormInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FormInsertInput<TRes>
    implements CopyWith$Input$FormInsertInput<TRes> {
  _CopyWithStubImpl$Input$FormInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$FormOrderBy {
  factory Input$FormOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$FormOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormOrderBy._(this._$data);

  factory Input$FormOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$FormOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$FormOrderBy<Input$FormOrderBy> get copyWith =>
      CopyWith$Input$FormOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormOrderBy<TRes> {
  factory CopyWith$Input$FormOrderBy(
    Input$FormOrderBy instance,
    TRes Function(Input$FormOrderBy) then,
  ) = _CopyWithImpl$Input$FormOrderBy;

  factory CopyWith$Input$FormOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$FormOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$FormOrderBy<TRes>
    implements CopyWith$Input$FormOrderBy<TRes> {
  _CopyWithImpl$Input$FormOrderBy(
    this._instance,
    this._then,
  );

  final Input$FormOrderBy _instance;

  final TRes Function(Input$FormOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$FormOrderBy<TRes>
    implements CopyWith$Input$FormOrderBy<TRes> {
  _CopyWithStubImpl$Input$FormOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$FormQuestionFilter {
  factory Input$FormQuestionFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormQuestionFilter>? and,
    List<Input$FormQuestionFilter>? or,
    Input$FormQuestionFilter? not,
  }) =>
      Input$FormQuestionFilter._({
        if (id != null) r'id': id,
        if (formId != null) r'formId': formId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$FormQuestionFilter._(this._$data);

  factory Input$FormQuestionFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : Input$UUIDFilter.fromJson((l$formId as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$FormQuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$FormQuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$FormQuestionFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$FormQuestionFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get formId => (_$data['formId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$FormQuestionFilter>? get and =>
      (_$data['and'] as List<Input$FormQuestionFilter>?);

  List<Input$FormQuestionFilter>? get or =>
      (_$data['or'] as List<Input$FormQuestionFilter>?);

  Input$FormQuestionFilter? get not =>
      (_$data['not'] as Input$FormQuestionFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FormQuestionFilter<Input$FormQuestionFilter> get copyWith =>
      CopyWith$Input$FormQuestionFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormQuestionFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$formId = formId;
    final l$questionId = questionId;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormQuestionFilter<TRes> {
  factory CopyWith$Input$FormQuestionFilter(
    Input$FormQuestionFilter instance,
    TRes Function(Input$FormQuestionFilter) then,
  ) = _CopyWithImpl$Input$FormQuestionFilter;

  factory CopyWith$Input$FormQuestionFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FormQuestionFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormQuestionFilter>? and,
    List<Input$FormQuestionFilter>? or,
    Input$FormQuestionFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get formId;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$FormQuestionFilter>? Function(
              Iterable<
                  CopyWith$Input$FormQuestionFilter<Input$FormQuestionFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$FormQuestionFilter>? Function(
              Iterable<
                  CopyWith$Input$FormQuestionFilter<Input$FormQuestionFilter>>?)
          _fn);
  CopyWith$Input$FormQuestionFilter<TRes> get not;
}

class _CopyWithImpl$Input$FormQuestionFilter<TRes>
    implements CopyWith$Input$FormQuestionFilter<TRes> {
  _CopyWithImpl$Input$FormQuestionFilter(
    this._instance,
    this._then,
  );

  final Input$FormQuestionFilter _instance;

  final TRes Function(Input$FormQuestionFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? formId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FormQuestionFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (formId != _undefined) 'formId': (formId as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$FormQuestionFilter>?),
        if (or != _undefined) 'or': (or as List<Input$FormQuestionFilter>?),
        if (not != _undefined) 'not': (not as Input$FormQuestionFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get formId {
    final local$formId = _instance.formId;
    return local$formId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$formId, (e) => call(formId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$FormQuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$FormQuestionFilter<
                          Input$FormQuestionFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$FormQuestionFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$FormQuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$FormQuestionFilter<
                          Input$FormQuestionFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$FormQuestionFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$FormQuestionFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$FormQuestionFilter.stub(_then(_instance))
        : CopyWith$Input$FormQuestionFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FormQuestionFilter<TRes>
    implements CopyWith$Input$FormQuestionFilter<TRes> {
  _CopyWithStubImpl$Input$FormQuestionFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$FormQuestionFilter>? and,
    List<Input$FormQuestionFilter>? or,
    Input$FormQuestionFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get formId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FormQuestionFilter<TRes> get not =>
      CopyWith$Input$FormQuestionFilter.stub(_res);
}

class Input$FormQuestionInsertInput {
  factory Input$FormQuestionInsertInput({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$FormQuestionInsertInput._({
        if (id != null) r'id': id,
        if (formId != null) r'formId': formId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormQuestionInsertInput._(this._$data);

  factory Input$FormQuestionInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$FormQuestionInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get formId => (_$data['formId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FormQuestionInsertInput<Input$FormQuestionInsertInput>
      get copyWith => CopyWith$Input$FormQuestionInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormQuestionInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$formId = formId;
    final l$questionId = questionId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormQuestionInsertInput<TRes> {
  factory CopyWith$Input$FormQuestionInsertInput(
    Input$FormQuestionInsertInput instance,
    TRes Function(Input$FormQuestionInsertInput) then,
  ) = _CopyWithImpl$Input$FormQuestionInsertInput;

  factory CopyWith$Input$FormQuestionInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FormQuestionInsertInput;

  TRes call({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$FormQuestionInsertInput<TRes>
    implements CopyWith$Input$FormQuestionInsertInput<TRes> {
  _CopyWithImpl$Input$FormQuestionInsertInput(
    this._instance,
    this._then,
  );

  final Input$FormQuestionInsertInput _instance;

  final TRes Function(Input$FormQuestionInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? formId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormQuestionInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FormQuestionInsertInput<TRes>
    implements CopyWith$Input$FormQuestionInsertInput<TRes> {
  _CopyWithStubImpl$Input$FormQuestionInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$FormQuestionOrderBy {
  factory Input$FormQuestionOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$FormQuestionOrderBy._({
        if (id != null) r'id': id,
        if (formId != null) r'formId': formId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormQuestionOrderBy._(this._$data);

  factory Input$FormQuestionOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$formId as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$FormQuestionOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get formId =>
      (_$data['formId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] =
          l$formId == null ? null : toJson$Enum$OrderByDirection(l$formId);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$FormQuestionOrderBy<Input$FormQuestionOrderBy> get copyWith =>
      CopyWith$Input$FormQuestionOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormQuestionOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$formId = formId;
    final l$questionId = questionId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormQuestionOrderBy<TRes> {
  factory CopyWith$Input$FormQuestionOrderBy(
    Input$FormQuestionOrderBy instance,
    TRes Function(Input$FormQuestionOrderBy) then,
  ) = _CopyWithImpl$Input$FormQuestionOrderBy;

  factory CopyWith$Input$FormQuestionOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$FormQuestionOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$FormQuestionOrderBy<TRes>
    implements CopyWith$Input$FormQuestionOrderBy<TRes> {
  _CopyWithImpl$Input$FormQuestionOrderBy(
    this._instance,
    this._then,
  );

  final Input$FormQuestionOrderBy _instance;

  final TRes Function(Input$FormQuestionOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? formId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormQuestionOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (formId != _undefined) 'formId': (formId as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$FormQuestionOrderBy<TRes>
    implements CopyWith$Input$FormQuestionOrderBy<TRes> {
  _CopyWithStubImpl$Input$FormQuestionOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$FormQuestionUpdateInput {
  factory Input$FormQuestionUpdateInput({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  }) =>
      Input$FormQuestionUpdateInput._({
        if (id != null) r'id': id,
        if (formId != null) r'formId': formId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormQuestionUpdateInput._(this._$data);

  factory Input$FormQuestionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$FormQuestionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get formId => (_$data['formId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FormQuestionUpdateInput<Input$FormQuestionUpdateInput>
      get copyWith => CopyWith$Input$FormQuestionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormQuestionUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$formId = formId;
    final l$questionId = questionId;
    final l$index = index;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormQuestionUpdateInput<TRes> {
  factory CopyWith$Input$FormQuestionUpdateInput(
    Input$FormQuestionUpdateInput instance,
    TRes Function(Input$FormQuestionUpdateInput) then,
  ) = _CopyWithImpl$Input$FormQuestionUpdateInput;

  factory CopyWith$Input$FormQuestionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FormQuestionUpdateInput;

  TRes call({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$FormQuestionUpdateInput<TRes>
    implements CopyWith$Input$FormQuestionUpdateInput<TRes> {
  _CopyWithImpl$Input$FormQuestionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$FormQuestionUpdateInput _instance;

  final TRes Function(Input$FormQuestionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? formId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormQuestionUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FormQuestionUpdateInput<TRes>
    implements CopyWith$Input$FormQuestionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$FormQuestionUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? formId,
    String? questionId,
    int? index,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$FormUpdateInput {
  factory Input$FormUpdateInput({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  }) =>
      Input$FormUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$FormUpdateInput._(this._$data);

  factory Input$FormUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$FormUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$FormUpdateInput<Input$FormUpdateInput> get copyWith =>
      CopyWith$Input$FormUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FormUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$FormUpdateInput<TRes> {
  factory CopyWith$Input$FormUpdateInput(
    Input$FormUpdateInput instance,
    TRes Function(Input$FormUpdateInput) then,
  ) = _CopyWithImpl$Input$FormUpdateInput;

  factory CopyWith$Input$FormUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FormUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$FormUpdateInput<TRes>
    implements CopyWith$Input$FormUpdateInput<TRes> {
  _CopyWithImpl$Input$FormUpdateInput(
    this._instance,
    this._then,
  );

  final Input$FormUpdateInput _instance;

  final TRes Function(Input$FormUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$FormUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$FormUpdateInput<TRes>
    implements CopyWith$Input$FormUpdateInput<TRes> {
  _CopyWithStubImpl$Input$FormUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? description,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$HeroItemFilter {
  factory Input$HeroItemFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? coverImage,
    Input$StringFilter? targetUrl,
    Input$IDFilter? nodeId,
    List<Input$HeroItemFilter>? and,
    List<Input$HeroItemFilter>? or,
    Input$HeroItemFilter? not,
  }) =>
      Input$HeroItemFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (coverImage != null) r'coverImage': coverImage,
        if (targetUrl != null) r'targetUrl': targetUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$HeroItemFilter._(this._$data);

  factory Input$HeroItemFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = l$subtitle == null
          ? null
          : Input$StringFilter.fromJson((l$subtitle as Map<String, dynamic>));
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : Input$StringFilter.fromJson((l$coverImage as Map<String, dynamic>));
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = l$targetUrl == null
          ? null
          : Input$StringFilter.fromJson((l$targetUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$HeroItemFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$HeroItemFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$HeroItemFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$HeroItemFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get subtitle =>
      (_$data['subtitle'] as Input$StringFilter?);

  Input$StringFilter? get coverImage =>
      (_$data['coverImage'] as Input$StringFilter?);

  Input$StringFilter? get targetUrl =>
      (_$data['targetUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$HeroItemFilter>? get and =>
      (_$data['and'] as List<Input$HeroItemFilter>?);

  List<Input$HeroItemFilter>? get or =>
      (_$data['or'] as List<Input$HeroItemFilter>?);

  Input$HeroItemFilter? get not => (_$data['not'] as Input$HeroItemFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle?.toJson();
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage?.toJson();
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$HeroItemFilter<Input$HeroItemFilter> get copyWith =>
      CopyWith$Input$HeroItemFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HeroItemFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$coverImage = coverImage;
    final l$targetUrl = targetUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$HeroItemFilter<TRes> {
  factory CopyWith$Input$HeroItemFilter(
    Input$HeroItemFilter instance,
    TRes Function(Input$HeroItemFilter) then,
  ) = _CopyWithImpl$Input$HeroItemFilter;

  factory CopyWith$Input$HeroItemFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$HeroItemFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? coverImage,
    Input$StringFilter? targetUrl,
    Input$IDFilter? nodeId,
    List<Input$HeroItemFilter>? and,
    List<Input$HeroItemFilter>? or,
    Input$HeroItemFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get subtitle;
  CopyWith$Input$StringFilter<TRes> get coverImage;
  CopyWith$Input$StringFilter<TRes> get targetUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$HeroItemFilter>? Function(
              Iterable<CopyWith$Input$HeroItemFilter<Input$HeroItemFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$HeroItemFilter>? Function(
              Iterable<CopyWith$Input$HeroItemFilter<Input$HeroItemFilter>>?)
          _fn);
  CopyWith$Input$HeroItemFilter<TRes> get not;
}

class _CopyWithImpl$Input$HeroItemFilter<TRes>
    implements CopyWith$Input$HeroItemFilter<TRes> {
  _CopyWithImpl$Input$HeroItemFilter(
    this._instance,
    this._then,
  );

  final Input$HeroItemFilter _instance;

  final TRes Function(Input$HeroItemFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? coverImage = _undefined,
    Object? targetUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$HeroItemFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (subtitle != _undefined)
          'subtitle': (subtitle as Input$StringFilter?),
        if (coverImage != _undefined)
          'coverImage': (coverImage as Input$StringFilter?),
        if (targetUrl != _undefined)
          'targetUrl': (targetUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$HeroItemFilter>?),
        if (or != _undefined) 'or': (or as List<Input$HeroItemFilter>?),
        if (not != _undefined) 'not': (not as Input$HeroItemFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get subtitle {
    final local$subtitle = _instance.subtitle;
    return local$subtitle == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$subtitle, (e) => call(subtitle: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverImage {
    final local$coverImage = _instance.coverImage;
    return local$coverImage == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$coverImage, (e) => call(coverImage: e));
  }

  CopyWith$Input$StringFilter<TRes> get targetUrl {
    final local$targetUrl = _instance.targetUrl;
    return local$targetUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$targetUrl, (e) => call(targetUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$HeroItemFilter>? Function(
                  Iterable<
                      CopyWith$Input$HeroItemFilter<Input$HeroItemFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$HeroItemFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$HeroItemFilter>? Function(
                  Iterable<
                      CopyWith$Input$HeroItemFilter<Input$HeroItemFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$HeroItemFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$HeroItemFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$HeroItemFilter.stub(_then(_instance))
        : CopyWith$Input$HeroItemFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$HeroItemFilter<TRes>
    implements CopyWith$Input$HeroItemFilter<TRes> {
  _CopyWithStubImpl$Input$HeroItemFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? coverImage,
    Input$StringFilter? targetUrl,
    Input$IDFilter? nodeId,
    List<Input$HeroItemFilter>? and,
    List<Input$HeroItemFilter>? or,
    Input$HeroItemFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get subtitle =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverImage =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get targetUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$HeroItemFilter<TRes> get not =>
      CopyWith$Input$HeroItemFilter.stub(_res);
}

class Input$HeroItemInsertInput {
  factory Input$HeroItemInsertInput({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  }) =>
      Input$HeroItemInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (coverImage != null) r'coverImage': coverImage,
        if (targetUrl != null) r'targetUrl': targetUrl,
      });

  Input$HeroItemInsertInput._(this._$data);

  factory Input$HeroItemInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = (l$subtitle as String?);
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = (l$coverImage as String?);
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    return Input$HeroItemInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get title => (_$data['title'] as String?);

  String? get subtitle => (_$data['subtitle'] as String?);

  String? get coverImage => (_$data['coverImage'] as String?);

  String? get targetUrl => (_$data['targetUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle;
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage;
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    return result$data;
  }

  CopyWith$Input$HeroItemInsertInput<Input$HeroItemInsertInput> get copyWith =>
      CopyWith$Input$HeroItemInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HeroItemInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$coverImage = coverImage;
    final l$targetUrl = targetUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$HeroItemInsertInput<TRes> {
  factory CopyWith$Input$HeroItemInsertInput(
    Input$HeroItemInsertInput instance,
    TRes Function(Input$HeroItemInsertInput) then,
  ) = _CopyWithImpl$Input$HeroItemInsertInput;

  factory CopyWith$Input$HeroItemInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HeroItemInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  });
}

class _CopyWithImpl$Input$HeroItemInsertInput<TRes>
    implements CopyWith$Input$HeroItemInsertInput<TRes> {
  _CopyWithImpl$Input$HeroItemInsertInput(
    this._instance,
    this._then,
  );

  final Input$HeroItemInsertInput _instance;

  final TRes Function(Input$HeroItemInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? coverImage = _undefined,
    Object? targetUrl = _undefined,
  }) =>
      _then(Input$HeroItemInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (title != _undefined) 'title': (title as String?),
        if (subtitle != _undefined) 'subtitle': (subtitle as String?),
        if (coverImage != _undefined) 'coverImage': (coverImage as String?),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$HeroItemInsertInput<TRes>
    implements CopyWith$Input$HeroItemInsertInput<TRes> {
  _CopyWithStubImpl$Input$HeroItemInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  }) =>
      _res;
}

class Input$HeroItemOrderBy {
  factory Input$HeroItemOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? coverImage,
    Enum$OrderByDirection? targetUrl,
  }) =>
      Input$HeroItemOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (coverImage != null) r'coverImage': coverImage,
        if (targetUrl != null) r'targetUrl': targetUrl,
      });

  Input$HeroItemOrderBy._(this._$data);

  factory Input$HeroItemOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = l$subtitle == null
          ? null
          : fromJson$Enum$OrderByDirection((l$subtitle as String));
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverImage as String));
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = l$targetUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$targetUrl as String));
    }
    return Input$HeroItemOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get subtitle =>
      (_$data['subtitle'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverImage =>
      (_$data['coverImage'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get targetUrl =>
      (_$data['targetUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] =
          l$subtitle == null ? null : toJson$Enum$OrderByDirection(l$subtitle);
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage == null
          ? null
          : toJson$Enum$OrderByDirection(l$coverImage);
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$targetUrl);
    }
    return result$data;
  }

  CopyWith$Input$HeroItemOrderBy<Input$HeroItemOrderBy> get copyWith =>
      CopyWith$Input$HeroItemOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HeroItemOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$coverImage = coverImage;
    final l$targetUrl = targetUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$HeroItemOrderBy<TRes> {
  factory CopyWith$Input$HeroItemOrderBy(
    Input$HeroItemOrderBy instance,
    TRes Function(Input$HeroItemOrderBy) then,
  ) = _CopyWithImpl$Input$HeroItemOrderBy;

  factory CopyWith$Input$HeroItemOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$HeroItemOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? coverImage,
    Enum$OrderByDirection? targetUrl,
  });
}

class _CopyWithImpl$Input$HeroItemOrderBy<TRes>
    implements CopyWith$Input$HeroItemOrderBy<TRes> {
  _CopyWithImpl$Input$HeroItemOrderBy(
    this._instance,
    this._then,
  );

  final Input$HeroItemOrderBy _instance;

  final TRes Function(Input$HeroItemOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? coverImage = _undefined,
    Object? targetUrl = _undefined,
  }) =>
      _then(Input$HeroItemOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (subtitle != _undefined)
          'subtitle': (subtitle as Enum$OrderByDirection?),
        if (coverImage != _undefined)
          'coverImage': (coverImage as Enum$OrderByDirection?),
        if (targetUrl != _undefined)
          'targetUrl': (targetUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$HeroItemOrderBy<TRes>
    implements CopyWith$Input$HeroItemOrderBy<TRes> {
  _CopyWithStubImpl$Input$HeroItemOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? coverImage,
    Enum$OrderByDirection? targetUrl,
  }) =>
      _res;
}

class Input$HeroItemUpdateInput {
  factory Input$HeroItemUpdateInput({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  }) =>
      Input$HeroItemUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (coverImage != null) r'coverImage': coverImage,
        if (targetUrl != null) r'targetUrl': targetUrl,
      });

  Input$HeroItemUpdateInput._(this._$data);

  factory Input$HeroItemUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = (l$subtitle as String?);
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = (l$coverImage as String?);
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    return Input$HeroItemUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get title => (_$data['title'] as String?);

  String? get subtitle => (_$data['subtitle'] as String?);

  String? get coverImage => (_$data['coverImage'] as String?);

  String? get targetUrl => (_$data['targetUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle;
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage;
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    return result$data;
  }

  CopyWith$Input$HeroItemUpdateInput<Input$HeroItemUpdateInput> get copyWith =>
      CopyWith$Input$HeroItemUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HeroItemUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$coverImage = coverImage;
    final l$targetUrl = targetUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$HeroItemUpdateInput<TRes> {
  factory CopyWith$Input$HeroItemUpdateInput(
    Input$HeroItemUpdateInput instance,
    TRes Function(Input$HeroItemUpdateInput) then,
  ) = _CopyWithImpl$Input$HeroItemUpdateInput;

  factory CopyWith$Input$HeroItemUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HeroItemUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  });
}

class _CopyWithImpl$Input$HeroItemUpdateInput<TRes>
    implements CopyWith$Input$HeroItemUpdateInput<TRes> {
  _CopyWithImpl$Input$HeroItemUpdateInput(
    this._instance,
    this._then,
  );

  final Input$HeroItemUpdateInput _instance;

  final TRes Function(Input$HeroItemUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? coverImage = _undefined,
    Object? targetUrl = _undefined,
  }) =>
      _then(Input$HeroItemUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (title != _undefined) 'title': (title as String?),
        if (subtitle != _undefined) 'subtitle': (subtitle as String?),
        if (coverImage != _undefined) 'coverImage': (coverImage as String?),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$HeroItemUpdateInput<TRes>
    implements CopyWith$Input$HeroItemUpdateInput<TRes> {
  _CopyWithStubImpl$Input$HeroItemUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? title,
    String? subtitle,
    String? coverImage,
    String? targetUrl,
  }) =>
      _res;
}

class Input$IDFilter {
  factory Input$IDFilter({String? eq}) => Input$IDFilter._({
        if (eq != null) r'eq': eq,
      });

  Input$IDFilter._(this._$data);

  factory Input$IDFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    return Input$IDFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    return result$data;
  }

  CopyWith$Input$IDFilter<Input$IDFilter> get copyWith =>
      CopyWith$Input$IDFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IDFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    return Object.hashAll([_$data.containsKey('eq') ? l$eq : const {}]);
  }
}

abstract class CopyWith$Input$IDFilter<TRes> {
  factory CopyWith$Input$IDFilter(
    Input$IDFilter instance,
    TRes Function(Input$IDFilter) then,
  ) = _CopyWithImpl$Input$IDFilter;

  factory CopyWith$Input$IDFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IDFilter;

  TRes call({String? eq});
}

class _CopyWithImpl$Input$IDFilter<TRes>
    implements CopyWith$Input$IDFilter<TRes> {
  _CopyWithImpl$Input$IDFilter(
    this._instance,
    this._then,
  );

  final Input$IDFilter _instance;

  final TRes Function(Input$IDFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? eq = _undefined}) => _then(Input$IDFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
      }));
}

class _CopyWithStubImpl$Input$IDFilter<TRes>
    implements CopyWith$Input$IDFilter<TRes> {
  _CopyWithStubImpl$Input$IDFilter(this._res);

  TRes _res;

  call({String? eq}) => _res;
}

class Input$IntFilter {
  factory Input$IntFilter({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  }) =>
      Input$IntFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$IntFilter._(this._$data);

  factory Input$IntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    return Input$IntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  int? get neq => (_$data['neq'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$IntFilter<Input$IntFilter> get copyWith =>
      CopyWith$Input$IntFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFilter<TRes> {
  factory CopyWith$Input$IntFilter(
    Input$IntFilter instance,
    TRes Function(Input$IntFilter) then,
  ) = _CopyWithImpl$Input$IntFilter;

  factory CopyWith$Input$IntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFilter;

  TRes call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  });
}

class _CopyWithImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithImpl$Input$IntFilter(
    this._instance,
    this._then,
  );

  final Input$IntFilter _instance;

  final TRes Function(Input$IntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$IntFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (neq != _undefined) 'neq': (neq as int?),
      }));
}

class _CopyWithStubImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithStubImpl$Input$IntFilter(this._res);

  TRes _res;

  call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    Enum$FilterIs? $is,
    int? lt,
    int? lte,
    int? neq,
  }) =>
      _res;
}

class Input$MimeTypeFilter {
  factory Input$MimeTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? mime,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$MimeTypeFilter>? and,
    List<Input$MimeTypeFilter>? or,
    Input$MimeTypeFilter? not,
  }) =>
      Input$MimeTypeFilter._({
        if (id != null) r'id': id,
        if (mime != null) r'mime': mime,
        if (name != null) r'name': name,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$MimeTypeFilter._(this._$data);

  factory Input$MimeTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('mime')) {
      final l$mime = data['mime'];
      result$data['mime'] = l$mime == null
          ? null
          : Input$StringFilter.fromJson((l$mime as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$MimeTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$MimeTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$MimeTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$MimeTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get mime => (_$data['mime'] as Input$StringFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$MimeTypeFilter>? get and =>
      (_$data['and'] as List<Input$MimeTypeFilter>?);

  List<Input$MimeTypeFilter>? get or =>
      (_$data['or'] as List<Input$MimeTypeFilter>?);

  Input$MimeTypeFilter? get not => (_$data['not'] as Input$MimeTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('mime')) {
      final l$mime = mime;
      result$data['mime'] = l$mime?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MimeTypeFilter<Input$MimeTypeFilter> get copyWith =>
      CopyWith$Input$MimeTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MimeTypeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mime = mime;
    final lOther$mime = other.mime;
    if (_$data.containsKey('mime') != other._$data.containsKey('mime')) {
      return false;
    }
    if (l$mime != lOther$mime) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$mime = mime;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mime') ? l$mime : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$MimeTypeFilter<TRes> {
  factory CopyWith$Input$MimeTypeFilter(
    Input$MimeTypeFilter instance,
    TRes Function(Input$MimeTypeFilter) then,
  ) = _CopyWithImpl$Input$MimeTypeFilter;

  factory CopyWith$Input$MimeTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$MimeTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? mime,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$MimeTypeFilter>? and,
    List<Input$MimeTypeFilter>? or,
    Input$MimeTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get mime;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$MimeTypeFilter>? Function(
              Iterable<CopyWith$Input$MimeTypeFilter<Input$MimeTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$MimeTypeFilter>? Function(
              Iterable<CopyWith$Input$MimeTypeFilter<Input$MimeTypeFilter>>?)
          _fn);
  CopyWith$Input$MimeTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$MimeTypeFilter<TRes>
    implements CopyWith$Input$MimeTypeFilter<TRes> {
  _CopyWithImpl$Input$MimeTypeFilter(
    this._instance,
    this._then,
  );

  final Input$MimeTypeFilter _instance;

  final TRes Function(Input$MimeTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? mime = _undefined,
    Object? name = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$MimeTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (mime != _undefined) 'mime': (mime as Input$StringFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$MimeTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$MimeTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$MimeTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get mime {
    final local$mime = _instance.mime;
    return local$mime == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$mime, (e) => call(mime: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$MimeTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$MimeTypeFilter<Input$MimeTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$MimeTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$MimeTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$MimeTypeFilter<Input$MimeTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$MimeTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$MimeTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$MimeTypeFilter.stub(_then(_instance))
        : CopyWith$Input$MimeTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$MimeTypeFilter<TRes>
    implements CopyWith$Input$MimeTypeFilter<TRes> {
  _CopyWithStubImpl$Input$MimeTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? mime,
    Input$StringFilter? name,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$MimeTypeFilter>? and,
    List<Input$MimeTypeFilter>? or,
    Input$MimeTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get mime =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$MimeTypeFilter<TRes> get not =>
      CopyWith$Input$MimeTypeFilter.stub(_res);
}

class Input$MimeTypeInsertInput {
  factory Input$MimeTypeInsertInput({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  }) =>
      Input$MimeTypeInsertInput._({
        if (id != null) r'id': id,
        if (mime != null) r'mime': mime,
        if (name != null) r'name': name,
        if (extensions != null) r'extensions': extensions,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$MimeTypeInsertInput._(this._$data);

  factory Input$MimeTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('mime')) {
      final l$mime = data['mime'];
      result$data['mime'] = (l$mime as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('extensions')) {
      final l$extensions = data['extensions'];
      result$data['extensions'] =
          (l$extensions as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$MimeTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get mime => (_$data['mime'] as String?);

  String? get name => (_$data['name'] as String?);

  List<String?>? get extensions => (_$data['extensions'] as List<String?>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('mime')) {
      final l$mime = mime;
      result$data['mime'] = l$mime;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('extensions')) {
      final l$extensions = extensions;
      result$data['extensions'] = l$extensions?.map((e) => e).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$MimeTypeInsertInput<Input$MimeTypeInsertInput> get copyWith =>
      CopyWith$Input$MimeTypeInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MimeTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mime = mime;
    final lOther$mime = other.mime;
    if (_$data.containsKey('mime') != other._$data.containsKey('mime')) {
      return false;
    }
    if (l$mime != lOther$mime) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$extensions = extensions;
    final lOther$extensions = other.extensions;
    if (_$data.containsKey('extensions') !=
        other._$data.containsKey('extensions')) {
      return false;
    }
    if (l$extensions != null && lOther$extensions != null) {
      if (l$extensions.length != lOther$extensions.length) {
        return false;
      }
      for (int i = 0; i < l$extensions.length; i++) {
        final l$extensions$entry = l$extensions[i];
        final lOther$extensions$entry = lOther$extensions[i];
        if (l$extensions$entry != lOther$extensions$entry) {
          return false;
        }
      }
    } else if (l$extensions != lOther$extensions) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$mime = mime;
    final l$name = name;
    final l$extensions = extensions;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mime') ? l$mime : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('extensions')
          ? l$extensions == null
              ? null
              : Object.hashAll(l$extensions.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MimeTypeInsertInput<TRes> {
  factory CopyWith$Input$MimeTypeInsertInput(
    Input$MimeTypeInsertInput instance,
    TRes Function(Input$MimeTypeInsertInput) then,
  ) = _CopyWithImpl$Input$MimeTypeInsertInput;

  factory CopyWith$Input$MimeTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MimeTypeInsertInput;

  TRes call({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$MimeTypeInsertInput<TRes>
    implements CopyWith$Input$MimeTypeInsertInput<TRes> {
  _CopyWithImpl$Input$MimeTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$MimeTypeInsertInput _instance;

  final TRes Function(Input$MimeTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? mime = _undefined,
    Object? name = _undefined,
    Object? extensions = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$MimeTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (mime != _undefined) 'mime': (mime as String?),
        if (name != _undefined) 'name': (name as String?),
        if (extensions != _undefined)
          'extensions': (extensions as List<String?>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$MimeTypeInsertInput<TRes>
    implements CopyWith$Input$MimeTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$MimeTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$MimeTypeOrderBy {
  factory Input$MimeTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? mime,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$MimeTypeOrderBy._({
        if (id != null) r'id': id,
        if (mime != null) r'mime': mime,
        if (name != null) r'name': name,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$MimeTypeOrderBy._(this._$data);

  factory Input$MimeTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('mime')) {
      final l$mime = data['mime'];
      result$data['mime'] = l$mime == null
          ? null
          : fromJson$Enum$OrderByDirection((l$mime as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$MimeTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get mime => (_$data['mime'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('mime')) {
      final l$mime = mime;
      result$data['mime'] =
          l$mime == null ? null : toJson$Enum$OrderByDirection(l$mime);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$MimeTypeOrderBy<Input$MimeTypeOrderBy> get copyWith =>
      CopyWith$Input$MimeTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MimeTypeOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mime = mime;
    final lOther$mime = other.mime;
    if (_$data.containsKey('mime') != other._$data.containsKey('mime')) {
      return false;
    }
    if (l$mime != lOther$mime) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$mime = mime;
    final l$name = name;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mime') ? l$mime : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MimeTypeOrderBy<TRes> {
  factory CopyWith$Input$MimeTypeOrderBy(
    Input$MimeTypeOrderBy instance,
    TRes Function(Input$MimeTypeOrderBy) then,
  ) = _CopyWithImpl$Input$MimeTypeOrderBy;

  factory CopyWith$Input$MimeTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MimeTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? mime,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$MimeTypeOrderBy<TRes>
    implements CopyWith$Input$MimeTypeOrderBy<TRes> {
  _CopyWithImpl$Input$MimeTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$MimeTypeOrderBy _instance;

  final TRes Function(Input$MimeTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? mime = _undefined,
    Object? name = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$MimeTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (mime != _undefined) 'mime': (mime as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$MimeTypeOrderBy<TRes>
    implements CopyWith$Input$MimeTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$MimeTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? mime,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$MimeTypeUpdateInput {
  factory Input$MimeTypeUpdateInput({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  }) =>
      Input$MimeTypeUpdateInput._({
        if (id != null) r'id': id,
        if (mime != null) r'mime': mime,
        if (name != null) r'name': name,
        if (extensions != null) r'extensions': extensions,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$MimeTypeUpdateInput._(this._$data);

  factory Input$MimeTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('mime')) {
      final l$mime = data['mime'];
      result$data['mime'] = (l$mime as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('extensions')) {
      final l$extensions = data['extensions'];
      result$data['extensions'] =
          (l$extensions as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$MimeTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get mime => (_$data['mime'] as String?);

  String? get name => (_$data['name'] as String?);

  List<String?>? get extensions => (_$data['extensions'] as List<String?>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('mime')) {
      final l$mime = mime;
      result$data['mime'] = l$mime;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('extensions')) {
      final l$extensions = extensions;
      result$data['extensions'] = l$extensions?.map((e) => e).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$MimeTypeUpdateInput<Input$MimeTypeUpdateInput> get copyWith =>
      CopyWith$Input$MimeTypeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MimeTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mime = mime;
    final lOther$mime = other.mime;
    if (_$data.containsKey('mime') != other._$data.containsKey('mime')) {
      return false;
    }
    if (l$mime != lOther$mime) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$extensions = extensions;
    final lOther$extensions = other.extensions;
    if (_$data.containsKey('extensions') !=
        other._$data.containsKey('extensions')) {
      return false;
    }
    if (l$extensions != null && lOther$extensions != null) {
      if (l$extensions.length != lOther$extensions.length) {
        return false;
      }
      for (int i = 0; i < l$extensions.length; i++) {
        final l$extensions$entry = l$extensions[i];
        final lOther$extensions$entry = lOther$extensions[i];
        if (l$extensions$entry != lOther$extensions$entry) {
          return false;
        }
      }
    } else if (l$extensions != lOther$extensions) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$mime = mime;
    final l$name = name;
    final l$extensions = extensions;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mime') ? l$mime : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('extensions')
          ? l$extensions == null
              ? null
              : Object.hashAll(l$extensions.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MimeTypeUpdateInput<TRes> {
  factory CopyWith$Input$MimeTypeUpdateInput(
    Input$MimeTypeUpdateInput instance,
    TRes Function(Input$MimeTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$MimeTypeUpdateInput;

  factory CopyWith$Input$MimeTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MimeTypeUpdateInput;

  TRes call({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$MimeTypeUpdateInput<TRes>
    implements CopyWith$Input$MimeTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$MimeTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$MimeTypeUpdateInput _instance;

  final TRes Function(Input$MimeTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? mime = _undefined,
    Object? name = _undefined,
    Object? extensions = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$MimeTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (mime != _undefined) 'mime': (mime as String?),
        if (name != _undefined) 'name': (name as String?),
        if (extensions != _undefined)
          'extensions': (extensions as List<String?>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$MimeTypeUpdateInput<TRes>
    implements CopyWith$Input$MimeTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$MimeTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? mime,
    String? name,
    List<String?>? extensions,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$NotificationFilter {
  factory Input$NotificationFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? notificationTypeId,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? messageMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$BooleanFilter? isRead,
    Input$StringFilter? iconUrl,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$NotificationFilter>? and,
    List<Input$NotificationFilter>? or,
    Input$NotificationFilter? not,
  }) =>
      Input$NotificationFilter._({
        if (id != null) r'id': id,
        if (notificationTypeId != null)
          r'notificationTypeId': notificationTypeId,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (messageMarkdown != null) r'messageMarkdown': messageMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (isRead != null) r'isRead': isRead,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (applicationId != null) r'applicationId': applicationId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$NotificationFilter._(this._$data);

  factory Input$NotificationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = data['notificationTypeId'];
      result$data['notificationTypeId'] = l$notificationTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$notificationTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = l$subtitle == null
          ? null
          : Input$StringFilter.fromJson((l$subtitle as Map<String, dynamic>));
    }
    if (data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = data['messageMarkdown'];
      result$data['messageMarkdown'] = l$messageMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$messageMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = l$isRead == null
          ? null
          : Input$BooleanFilter.fromJson((l$isRead as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$NotificationFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$NotificationFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NotificationFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NotificationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get notificationTypeId =>
      (_$data['notificationTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$StringFilter? get subtitle =>
      (_$data['subtitle'] as Input$StringFilter?);

  Input$StringFilter? get messageMarkdown =>
      (_$data['messageMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$BooleanFilter? get isRead => (_$data['isRead'] as Input$BooleanFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$NotificationFilter>? get and =>
      (_$data['and'] as List<Input$NotificationFilter>?);

  List<Input$NotificationFilter>? get or =>
      (_$data['or'] as List<Input$NotificationFilter>?);

  Input$NotificationFilter? get not =>
      (_$data['not'] as Input$NotificationFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = notificationTypeId;
      result$data['notificationTypeId'] = l$notificationTypeId?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle?.toJson();
    }
    if (_$data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = messageMarkdown;
      result$data['messageMarkdown'] = l$messageMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] = l$isRead?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NotificationFilter<Input$NotificationFilter> get copyWith =>
      CopyWith$Input$NotificationFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$notificationTypeId = notificationTypeId;
    final lOther$notificationTypeId = other.notificationTypeId;
    if (_$data.containsKey('notificationTypeId') !=
        other._$data.containsKey('notificationTypeId')) {
      return false;
    }
    if (l$notificationTypeId != lOther$notificationTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$messageMarkdown = messageMarkdown;
    final lOther$messageMarkdown = other.messageMarkdown;
    if (_$data.containsKey('messageMarkdown') !=
        other._$data.containsKey('messageMarkdown')) {
      return false;
    }
    if (l$messageMarkdown != lOther$messageMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$notificationTypeId = notificationTypeId;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$messageMarkdown = messageMarkdown;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$isRead = isRead;
    final l$iconUrl = iconUrl;
    final l$applicationId = applicationId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('notificationTypeId')
          ? l$notificationTypeId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('messageMarkdown') ? l$messageMarkdown : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationFilter<TRes> {
  factory CopyWith$Input$NotificationFilter(
    Input$NotificationFilter instance,
    TRes Function(Input$NotificationFilter) then,
  ) = _CopyWithImpl$Input$NotificationFilter;

  factory CopyWith$Input$NotificationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? notificationTypeId,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? messageMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$BooleanFilter? isRead,
    Input$StringFilter? iconUrl,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$NotificationFilter>? and,
    List<Input$NotificationFilter>? or,
    Input$NotificationFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get notificationTypeId;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$StringFilter<TRes> get subtitle;
  CopyWith$Input$StringFilter<TRes> get messageMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$BooleanFilter<TRes> get isRead;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$NotificationFilter>? Function(
              Iterable<
                  CopyWith$Input$NotificationFilter<Input$NotificationFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$NotificationFilter>? Function(
              Iterable<
                  CopyWith$Input$NotificationFilter<Input$NotificationFilter>>?)
          _fn);
  CopyWith$Input$NotificationFilter<TRes> get not;
}

class _CopyWithImpl$Input$NotificationFilter<TRes>
    implements CopyWith$Input$NotificationFilter<TRes> {
  _CopyWithImpl$Input$NotificationFilter(
    this._instance,
    this._then,
  );

  final Input$NotificationFilter _instance;

  final TRes Function(Input$NotificationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? notificationTypeId = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? messageMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? isRead = _undefined,
    Object? iconUrl = _undefined,
    Object? applicationId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NotificationFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (notificationTypeId != _undefined)
          'notificationTypeId': (notificationTypeId as Input$UUIDFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (subtitle != _undefined)
          'subtitle': (subtitle as Input$StringFilter?),
        if (messageMarkdown != _undefined)
          'messageMarkdown': (messageMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (isRead != _undefined) 'isRead': (isRead as Input$BooleanFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$NotificationFilter>?),
        if (or != _undefined) 'or': (or as List<Input$NotificationFilter>?),
        if (not != _undefined) 'not': (not as Input$NotificationFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get notificationTypeId {
    final local$notificationTypeId = _instance.notificationTypeId;
    return local$notificationTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$notificationTypeId, (e) => call(notificationTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$StringFilter<TRes> get subtitle {
    final local$subtitle = _instance.subtitle;
    return local$subtitle == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$subtitle, (e) => call(subtitle: e));
  }

  CopyWith$Input$StringFilter<TRes> get messageMarkdown {
    final local$messageMarkdown = _instance.messageMarkdown;
    return local$messageMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$messageMarkdown, (e) => call(messageMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isRead {
    final local$isRead = _instance.isRead;
    return local$isRead == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(local$isRead, (e) => call(isRead: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$NotificationFilter>? Function(
                  Iterable<
                      CopyWith$Input$NotificationFilter<
                          Input$NotificationFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$NotificationFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$NotificationFilter>? Function(
                  Iterable<
                      CopyWith$Input$NotificationFilter<
                          Input$NotificationFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$NotificationFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$NotificationFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NotificationFilter.stub(_then(_instance))
        : CopyWith$Input$NotificationFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NotificationFilter<TRes>
    implements CopyWith$Input$NotificationFilter<TRes> {
  _CopyWithStubImpl$Input$NotificationFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? notificationTypeId,
    Input$StringFilter? title,
    Input$StringFilter? subtitle,
    Input$StringFilter? messageMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$BooleanFilter? isRead,
    Input$StringFilter? iconUrl,
    Input$UUIDFilter? applicationId,
    Input$IDFilter? nodeId,
    List<Input$NotificationFilter>? and,
    List<Input$NotificationFilter>? or,
    Input$NotificationFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get notificationTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get subtitle =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get messageMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isRead =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$NotificationFilter<TRes> get not =>
      CopyWith$Input$NotificationFilter.stub(_res);
}

class Input$NotificationInsertInput {
  factory Input$NotificationInsertInput({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  }) =>
      Input$NotificationInsertInput._({
        if (id != null) r'id': id,
        if (notificationTypeId != null)
          r'notificationTypeId': notificationTypeId,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (messageMarkdown != null) r'messageMarkdown': messageMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (userId != null) r'userId': userId,
        if (isRead != null) r'isRead': isRead,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$NotificationInsertInput._(this._$data);

  factory Input$NotificationInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = data['notificationTypeId'];
      result$data['notificationTypeId'] = (l$notificationTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = (l$subtitle as String?);
    }
    if (data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = data['messageMarkdown'];
      result$data['messageMarkdown'] = (l$messageMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = (l$isRead as bool?);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$NotificationInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get notificationTypeId => (_$data['notificationTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get subtitle => (_$data['subtitle'] as String?);

  String? get messageMarkdown => (_$data['messageMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get userId => (_$data['userId'] as String?);

  bool? get isRead => (_$data['isRead'] as bool?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = notificationTypeId;
      result$data['notificationTypeId'] = l$notificationTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle;
    }
    if (_$data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = messageMarkdown;
      result$data['messageMarkdown'] = l$messageMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] = l$isRead;
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$NotificationInsertInput<Input$NotificationInsertInput>
      get copyWith => CopyWith$Input$NotificationInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$notificationTypeId = notificationTypeId;
    final lOther$notificationTypeId = other.notificationTypeId;
    if (_$data.containsKey('notificationTypeId') !=
        other._$data.containsKey('notificationTypeId')) {
      return false;
    }
    if (l$notificationTypeId != lOther$notificationTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$messageMarkdown = messageMarkdown;
    final lOther$messageMarkdown = other.messageMarkdown;
    if (_$data.containsKey('messageMarkdown') !=
        other._$data.containsKey('messageMarkdown')) {
      return false;
    }
    if (l$messageMarkdown != lOther$messageMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$notificationTypeId = notificationTypeId;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$messageMarkdown = messageMarkdown;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$userId = userId;
    final l$isRead = isRead;
    final l$iconUrl = iconUrl;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('notificationTypeId')
          ? l$notificationTypeId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('messageMarkdown') ? l$messageMarkdown : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationInsertInput<TRes> {
  factory CopyWith$Input$NotificationInsertInput(
    Input$NotificationInsertInput instance,
    TRes Function(Input$NotificationInsertInput) then,
  ) = _CopyWithImpl$Input$NotificationInsertInput;

  factory CopyWith$Input$NotificationInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationInsertInput;

  TRes call({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$NotificationInsertInput<TRes>
    implements CopyWith$Input$NotificationInsertInput<TRes> {
  _CopyWithImpl$Input$NotificationInsertInput(
    this._instance,
    this._then,
  );

  final Input$NotificationInsertInput _instance;

  final TRes Function(Input$NotificationInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? notificationTypeId = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? messageMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? userId = _undefined,
    Object? isRead = _undefined,
    Object? iconUrl = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$NotificationInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (notificationTypeId != _undefined)
          'notificationTypeId': (notificationTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (subtitle != _undefined) 'subtitle': (subtitle as String?),
        if (messageMarkdown != _undefined)
          'messageMarkdown': (messageMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (isRead != _undefined) 'isRead': (isRead as bool?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$NotificationInsertInput<TRes>
    implements CopyWith$Input$NotificationInsertInput<TRes> {
  _CopyWithStubImpl$Input$NotificationInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  }) =>
      _res;
}

class Input$NotificationOrderBy {
  factory Input$NotificationOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? notificationTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? messageMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? isRead,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? applicationId,
  }) =>
      Input$NotificationOrderBy._({
        if (id != null) r'id': id,
        if (notificationTypeId != null)
          r'notificationTypeId': notificationTypeId,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (messageMarkdown != null) r'messageMarkdown': messageMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (isRead != null) r'isRead': isRead,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$NotificationOrderBy._(this._$data);

  factory Input$NotificationOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = data['notificationTypeId'];
      result$data['notificationTypeId'] = l$notificationTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$notificationTypeId as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$OrderByDirection((l$title as String));
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = l$subtitle == null
          ? null
          : fromJson$Enum$OrderByDirection((l$subtitle as String));
    }
    if (data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = data['messageMarkdown'];
      result$data['messageMarkdown'] = l$messageMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection((l$messageMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = l$isRead == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isRead as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    return Input$NotificationOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get notificationTypeId =>
      (_$data['notificationTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get title =>
      (_$data['title'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get subtitle =>
      (_$data['subtitle'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get messageMarkdown =>
      (_$data['messageMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isRead =>
      (_$data['isRead'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = notificationTypeId;
      result$data['notificationTypeId'] = l$notificationTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$notificationTypeId);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$OrderByDirection(l$title);
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] =
          l$subtitle == null ? null : toJson$Enum$OrderByDirection(l$subtitle);
    }
    if (_$data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = messageMarkdown;
      result$data['messageMarkdown'] = l$messageMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$messageMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] =
          l$isRead == null ? null : toJson$Enum$OrderByDirection(l$isRead);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    return result$data;
  }

  CopyWith$Input$NotificationOrderBy<Input$NotificationOrderBy> get copyWith =>
      CopyWith$Input$NotificationOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$notificationTypeId = notificationTypeId;
    final lOther$notificationTypeId = other.notificationTypeId;
    if (_$data.containsKey('notificationTypeId') !=
        other._$data.containsKey('notificationTypeId')) {
      return false;
    }
    if (l$notificationTypeId != lOther$notificationTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$messageMarkdown = messageMarkdown;
    final lOther$messageMarkdown = other.messageMarkdown;
    if (_$data.containsKey('messageMarkdown') !=
        other._$data.containsKey('messageMarkdown')) {
      return false;
    }
    if (l$messageMarkdown != lOther$messageMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$notificationTypeId = notificationTypeId;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$messageMarkdown = messageMarkdown;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$isRead = isRead;
    final l$iconUrl = iconUrl;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('notificationTypeId')
          ? l$notificationTypeId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('messageMarkdown') ? l$messageMarkdown : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationOrderBy<TRes> {
  factory CopyWith$Input$NotificationOrderBy(
    Input$NotificationOrderBy instance,
    TRes Function(Input$NotificationOrderBy) then,
  ) = _CopyWithImpl$Input$NotificationOrderBy;

  factory CopyWith$Input$NotificationOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? notificationTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? messageMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? isRead,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? applicationId,
  });
}

class _CopyWithImpl$Input$NotificationOrderBy<TRes>
    implements CopyWith$Input$NotificationOrderBy<TRes> {
  _CopyWithImpl$Input$NotificationOrderBy(
    this._instance,
    this._then,
  );

  final Input$NotificationOrderBy _instance;

  final TRes Function(Input$NotificationOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? notificationTypeId = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? messageMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? isRead = _undefined,
    Object? iconUrl = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$NotificationOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (notificationTypeId != _undefined)
          'notificationTypeId': (notificationTypeId as Enum$OrderByDirection?),
        if (title != _undefined) 'title': (title as Enum$OrderByDirection?),
        if (subtitle != _undefined)
          'subtitle': (subtitle as Enum$OrderByDirection?),
        if (messageMarkdown != _undefined)
          'messageMarkdown': (messageMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (isRead != _undefined) 'isRead': (isRead as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$NotificationOrderBy<TRes>
    implements CopyWith$Input$NotificationOrderBy<TRes> {
  _CopyWithStubImpl$Input$NotificationOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? notificationTypeId,
    Enum$OrderByDirection? title,
    Enum$OrderByDirection? subtitle,
    Enum$OrderByDirection? messageMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? isRead,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? applicationId,
  }) =>
      _res;
}

class Input$NotificationTypeFilter {
  factory Input$NotificationTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$NotificationTypeFilter>? and,
    List<Input$NotificationTypeFilter>? or,
    Input$NotificationTypeFilter? not,
  }) =>
      Input$NotificationTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$NotificationTypeFilter._(this._$data);

  factory Input$NotificationTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$NotificationTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$NotificationTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NotificationTypeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NotificationTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$NotificationTypeFilter>? get and =>
      (_$data['and'] as List<Input$NotificationTypeFilter>?);

  List<Input$NotificationTypeFilter>? get or =>
      (_$data['or'] as List<Input$NotificationTypeFilter>?);

  Input$NotificationTypeFilter? get not =>
      (_$data['not'] as Input$NotificationTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NotificationTypeFilter<Input$NotificationTypeFilter>
      get copyWith => CopyWith$Input$NotificationTypeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationTypeFilter<TRes> {
  factory CopyWith$Input$NotificationTypeFilter(
    Input$NotificationTypeFilter instance,
    TRes Function(Input$NotificationTypeFilter) then,
  ) = _CopyWithImpl$Input$NotificationTypeFilter;

  factory CopyWith$Input$NotificationTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$NotificationTypeFilter>? and,
    List<Input$NotificationTypeFilter>? or,
    Input$NotificationTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$NotificationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$NotificationTypeFilter<
                      Input$NotificationTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$NotificationTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$NotificationTypeFilter<
                      Input$NotificationTypeFilter>>?)
          _fn);
  CopyWith$Input$NotificationTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$NotificationTypeFilter<TRes>
    implements CopyWith$Input$NotificationTypeFilter<TRes> {
  _CopyWithImpl$Input$NotificationTypeFilter(
    this._instance,
    this._then,
  );

  final Input$NotificationTypeFilter _instance;

  final TRes Function(Input$NotificationTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NotificationTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$NotificationTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$NotificationTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$NotificationTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$NotificationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$NotificationTypeFilter<
                          Input$NotificationTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$NotificationTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$NotificationTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$NotificationTypeFilter<
                          Input$NotificationTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$NotificationTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$NotificationTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NotificationTypeFilter.stub(_then(_instance))
        : CopyWith$Input$NotificationTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NotificationTypeFilter<TRes>
    implements CopyWith$Input$NotificationTypeFilter<TRes> {
  _CopyWithStubImpl$Input$NotificationTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$NotificationTypeFilter>? and,
    List<Input$NotificationTypeFilter>? or,
    Input$NotificationTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$NotificationTypeFilter<TRes> get not =>
      CopyWith$Input$NotificationTypeFilter.stub(_res);
}

class Input$NotificationTypeInsertInput {
  factory Input$NotificationTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$NotificationTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$NotificationTypeInsertInput._(this._$data);

  factory Input$NotificationTypeInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$NotificationTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$NotificationTypeInsertInput<Input$NotificationTypeInsertInput>
      get copyWith => CopyWith$Input$NotificationTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationTypeInsertInput<TRes> {
  factory CopyWith$Input$NotificationTypeInsertInput(
    Input$NotificationTypeInsertInput instance,
    TRes Function(Input$NotificationTypeInsertInput) then,
  ) = _CopyWithImpl$Input$NotificationTypeInsertInput;

  factory CopyWith$Input$NotificationTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$NotificationTypeInsertInput<TRes>
    implements CopyWith$Input$NotificationTypeInsertInput<TRes> {
  _CopyWithImpl$Input$NotificationTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$NotificationTypeInsertInput _instance;

  final TRes Function(Input$NotificationTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$NotificationTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$NotificationTypeInsertInput<TRes>
    implements CopyWith$Input$NotificationTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$NotificationTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

class Input$NotificationTypeOrderBy {
  factory Input$NotificationTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      Input$NotificationTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$NotificationTypeOrderBy._(this._$data);

  factory Input$NotificationTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    return Input$NotificationTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    return result$data;
  }

  CopyWith$Input$NotificationTypeOrderBy<Input$NotificationTypeOrderBy>
      get copyWith => CopyWith$Input$NotificationTypeOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationTypeOrderBy<TRes> {
  factory CopyWith$Input$NotificationTypeOrderBy(
    Input$NotificationTypeOrderBy instance,
    TRes Function(Input$NotificationTypeOrderBy) then,
  ) = _CopyWithImpl$Input$NotificationTypeOrderBy;

  factory CopyWith$Input$NotificationTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  });
}

class _CopyWithImpl$Input$NotificationTypeOrderBy<TRes>
    implements CopyWith$Input$NotificationTypeOrderBy<TRes> {
  _CopyWithImpl$Input$NotificationTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$NotificationTypeOrderBy _instance;

  final TRes Function(Input$NotificationTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$NotificationTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$NotificationTypeOrderBy<TRes>
    implements CopyWith$Input$NotificationTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$NotificationTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      _res;
}

class Input$NotificationTypeUpdateInput {
  factory Input$NotificationTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$NotificationTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$NotificationTypeUpdateInput._(this._$data);

  factory Input$NotificationTypeUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$NotificationTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$NotificationTypeUpdateInput<Input$NotificationTypeUpdateInput>
      get copyWith => CopyWith$Input$NotificationTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationTypeUpdateInput<TRes> {
  factory CopyWith$Input$NotificationTypeUpdateInput(
    Input$NotificationTypeUpdateInput instance,
    TRes Function(Input$NotificationTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$NotificationTypeUpdateInput;

  factory CopyWith$Input$NotificationTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$NotificationTypeUpdateInput<TRes>
    implements CopyWith$Input$NotificationTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$NotificationTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$NotificationTypeUpdateInput _instance;

  final TRes Function(Input$NotificationTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$NotificationTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$NotificationTypeUpdateInput<TRes>
    implements CopyWith$Input$NotificationTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$NotificationTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

class Input$NotificationUpdateInput {
  factory Input$NotificationUpdateInput({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  }) =>
      Input$NotificationUpdateInput._({
        if (id != null) r'id': id,
        if (notificationTypeId != null)
          r'notificationTypeId': notificationTypeId,
        if (title != null) r'title': title,
        if (subtitle != null) r'subtitle': subtitle,
        if (messageMarkdown != null) r'messageMarkdown': messageMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (userId != null) r'userId': userId,
        if (isRead != null) r'isRead': isRead,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (applicationId != null) r'applicationId': applicationId,
      });

  Input$NotificationUpdateInput._(this._$data);

  factory Input$NotificationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = data['notificationTypeId'];
      result$data['notificationTypeId'] = (l$notificationTypeId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('subtitle')) {
      final l$subtitle = data['subtitle'];
      result$data['subtitle'] = (l$subtitle as String?);
    }
    if (data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = data['messageMarkdown'];
      result$data['messageMarkdown'] = (l$messageMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = (l$isRead as bool?);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    return Input$NotificationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get notificationTypeId => (_$data['notificationTypeId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get subtitle => (_$data['subtitle'] as String?);

  String? get messageMarkdown => (_$data['messageMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get userId => (_$data['userId'] as String?);

  bool? get isRead => (_$data['isRead'] as bool?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('notificationTypeId')) {
      final l$notificationTypeId = notificationTypeId;
      result$data['notificationTypeId'] = l$notificationTypeId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('subtitle')) {
      final l$subtitle = subtitle;
      result$data['subtitle'] = l$subtitle;
    }
    if (_$data.containsKey('messageMarkdown')) {
      final l$messageMarkdown = messageMarkdown;
      result$data['messageMarkdown'] = l$messageMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] = l$isRead;
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    return result$data;
  }

  CopyWith$Input$NotificationUpdateInput<Input$NotificationUpdateInput>
      get copyWith => CopyWith$Input$NotificationUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$notificationTypeId = notificationTypeId;
    final lOther$notificationTypeId = other.notificationTypeId;
    if (_$data.containsKey('notificationTypeId') !=
        other._$data.containsKey('notificationTypeId')) {
      return false;
    }
    if (l$notificationTypeId != lOther$notificationTypeId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$subtitle = subtitle;
    final lOther$subtitle = other.subtitle;
    if (_$data.containsKey('subtitle') !=
        other._$data.containsKey('subtitle')) {
      return false;
    }
    if (l$subtitle != lOther$subtitle) {
      return false;
    }
    final l$messageMarkdown = messageMarkdown;
    final lOther$messageMarkdown = other.messageMarkdown;
    if (_$data.containsKey('messageMarkdown') !=
        other._$data.containsKey('messageMarkdown')) {
      return false;
    }
    if (l$messageMarkdown != lOther$messageMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$notificationTypeId = notificationTypeId;
    final l$title = title;
    final l$subtitle = subtitle;
    final l$messageMarkdown = messageMarkdown;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$userId = userId;
    final l$isRead = isRead;
    final l$iconUrl = iconUrl;
    final l$applicationId = applicationId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('notificationTypeId')
          ? l$notificationTypeId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('subtitle') ? l$subtitle : const {},
      _$data.containsKey('messageMarkdown') ? l$messageMarkdown : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$NotificationUpdateInput<TRes> {
  factory CopyWith$Input$NotificationUpdateInput(
    Input$NotificationUpdateInput instance,
    TRes Function(Input$NotificationUpdateInput) then,
  ) = _CopyWithImpl$Input$NotificationUpdateInput;

  factory CopyWith$Input$NotificationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationUpdateInput;

  TRes call({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  });
}

class _CopyWithImpl$Input$NotificationUpdateInput<TRes>
    implements CopyWith$Input$NotificationUpdateInput<TRes> {
  _CopyWithImpl$Input$NotificationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$NotificationUpdateInput _instance;

  final TRes Function(Input$NotificationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? notificationTypeId = _undefined,
    Object? title = _undefined,
    Object? subtitle = _undefined,
    Object? messageMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? userId = _undefined,
    Object? isRead = _undefined,
    Object? iconUrl = _undefined,
    Object? applicationId = _undefined,
  }) =>
      _then(Input$NotificationUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (notificationTypeId != _undefined)
          'notificationTypeId': (notificationTypeId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (subtitle != _undefined) 'subtitle': (subtitle as String?),
        if (messageMarkdown != _undefined)
          'messageMarkdown': (messageMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (isRead != _undefined) 'isRead': (isRead as bool?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
      }));
}

class _CopyWithStubImpl$Input$NotificationUpdateInput<TRes>
    implements CopyWith$Input$NotificationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$NotificationUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? notificationTypeId,
    String? title,
    String? subtitle,
    String? messageMarkdown,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? userId,
    bool? isRead,
    String? iconUrl,
    String? applicationId,
  }) =>
      _res;
}

class Input$OnboardingFilter {
  factory Input$OnboardingFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingTypeId,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFilter>? and,
    List<Input$OnboardingFilter>? or,
    Input$OnboardingFilter? not,
  }) =>
      Input$OnboardingFilter._({
        if (id != null) r'id': id,
        if (onboardingTypeId != null) r'onboardingTypeId': onboardingTypeId,
        if (applicationId != null) r'applicationId': applicationId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$OnboardingFilter._(this._$data);

  factory Input$OnboardingFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = data['onboardingTypeId'];
      result$data['onboardingTypeId'] = l$onboardingTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$onboardingTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$OnboardingFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$OnboardingFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingTypeId =>
      (_$data['onboardingTypeId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$OnboardingFilter>? get and =>
      (_$data['and'] as List<Input$OnboardingFilter>?);

  List<Input$OnboardingFilter>? get or =>
      (_$data['or'] as List<Input$OnboardingFilter>?);

  Input$OnboardingFilter? get not => (_$data['not'] as Input$OnboardingFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = onboardingTypeId;
      result$data['onboardingTypeId'] = l$onboardingTypeId?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingFilter<Input$OnboardingFilter> get copyWith =>
      CopyWith$Input$OnboardingFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingTypeId = onboardingTypeId;
    final lOther$onboardingTypeId = other.onboardingTypeId;
    if (_$data.containsKey('onboardingTypeId') !=
        other._$data.containsKey('onboardingTypeId')) {
      return false;
    }
    if (l$onboardingTypeId != lOther$onboardingTypeId) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingTypeId = onboardingTypeId;
    final l$applicationId = applicationId;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingTypeId') ? l$onboardingTypeId : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingFilter<TRes> {
  factory CopyWith$Input$OnboardingFilter(
    Input$OnboardingFilter instance,
    TRes Function(Input$OnboardingFilter) then,
  ) = _CopyWithImpl$Input$OnboardingFilter;

  factory CopyWith$Input$OnboardingFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingTypeId,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFilter>? and,
    List<Input$OnboardingFilter>? or,
    Input$OnboardingFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get onboardingTypeId;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$OnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingFilter<Input$OnboardingFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$OnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingFilter<Input$OnboardingFilter>>?)
          _fn);
  CopyWith$Input$OnboardingFilter<TRes> get not;
}

class _CopyWithImpl$Input$OnboardingFilter<TRes>
    implements CopyWith$Input$OnboardingFilter<TRes> {
  _CopyWithImpl$Input$OnboardingFilter(
    this._instance,
    this._then,
  );

  final Input$OnboardingFilter _instance;

  final TRes Function(Input$OnboardingFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingTypeId = _undefined,
    Object? applicationId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$OnboardingFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (onboardingTypeId != _undefined)
          'onboardingTypeId': (onboardingTypeId as Input$UUIDFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$OnboardingFilter>?),
        if (or != _undefined) 'or': (or as List<Input$OnboardingFilter>?),
        if (not != _undefined) 'not': (not as Input$OnboardingFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingTypeId {
    final local$onboardingTypeId = _instance.onboardingTypeId;
    return local$onboardingTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingTypeId, (e) => call(onboardingTypeId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$OnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingFilter<Input$OnboardingFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$OnboardingFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$OnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingFilter<Input$OnboardingFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$OnboardingFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$OnboardingFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$OnboardingFilter.stub(_then(_instance))
        : CopyWith$Input$OnboardingFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$OnboardingFilter<TRes>
    implements CopyWith$Input$OnboardingFilter<TRes> {
  _CopyWithStubImpl$Input$OnboardingFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingTypeId,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFilter>? and,
    List<Input$OnboardingFilter>? or,
    Input$OnboardingFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$OnboardingFilter<TRes> get not =>
      CopyWith$Input$OnboardingFilter.stub(_res);
}

class Input$OnboardingFormFilter {
  factory Input$OnboardingFormFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isRequired,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFormFilter>? and,
    List<Input$OnboardingFormFilter>? or,
    Input$OnboardingFormFilter? not,
  }) =>
      Input$OnboardingFormFilter._({
        if (id != null) r'id': id,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRequired != null) r'isRequired': isRequired,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$OnboardingFormFilter._(this._$data);

  factory Input$OnboardingFormFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : Input$UUIDFilter.fromJson((l$onboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : Input$UUIDFilter.fromJson((l$formId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isRequired as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingFormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingFormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$OnboardingFormFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$OnboardingFormFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingId =>
      (_$data['onboardingId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get formId => (_$data['formId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isRequired =>
      (_$data['isRequired'] as Input$BooleanFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$OnboardingFormFilter>? get and =>
      (_$data['and'] as List<Input$OnboardingFormFilter>?);

  List<Input$OnboardingFormFilter>? get or =>
      (_$data['or'] as List<Input$OnboardingFormFilter>?);

  Input$OnboardingFormFilter? get not =>
      (_$data['not'] as Input$OnboardingFormFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId?.toJson();
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingFormFilter<Input$OnboardingFormFilter>
      get copyWith => CopyWith$Input$OnboardingFormFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingFormFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingId = onboardingId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    final l$isRequired = isRequired;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingFormFilter<TRes> {
  factory CopyWith$Input$OnboardingFormFilter(
    Input$OnboardingFormFilter instance,
    TRes Function(Input$OnboardingFormFilter) then,
  ) = _CopyWithImpl$Input$OnboardingFormFilter;

  factory CopyWith$Input$OnboardingFormFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingFormFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isRequired,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFormFilter>? and,
    List<Input$OnboardingFormFilter>? or,
    Input$OnboardingFormFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get onboardingId;
  CopyWith$Input$UUIDFilter<TRes> get formId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$BooleanFilter<TRes> get isRequired;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$OnboardingFormFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingFormFilter<
                      Input$OnboardingFormFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$OnboardingFormFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingFormFilter<
                      Input$OnboardingFormFilter>>?)
          _fn);
  CopyWith$Input$OnboardingFormFilter<TRes> get not;
}

class _CopyWithImpl$Input$OnboardingFormFilter<TRes>
    implements CopyWith$Input$OnboardingFormFilter<TRes> {
  _CopyWithImpl$Input$OnboardingFormFilter(
    this._instance,
    this._then,
  );

  final Input$OnboardingFormFilter _instance;

  final TRes Function(Input$OnboardingFormFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
    Object? isRequired = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$OnboardingFormFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Input$UUIDFilter?),
        if (formId != _undefined) 'formId': (formId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Input$BooleanFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$OnboardingFormFilter>?),
        if (or != _undefined) 'or': (or as List<Input$OnboardingFormFilter>?),
        if (not != _undefined) 'not': (not as Input$OnboardingFormFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingId {
    final local$onboardingId = _instance.onboardingId;
    return local$onboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingId, (e) => call(onboardingId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get formId {
    final local$formId = _instance.formId;
    return local$formId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$formId, (e) => call(formId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isRequired {
    final local$isRequired = _instance.isRequired;
    return local$isRequired == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isRequired, (e) => call(isRequired: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$OnboardingFormFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingFormFilter<
                          Input$OnboardingFormFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$OnboardingFormFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$OnboardingFormFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingFormFilter<
                          Input$OnboardingFormFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$OnboardingFormFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$OnboardingFormFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$OnboardingFormFilter.stub(_then(_instance))
        : CopyWith$Input$OnboardingFormFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$OnboardingFormFilter<TRes>
    implements CopyWith$Input$OnboardingFormFilter<TRes> {
  _CopyWithStubImpl$Input$OnboardingFormFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? onboardingId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isRequired,
    Input$IDFilter? nodeId,
    List<Input$OnboardingFormFilter>? and,
    List<Input$OnboardingFormFilter>? or,
    Input$OnboardingFormFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get formId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isRequired =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$OnboardingFormFilter<TRes> get not =>
      CopyWith$Input$OnboardingFormFilter.stub(_res);
}

class Input$OnboardingFormInsertInput {
  factory Input$OnboardingFormInsertInput({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  }) =>
      Input$OnboardingFormInsertInput._({
        if (id != null) r'id': id,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (formId != null) r'formId': formId,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRequired != null) r'isRequired': isRequired,
      });

  Input$OnboardingFormInsertInput._(this._$data);

  factory Input$OnboardingFormInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    return Input$OnboardingFormInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  String? get formId => (_$data['formId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingFormInsertInput<Input$OnboardingFormInsertInput>
      get copyWith => CopyWith$Input$OnboardingFormInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingFormInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingId = onboardingId;
    final l$formId = formId;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$isRequired = isRequired;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingFormInsertInput<TRes> {
  factory CopyWith$Input$OnboardingFormInsertInput(
    Input$OnboardingFormInsertInput instance,
    TRes Function(Input$OnboardingFormInsertInput) then,
  ) = _CopyWithImpl$Input$OnboardingFormInsertInput;

  factory CopyWith$Input$OnboardingFormInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingFormInsertInput;

  TRes call({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  });
}

class _CopyWithImpl$Input$OnboardingFormInsertInput<TRes>
    implements CopyWith$Input$OnboardingFormInsertInput<TRes> {
  _CopyWithImpl$Input$OnboardingFormInsertInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingFormInsertInput _instance;

  final TRes Function(Input$OnboardingFormInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingId = _undefined,
    Object? formId = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? isRequired = _undefined,
  }) =>
      _then(Input$OnboardingFormInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingFormInsertInput<TRes>
    implements CopyWith$Input$OnboardingFormInsertInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingFormInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  }) =>
      _res;
}

class Input$OnboardingFormOrderBy {
  factory Input$OnboardingFormOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isRequired,
  }) =>
      Input$OnboardingFormOrderBy._({
        if (id != null) r'id': id,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRequired != null) r'isRequired': isRequired,
      });

  Input$OnboardingFormOrderBy._(this._$data);

  factory Input$OnboardingFormOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingId as String));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$formId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isRequired as String));
    }
    return Input$OnboardingFormOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingId =>
      (_$data['onboardingId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get formId =>
      (_$data['formId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isRequired =>
      (_$data['isRequired'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingId);
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] =
          l$formId == null ? null : toJson$Enum$OrderByDirection(l$formId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired == null
          ? null
          : toJson$Enum$OrderByDirection(l$isRequired);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingFormOrderBy<Input$OnboardingFormOrderBy>
      get copyWith => CopyWith$Input$OnboardingFormOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingFormOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingId = onboardingId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    final l$isRequired = isRequired;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingFormOrderBy<TRes> {
  factory CopyWith$Input$OnboardingFormOrderBy(
    Input$OnboardingFormOrderBy instance,
    TRes Function(Input$OnboardingFormOrderBy) then,
  ) = _CopyWithImpl$Input$OnboardingFormOrderBy;

  factory CopyWith$Input$OnboardingFormOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingFormOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isRequired,
  });
}

class _CopyWithImpl$Input$OnboardingFormOrderBy<TRes>
    implements CopyWith$Input$OnboardingFormOrderBy<TRes> {
  _CopyWithImpl$Input$OnboardingFormOrderBy(
    this._instance,
    this._then,
  );

  final Input$OnboardingFormOrderBy _instance;

  final TRes Function(Input$OnboardingFormOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
    Object? isRequired = _undefined,
  }) =>
      _then(Input$OnboardingFormOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Enum$OrderByDirection?),
        if (formId != _undefined) 'formId': (formId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingFormOrderBy<TRes>
    implements CopyWith$Input$OnboardingFormOrderBy<TRes> {
  _CopyWithStubImpl$Input$OnboardingFormOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isRequired,
  }) =>
      _res;
}

class Input$OnboardingFormUpdateInput {
  factory Input$OnboardingFormUpdateInput({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  }) =>
      Input$OnboardingFormUpdateInput._({
        if (id != null) r'id': id,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (formId != null) r'formId': formId,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRequired != null) r'isRequired': isRequired,
      });

  Input$OnboardingFormUpdateInput._(this._$data);

  factory Input$OnboardingFormUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    return Input$OnboardingFormUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  String? get formId => (_$data['formId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingFormUpdateInput<Input$OnboardingFormUpdateInput>
      get copyWith => CopyWith$Input$OnboardingFormUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingFormUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingId = onboardingId;
    final l$formId = formId;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$isRequired = isRequired;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingFormUpdateInput<TRes> {
  factory CopyWith$Input$OnboardingFormUpdateInput(
    Input$OnboardingFormUpdateInput instance,
    TRes Function(Input$OnboardingFormUpdateInput) then,
  ) = _CopyWithImpl$Input$OnboardingFormUpdateInput;

  factory CopyWith$Input$OnboardingFormUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingFormUpdateInput;

  TRes call({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  });
}

class _CopyWithImpl$Input$OnboardingFormUpdateInput<TRes>
    implements CopyWith$Input$OnboardingFormUpdateInput<TRes> {
  _CopyWithImpl$Input$OnboardingFormUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingFormUpdateInput _instance;

  final TRes Function(Input$OnboardingFormUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingId = _undefined,
    Object? formId = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? isRequired = _undefined,
  }) =>
      _then(Input$OnboardingFormUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingFormUpdateInput<TRes>
    implements CopyWith$Input$OnboardingFormUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingFormUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? onboardingId,
    String? formId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isRequired,
  }) =>
      _res;
}

class Input$OnboardingInsertInput {
  factory Input$OnboardingInsertInput({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$OnboardingInsertInput._({
        if (id != null) r'id': id,
        if (onboardingTypeId != null) r'onboardingTypeId': onboardingTypeId,
        if (applicationId != null) r'applicationId': applicationId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$OnboardingInsertInput._(this._$data);

  factory Input$OnboardingInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = data['onboardingTypeId'];
      result$data['onboardingTypeId'] = (l$onboardingTypeId as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$OnboardingInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get onboardingTypeId => (_$data['onboardingTypeId'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = onboardingTypeId;
      result$data['onboardingTypeId'] = l$onboardingTypeId;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingInsertInput<Input$OnboardingInsertInput>
      get copyWith => CopyWith$Input$OnboardingInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingTypeId = onboardingTypeId;
    final lOther$onboardingTypeId = other.onboardingTypeId;
    if (_$data.containsKey('onboardingTypeId') !=
        other._$data.containsKey('onboardingTypeId')) {
      return false;
    }
    if (l$onboardingTypeId != lOther$onboardingTypeId) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingTypeId = onboardingTypeId;
    final l$applicationId = applicationId;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingTypeId') ? l$onboardingTypeId : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingInsertInput<TRes> {
  factory CopyWith$Input$OnboardingInsertInput(
    Input$OnboardingInsertInput instance,
    TRes Function(Input$OnboardingInsertInput) then,
  ) = _CopyWithImpl$Input$OnboardingInsertInput;

  factory CopyWith$Input$OnboardingInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingInsertInput;

  TRes call({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$OnboardingInsertInput<TRes>
    implements CopyWith$Input$OnboardingInsertInput<TRes> {
  _CopyWithImpl$Input$OnboardingInsertInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingInsertInput _instance;

  final TRes Function(Input$OnboardingInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingTypeId = _undefined,
    Object? applicationId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$OnboardingInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (onboardingTypeId != _undefined)
          'onboardingTypeId': (onboardingTypeId as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingInsertInput<TRes>
    implements CopyWith$Input$OnboardingInsertInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$OnboardingOrderBy {
  factory Input$OnboardingOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingTypeId,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$OnboardingOrderBy._({
        if (id != null) r'id': id,
        if (onboardingTypeId != null) r'onboardingTypeId': onboardingTypeId,
        if (applicationId != null) r'applicationId': applicationId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$OnboardingOrderBy._(this._$data);

  factory Input$OnboardingOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = data['onboardingTypeId'];
      result$data['onboardingTypeId'] = l$onboardingTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingTypeId as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$OnboardingOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingTypeId =>
      (_$data['onboardingTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = onboardingTypeId;
      result$data['onboardingTypeId'] = l$onboardingTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingTypeId);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingOrderBy<Input$OnboardingOrderBy> get copyWith =>
      CopyWith$Input$OnboardingOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingTypeId = onboardingTypeId;
    final lOther$onboardingTypeId = other.onboardingTypeId;
    if (_$data.containsKey('onboardingTypeId') !=
        other._$data.containsKey('onboardingTypeId')) {
      return false;
    }
    if (l$onboardingTypeId != lOther$onboardingTypeId) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingTypeId = onboardingTypeId;
    final l$applicationId = applicationId;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingTypeId') ? l$onboardingTypeId : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingOrderBy<TRes> {
  factory CopyWith$Input$OnboardingOrderBy(
    Input$OnboardingOrderBy instance,
    TRes Function(Input$OnboardingOrderBy) then,
  ) = _CopyWithImpl$Input$OnboardingOrderBy;

  factory CopyWith$Input$OnboardingOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingTypeId,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$OnboardingOrderBy<TRes>
    implements CopyWith$Input$OnboardingOrderBy<TRes> {
  _CopyWithImpl$Input$OnboardingOrderBy(
    this._instance,
    this._then,
  );

  final Input$OnboardingOrderBy _instance;

  final TRes Function(Input$OnboardingOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingTypeId = _undefined,
    Object? applicationId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$OnboardingOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (onboardingTypeId != _undefined)
          'onboardingTypeId': (onboardingTypeId as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingOrderBy<TRes>
    implements CopyWith$Input$OnboardingOrderBy<TRes> {
  _CopyWithStubImpl$Input$OnboardingOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? onboardingTypeId,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$OnboardingStepFilter {
  factory Input$OnboardingStepFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingStepFilter>? and,
    List<Input$OnboardingStepFilter>? or,
    Input$OnboardingStepFilter? not,
  }) =>
      Input$OnboardingStepFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (formId != null) r'formId': formId,
        if (surveyId != null) r'surveyId': surveyId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$OnboardingStepFilter._(this._$data);

  factory Input$OnboardingStepFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : Input$UUIDFilter.fromJson((l$formId as Map<String, dynamic>));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$surveyId as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : Input$UUIDFilter.fromJson((l$onboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingStepFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingStepFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$OnboardingStepFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$OnboardingStepFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$UUIDFilter? get formId => (_$data['formId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get surveyId => (_$data['surveyId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingId =>
      (_$data['onboardingId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$OnboardingStepFilter>? get and =>
      (_$data['and'] as List<Input$OnboardingStepFilter>?);

  List<Input$OnboardingStepFilter>? get or =>
      (_$data['or'] as List<Input$OnboardingStepFilter>?);

  Input$OnboardingStepFilter? get not =>
      (_$data['not'] as Input$OnboardingStepFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId?.toJson();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId?.toJson();
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingStepFilter<Input$OnboardingStepFilter>
      get copyWith => CopyWith$Input$OnboardingStepFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingStepFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$formId = formId;
    final l$surveyId = surveyId;
    final l$onboardingId = onboardingId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingStepFilter<TRes> {
  factory CopyWith$Input$OnboardingStepFilter(
    Input$OnboardingStepFilter instance,
    TRes Function(Input$OnboardingStepFilter) then,
  ) = _CopyWithImpl$Input$OnboardingStepFilter;

  factory CopyWith$Input$OnboardingStepFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingStepFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingStepFilter>? and,
    List<Input$OnboardingStepFilter>? or,
    Input$OnboardingStepFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$UUIDFilter<TRes> get formId;
  CopyWith$Input$UUIDFilter<TRes> get surveyId;
  CopyWith$Input$UUIDFilter<TRes> get onboardingId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$OnboardingStepFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingStepFilter<
                      Input$OnboardingStepFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$OnboardingStepFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingStepFilter<
                      Input$OnboardingStepFilter>>?)
          _fn);
  CopyWith$Input$OnboardingStepFilter<TRes> get not;
}

class _CopyWithImpl$Input$OnboardingStepFilter<TRes>
    implements CopyWith$Input$OnboardingStepFilter<TRes> {
  _CopyWithImpl$Input$OnboardingStepFilter(
    this._instance,
    this._then,
  );

  final Input$OnboardingStepFilter _instance;

  final TRes Function(Input$OnboardingStepFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? formId = _undefined,
    Object? surveyId = _undefined,
    Object? onboardingId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$OnboardingStepFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (formId != _undefined) 'formId': (formId as Input$UUIDFilter?),
        if (surveyId != _undefined) 'surveyId': (surveyId as Input$UUIDFilter?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$OnboardingStepFilter>?),
        if (or != _undefined) 'or': (or as List<Input$OnboardingStepFilter>?),
        if (not != _undefined) 'not': (not as Input$OnboardingStepFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get formId {
    final local$formId = _instance.formId;
    return local$formId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$formId, (e) => call(formId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get surveyId {
    final local$surveyId = _instance.surveyId;
    return local$surveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$surveyId, (e) => call(surveyId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingId {
    final local$onboardingId = _instance.onboardingId;
    return local$onboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingId, (e) => call(onboardingId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$OnboardingStepFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingStepFilter<
                          Input$OnboardingStepFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$OnboardingStepFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$OnboardingStepFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingStepFilter<
                          Input$OnboardingStepFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$OnboardingStepFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$OnboardingStepFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$OnboardingStepFilter.stub(_then(_instance))
        : CopyWith$Input$OnboardingStepFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$OnboardingStepFilter<TRes>
    implements CopyWith$Input$OnboardingStepFilter<TRes> {
  _CopyWithStubImpl$Input$OnboardingStepFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$IntFilter? index,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$UUIDFilter? formId,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingStepFilter>? and,
    List<Input$OnboardingStepFilter>? or,
    Input$OnboardingStepFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get formId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get surveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$OnboardingStepFilter<TRes> get not =>
      CopyWith$Input$OnboardingStepFilter.stub(_res);
}

class Input$OnboardingStepInsertInput {
  factory Input$OnboardingStepInsertInput({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  }) =>
      Input$OnboardingStepInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (description != null) r'description': description,
        if (formId != null) r'formId': formId,
        if (surveyId != null) r'surveyId': surveyId,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingStepInsertInput._(this._$data);

  factory Input$OnboardingStepInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    return Input$OnboardingStepInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get description => (_$data['description'] as String?);

  String? get formId => (_$data['formId'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingStepInsertInput<Input$OnboardingStepInsertInput>
      get copyWith => CopyWith$Input$OnboardingStepInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingStepInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$description = description;
    final l$formId = formId;
    final l$surveyId = surveyId;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingStepInsertInput<TRes> {
  factory CopyWith$Input$OnboardingStepInsertInput(
    Input$OnboardingStepInsertInput instance,
    TRes Function(Input$OnboardingStepInsertInput) then,
  ) = _CopyWithImpl$Input$OnboardingStepInsertInput;

  factory CopyWith$Input$OnboardingStepInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingStepInsertInput;

  TRes call({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingStepInsertInput<TRes>
    implements CopyWith$Input$OnboardingStepInsertInput<TRes> {
  _CopyWithImpl$Input$OnboardingStepInsertInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingStepInsertInput _instance;

  final TRes Function(Input$OnboardingStepInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? description = _undefined,
    Object? formId = _undefined,
    Object? surveyId = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingStepInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (description != _undefined) 'description': (description as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingStepInsertInput<TRes>
    implements CopyWith$Input$OnboardingStepInsertInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingStepInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingStepOrderBy {
  factory Input$OnboardingStepOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? onboardingId,
  }) =>
      Input$OnboardingStepOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (formId != null) r'formId': formId,
        if (surveyId != null) r'surveyId': surveyId,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingStepOrderBy._(this._$data);

  factory Input$OnboardingStepOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$formId as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$surveyId as String));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingId as String));
    }
    return Input$OnboardingStepOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get formId =>
      (_$data['formId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get surveyId =>
      (_$data['surveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingId =>
      (_$data['onboardingId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] =
          l$formId == null ? null : toJson$Enum$OrderByDirection(l$formId);
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] =
          l$surveyId == null ? null : toJson$Enum$OrderByDirection(l$surveyId);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingId);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingStepOrderBy<Input$OnboardingStepOrderBy>
      get copyWith => CopyWith$Input$OnboardingStepOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingStepOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$formId = formId;
    final l$surveyId = surveyId;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingStepOrderBy<TRes> {
  factory CopyWith$Input$OnboardingStepOrderBy(
    Input$OnboardingStepOrderBy instance,
    TRes Function(Input$OnboardingStepOrderBy) then,
  ) = _CopyWithImpl$Input$OnboardingStepOrderBy;

  factory CopyWith$Input$OnboardingStepOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingStepOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingStepOrderBy<TRes>
    implements CopyWith$Input$OnboardingStepOrderBy<TRes> {
  _CopyWithImpl$Input$OnboardingStepOrderBy(
    this._instance,
    this._then,
  );

  final Input$OnboardingStepOrderBy _instance;

  final TRes Function(Input$OnboardingStepOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? formId = _undefined,
    Object? surveyId = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingStepOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (formId != _undefined) 'formId': (formId as Enum$OrderByDirection?),
        if (surveyId != _undefined)
          'surveyId': (surveyId as Enum$OrderByDirection?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingStepOrderBy<TRes>
    implements CopyWith$Input$OnboardingStepOrderBy<TRes> {
  _CopyWithStubImpl$Input$OnboardingStepOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingStepUpdateInput {
  factory Input$OnboardingStepUpdateInput({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  }) =>
      Input$OnboardingStepUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (index != null) r'index': index,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (description != null) r'description': description,
        if (formId != null) r'formId': formId,
        if (surveyId != null) r'surveyId': surveyId,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingStepUpdateInput._(this._$data);

  factory Input$OnboardingStepUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    return Input$OnboardingStepUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  int? get index => (_$data['index'] as int?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get description => (_$data['description'] as String?);

  String? get formId => (_$data['formId'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingStepUpdateInput<Input$OnboardingStepUpdateInput>
      get copyWith => CopyWith$Input$OnboardingStepUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingStepUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$description = description;
    final l$formId = formId;
    final l$surveyId = surveyId;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingStepUpdateInput<TRes> {
  factory CopyWith$Input$OnboardingStepUpdateInput(
    Input$OnboardingStepUpdateInput instance,
    TRes Function(Input$OnboardingStepUpdateInput) then,
  ) = _CopyWithImpl$Input$OnboardingStepUpdateInput;

  factory CopyWith$Input$OnboardingStepUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingStepUpdateInput;

  TRes call({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingStepUpdateInput<TRes>
    implements CopyWith$Input$OnboardingStepUpdateInput<TRes> {
  _CopyWithImpl$Input$OnboardingStepUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingStepUpdateInput _instance;

  final TRes Function(Input$OnboardingStepUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? index = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? description = _undefined,
    Object? formId = _undefined,
    Object? surveyId = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingStepUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (index != _undefined) 'index': (index as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (description != _undefined) 'description': (description as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingStepUpdateInput<TRes>
    implements CopyWith$Input$OnboardingStepUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingStepUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    int? index,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? description,
    String? formId,
    String? surveyId,
    String? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingSurveyFilter {
  factory Input$OnboardingSurveyFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isRequired,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingSurveyFilter>? and,
    List<Input$OnboardingSurveyFilter>? or,
    Input$OnboardingSurveyFilter? not,
  }) =>
      Input$OnboardingSurveyFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyId != null) r'surveyId': surveyId,
        if (isRequired != null) r'isRequired': isRequired,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$OnboardingSurveyFilter._(this._$data);

  factory Input$OnboardingSurveyFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$surveyId as Map<String, dynamic>));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isRequired as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : Input$UUIDFilter.fromJson((l$onboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$OnboardingSurveyFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$OnboardingSurveyFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$OnboardingSurveyFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$OnboardingSurveyFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get surveyId => (_$data['surveyId'] as Input$UUIDFilter?);

  Input$BooleanFilter? get isRequired =>
      (_$data['isRequired'] as Input$BooleanFilter?);

  Input$UUIDFilter? get onboardingId =>
      (_$data['onboardingId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$OnboardingSurveyFilter>? get and =>
      (_$data['and'] as List<Input$OnboardingSurveyFilter>?);

  List<Input$OnboardingSurveyFilter>? get or =>
      (_$data['or'] as List<Input$OnboardingSurveyFilter>?);

  Input$OnboardingSurveyFilter? get not =>
      (_$data['not'] as Input$OnboardingSurveyFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId?.toJson();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired?.toJson();
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingSurveyFilter<Input$OnboardingSurveyFilter>
      get copyWith => CopyWith$Input$OnboardingSurveyFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingSurveyFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$surveyId = surveyId;
    final l$isRequired = isRequired;
    final l$onboardingId = onboardingId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingSurveyFilter<TRes> {
  factory CopyWith$Input$OnboardingSurveyFilter(
    Input$OnboardingSurveyFilter instance,
    TRes Function(Input$OnboardingSurveyFilter) then,
  ) = _CopyWithImpl$Input$OnboardingSurveyFilter;

  factory CopyWith$Input$OnboardingSurveyFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingSurveyFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isRequired,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingSurveyFilter>? and,
    List<Input$OnboardingSurveyFilter>? or,
    Input$OnboardingSurveyFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get surveyId;
  CopyWith$Input$BooleanFilter<TRes> get isRequired;
  CopyWith$Input$UUIDFilter<TRes> get onboardingId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$OnboardingSurveyFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingSurveyFilter<
                      Input$OnboardingSurveyFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$OnboardingSurveyFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingSurveyFilter<
                      Input$OnboardingSurveyFilter>>?)
          _fn);
  CopyWith$Input$OnboardingSurveyFilter<TRes> get not;
}

class _CopyWithImpl$Input$OnboardingSurveyFilter<TRes>
    implements CopyWith$Input$OnboardingSurveyFilter<TRes> {
  _CopyWithImpl$Input$OnboardingSurveyFilter(
    this._instance,
    this._then,
  );

  final Input$OnboardingSurveyFilter _instance;

  final TRes Function(Input$OnboardingSurveyFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? surveyId = _undefined,
    Object? isRequired = _undefined,
    Object? onboardingId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$OnboardingSurveyFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (surveyId != _undefined) 'surveyId': (surveyId as Input$UUIDFilter?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Input$BooleanFilter?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$OnboardingSurveyFilter>?),
        if (or != _undefined) 'or': (or as List<Input$OnboardingSurveyFilter>?),
        if (not != _undefined) 'not': (not as Input$OnboardingSurveyFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get surveyId {
    final local$surveyId = _instance.surveyId;
    return local$surveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$surveyId, (e) => call(surveyId: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isRequired {
    final local$isRequired = _instance.isRequired;
    return local$isRequired == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isRequired, (e) => call(isRequired: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingId {
    final local$onboardingId = _instance.onboardingId;
    return local$onboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingId, (e) => call(onboardingId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$OnboardingSurveyFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingSurveyFilter<
                          Input$OnboardingSurveyFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$OnboardingSurveyFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$OnboardingSurveyFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingSurveyFilter<
                          Input$OnboardingSurveyFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$OnboardingSurveyFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$OnboardingSurveyFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$OnboardingSurveyFilter.stub(_then(_instance))
        : CopyWith$Input$OnboardingSurveyFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$OnboardingSurveyFilter<TRes>
    implements CopyWith$Input$OnboardingSurveyFilter<TRes> {
  _CopyWithStubImpl$Input$OnboardingSurveyFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isRequired,
    Input$UUIDFilter? onboardingId,
    Input$IDFilter? nodeId,
    List<Input$OnboardingSurveyFilter>? and,
    List<Input$OnboardingSurveyFilter>? or,
    Input$OnboardingSurveyFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get surveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isRequired =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$OnboardingSurveyFilter<TRes> get not =>
      CopyWith$Input$OnboardingSurveyFilter.stub(_res);
}

class Input$OnboardingSurveyInsertInput {
  factory Input$OnboardingSurveyInsertInput({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  }) =>
      Input$OnboardingSurveyInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyId != null) r'surveyId': surveyId,
        if (isRequired != null) r'isRequired': isRequired,
        if (data != null) r'data': data,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingSurveyInsertInput._(this._$data);

  factory Input$OnboardingSurveyInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    return Input$OnboardingSurveyInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get surveyId => (_$data['surveyId'] as String?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingSurveyInsertInput<Input$OnboardingSurveyInsertInput>
      get copyWith => CopyWith$Input$OnboardingSurveyInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingSurveyInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$surveyId = surveyId;
    final l$isRequired = isRequired;
    final l$data = data;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingSurveyInsertInput<TRes> {
  factory CopyWith$Input$OnboardingSurveyInsertInput(
    Input$OnboardingSurveyInsertInput instance,
    TRes Function(Input$OnboardingSurveyInsertInput) then,
  ) = _CopyWithImpl$Input$OnboardingSurveyInsertInput;

  factory CopyWith$Input$OnboardingSurveyInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingSurveyInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingSurveyInsertInput<TRes>
    implements CopyWith$Input$OnboardingSurveyInsertInput<TRes> {
  _CopyWithImpl$Input$OnboardingSurveyInsertInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingSurveyInsertInput _instance;

  final TRes Function(Input$OnboardingSurveyInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? surveyId = _undefined,
    Object? isRequired = _undefined,
    Object? data = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingSurveyInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingSurveyInsertInput<TRes>
    implements CopyWith$Input$OnboardingSurveyInsertInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingSurveyInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingSurveyOrderBy {
  factory Input$OnboardingSurveyOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? onboardingId,
  }) =>
      Input$OnboardingSurveyOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyId != null) r'surveyId': surveyId,
        if (isRequired != null) r'isRequired': isRequired,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingSurveyOrderBy._(this._$data);

  factory Input$OnboardingSurveyOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$surveyId as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isRequired as String));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingId as String));
    }
    return Input$OnboardingSurveyOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get surveyId =>
      (_$data['surveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isRequired =>
      (_$data['isRequired'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingId =>
      (_$data['onboardingId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] =
          l$surveyId == null ? null : toJson$Enum$OrderByDirection(l$surveyId);
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired == null
          ? null
          : toJson$Enum$OrderByDirection(l$isRequired);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingId);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingSurveyOrderBy<Input$OnboardingSurveyOrderBy>
      get copyWith => CopyWith$Input$OnboardingSurveyOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingSurveyOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$surveyId = surveyId;
    final l$isRequired = isRequired;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingSurveyOrderBy<TRes> {
  factory CopyWith$Input$OnboardingSurveyOrderBy(
    Input$OnboardingSurveyOrderBy instance,
    TRes Function(Input$OnboardingSurveyOrderBy) then,
  ) = _CopyWithImpl$Input$OnboardingSurveyOrderBy;

  factory CopyWith$Input$OnboardingSurveyOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingSurveyOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingSurveyOrderBy<TRes>
    implements CopyWith$Input$OnboardingSurveyOrderBy<TRes> {
  _CopyWithImpl$Input$OnboardingSurveyOrderBy(
    this._instance,
    this._then,
  );

  final Input$OnboardingSurveyOrderBy _instance;

  final TRes Function(Input$OnboardingSurveyOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? surveyId = _undefined,
    Object? isRequired = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingSurveyOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (surveyId != _undefined)
          'surveyId': (surveyId as Enum$OrderByDirection?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Enum$OrderByDirection?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingSurveyOrderBy<TRes>
    implements CopyWith$Input$OnboardingSurveyOrderBy<TRes> {
  _CopyWithStubImpl$Input$OnboardingSurveyOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingSurveyUpdateInput {
  factory Input$OnboardingSurveyUpdateInput({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  }) =>
      Input$OnboardingSurveyUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyId != null) r'surveyId': surveyId,
        if (isRequired != null) r'isRequired': isRequired,
        if (data != null) r'data': data,
        if (onboardingId != null) r'onboardingId': onboardingId,
      });

  Input$OnboardingSurveyUpdateInput._(this._$data);

  factory Input$OnboardingSurveyUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    return Input$OnboardingSurveyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get surveyId => (_$data['surveyId'] as String?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    return result$data;
  }

  CopyWith$Input$OnboardingSurveyUpdateInput<Input$OnboardingSurveyUpdateInput>
      get copyWith => CopyWith$Input$OnboardingSurveyUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingSurveyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$surveyId = surveyId;
    final l$isRequired = isRequired;
    final l$data = data;
    final l$onboardingId = onboardingId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingSurveyUpdateInput<TRes> {
  factory CopyWith$Input$OnboardingSurveyUpdateInput(
    Input$OnboardingSurveyUpdateInput instance,
    TRes Function(Input$OnboardingSurveyUpdateInput) then,
  ) = _CopyWithImpl$Input$OnboardingSurveyUpdateInput;

  factory CopyWith$Input$OnboardingSurveyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingSurveyUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  });
}

class _CopyWithImpl$Input$OnboardingSurveyUpdateInput<TRes>
    implements CopyWith$Input$OnboardingSurveyUpdateInput<TRes> {
  _CopyWithImpl$Input$OnboardingSurveyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingSurveyUpdateInput _instance;

  final TRes Function(Input$OnboardingSurveyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? surveyId = _undefined,
    Object? isRequired = _undefined,
    Object? data = _undefined,
    Object? onboardingId = _undefined,
  }) =>
      _then(Input$OnboardingSurveyUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingSurveyUpdateInput<TRes>
    implements CopyWith$Input$OnboardingSurveyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingSurveyUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? surveyId,
    bool? isRequired,
    Map<String, dynamic>? data,
    String? onboardingId,
  }) =>
      _res;
}

class Input$OnboardingTypeFilter {
  factory Input$OnboardingTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingTypeFilter>? and,
    List<Input$OnboardingTypeFilter>? or,
    Input$OnboardingTypeFilter? not,
  }) =>
      Input$OnboardingTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$OnboardingTypeFilter._(this._$data);

  factory Input$OnboardingTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$OnboardingTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$OnboardingTypeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$OnboardingTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$OnboardingTypeFilter>? get and =>
      (_$data['and'] as List<Input$OnboardingTypeFilter>?);

  List<Input$OnboardingTypeFilter>? get or =>
      (_$data['or'] as List<Input$OnboardingTypeFilter>?);

  Input$OnboardingTypeFilter? get not =>
      (_$data['not'] as Input$OnboardingTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingTypeFilter<Input$OnboardingTypeFilter>
      get copyWith => CopyWith$Input$OnboardingTypeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingTypeFilter<TRes> {
  factory CopyWith$Input$OnboardingTypeFilter(
    Input$OnboardingTypeFilter instance,
    TRes Function(Input$OnboardingTypeFilter) then,
  ) = _CopyWithImpl$Input$OnboardingTypeFilter;

  factory CopyWith$Input$OnboardingTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingTypeFilter>? and,
    List<Input$OnboardingTypeFilter>? or,
    Input$OnboardingTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$OnboardingTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingTypeFilter<
                      Input$OnboardingTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$OnboardingTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$OnboardingTypeFilter<
                      Input$OnboardingTypeFilter>>?)
          _fn);
  CopyWith$Input$OnboardingTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$OnboardingTypeFilter<TRes>
    implements CopyWith$Input$OnboardingTypeFilter<TRes> {
  _CopyWithImpl$Input$OnboardingTypeFilter(
    this._instance,
    this._then,
  );

  final Input$OnboardingTypeFilter _instance;

  final TRes Function(Input$OnboardingTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$OnboardingTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$OnboardingTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$OnboardingTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$OnboardingTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$OnboardingTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingTypeFilter<
                          Input$OnboardingTypeFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$OnboardingTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$OnboardingTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$OnboardingTypeFilter<
                          Input$OnboardingTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$OnboardingTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$OnboardingTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$OnboardingTypeFilter.stub(_then(_instance))
        : CopyWith$Input$OnboardingTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$OnboardingTypeFilter<TRes>
    implements CopyWith$Input$OnboardingTypeFilter<TRes> {
  _CopyWithStubImpl$Input$OnboardingTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$OnboardingTypeFilter>? and,
    List<Input$OnboardingTypeFilter>? or,
    Input$OnboardingTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$OnboardingTypeFilter<TRes> get not =>
      CopyWith$Input$OnboardingTypeFilter.stub(_res);
}

class Input$OnboardingTypeInsertInput {
  factory Input$OnboardingTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      Input$OnboardingTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$OnboardingTypeInsertInput._(this._$data);

  factory Input$OnboardingTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$OnboardingTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingTypeInsertInput<Input$OnboardingTypeInsertInput>
      get copyWith => CopyWith$Input$OnboardingTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingTypeInsertInput<TRes> {
  factory CopyWith$Input$OnboardingTypeInsertInput(
    Input$OnboardingTypeInsertInput instance,
    TRes Function(Input$OnboardingTypeInsertInput) then,
  ) = _CopyWithImpl$Input$OnboardingTypeInsertInput;

  factory CopyWith$Input$OnboardingTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$OnboardingTypeInsertInput<TRes>
    implements CopyWith$Input$OnboardingTypeInsertInput<TRes> {
  _CopyWithImpl$Input$OnboardingTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingTypeInsertInput _instance;

  final TRes Function(Input$OnboardingTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$OnboardingTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingTypeInsertInput<TRes>
    implements CopyWith$Input$OnboardingTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$OnboardingTypeOrderBy {
  factory Input$OnboardingTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$OnboardingTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$OnboardingTypeOrderBy._(this._$data);

  factory Input$OnboardingTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$OnboardingTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingTypeOrderBy<Input$OnboardingTypeOrderBy>
      get copyWith => CopyWith$Input$OnboardingTypeOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingTypeOrderBy<TRes> {
  factory CopyWith$Input$OnboardingTypeOrderBy(
    Input$OnboardingTypeOrderBy instance,
    TRes Function(Input$OnboardingTypeOrderBy) then,
  ) = _CopyWithImpl$Input$OnboardingTypeOrderBy;

  factory CopyWith$Input$OnboardingTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$OnboardingTypeOrderBy<TRes>
    implements CopyWith$Input$OnboardingTypeOrderBy<TRes> {
  _CopyWithImpl$Input$OnboardingTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$OnboardingTypeOrderBy _instance;

  final TRes Function(Input$OnboardingTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$OnboardingTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingTypeOrderBy<TRes>
    implements CopyWith$Input$OnboardingTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$OnboardingTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$OnboardingTypeUpdateInput {
  factory Input$OnboardingTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      Input$OnboardingTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$OnboardingTypeUpdateInput._(this._$data);

  factory Input$OnboardingTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$OnboardingTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$OnboardingTypeUpdateInput<Input$OnboardingTypeUpdateInput>
      get copyWith => CopyWith$Input$OnboardingTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingTypeUpdateInput<TRes> {
  factory CopyWith$Input$OnboardingTypeUpdateInput(
    Input$OnboardingTypeUpdateInput instance,
    TRes Function(Input$OnboardingTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$OnboardingTypeUpdateInput;

  factory CopyWith$Input$OnboardingTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$OnboardingTypeUpdateInput<TRes>
    implements CopyWith$Input$OnboardingTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$OnboardingTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingTypeUpdateInput _instance;

  final TRes Function(Input$OnboardingTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$OnboardingTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingTypeUpdateInput<TRes>
    implements CopyWith$Input$OnboardingTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? description,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$OnboardingUpdateInput {
  factory Input$OnboardingUpdateInput({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$OnboardingUpdateInput._({
        if (id != null) r'id': id,
        if (onboardingTypeId != null) r'onboardingTypeId': onboardingTypeId,
        if (applicationId != null) r'applicationId': applicationId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$OnboardingUpdateInput._(this._$data);

  factory Input$OnboardingUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = data['onboardingTypeId'];
      result$data['onboardingTypeId'] = (l$onboardingTypeId as String?);
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$OnboardingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get onboardingTypeId => (_$data['onboardingTypeId'] as String?);

  String? get applicationId => (_$data['applicationId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('onboardingTypeId')) {
      final l$onboardingTypeId = onboardingTypeId;
      result$data['onboardingTypeId'] = l$onboardingTypeId;
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$OnboardingUpdateInput<Input$OnboardingUpdateInput>
      get copyWith => CopyWith$Input$OnboardingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OnboardingUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$onboardingTypeId = onboardingTypeId;
    final lOther$onboardingTypeId = other.onboardingTypeId;
    if (_$data.containsKey('onboardingTypeId') !=
        other._$data.containsKey('onboardingTypeId')) {
      return false;
    }
    if (l$onboardingTypeId != lOther$onboardingTypeId) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$onboardingTypeId = onboardingTypeId;
    final l$applicationId = applicationId;
    final l$name = name;
    final l$description = description;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('onboardingTypeId') ? l$onboardingTypeId : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$OnboardingUpdateInput<TRes> {
  factory CopyWith$Input$OnboardingUpdateInput(
    Input$OnboardingUpdateInput instance,
    TRes Function(Input$OnboardingUpdateInput) then,
  ) = _CopyWithImpl$Input$OnboardingUpdateInput;

  factory CopyWith$Input$OnboardingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OnboardingUpdateInput;

  TRes call({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$OnboardingUpdateInput<TRes>
    implements CopyWith$Input$OnboardingUpdateInput<TRes> {
  _CopyWithImpl$Input$OnboardingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OnboardingUpdateInput _instance;

  final TRes Function(Input$OnboardingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? onboardingTypeId = _undefined,
    Object? applicationId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$OnboardingUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (onboardingTypeId != _undefined)
          'onboardingTypeId': (onboardingTypeId as String?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$OnboardingUpdateInput<TRes>
    implements CopyWith$Input$OnboardingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OnboardingUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? onboardingTypeId,
    String? applicationId,
    String? name,
    String? description,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$OpaqueFilter {
  factory Input$OpaqueFilter({
    String? eq,
    Enum$FilterIs? $is,
  }) =>
      Input$OpaqueFilter._({
        if (eq != null) r'eq': eq,
        if ($is != null) r'is': $is,
      });

  Input$OpaqueFilter._(this._$data);

  factory Input$OpaqueFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    return Input$OpaqueFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    return result$data;
  }

  CopyWith$Input$OpaqueFilter<Input$OpaqueFilter> get copyWith =>
      CopyWith$Input$OpaqueFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpaqueFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$is = $is;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('is') ? l$$is : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpaqueFilter<TRes> {
  factory CopyWith$Input$OpaqueFilter(
    Input$OpaqueFilter instance,
    TRes Function(Input$OpaqueFilter) then,
  ) = _CopyWithImpl$Input$OpaqueFilter;

  factory CopyWith$Input$OpaqueFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$OpaqueFilter;

  TRes call({
    String? eq,
    Enum$FilterIs? $is,
  });
}

class _CopyWithImpl$Input$OpaqueFilter<TRes>
    implements CopyWith$Input$OpaqueFilter<TRes> {
  _CopyWithImpl$Input$OpaqueFilter(
    this._instance,
    this._then,
  );

  final Input$OpaqueFilter _instance;

  final TRes Function(Input$OpaqueFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? $is = _undefined,
  }) =>
      _then(Input$OpaqueFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
      }));
}

class _CopyWithStubImpl$Input$OpaqueFilter<TRes>
    implements CopyWith$Input$OpaqueFilter<TRes> {
  _CopyWithStubImpl$Input$OpaqueFilter(this._res);

  TRes _res;

  call({
    String? eq,
    Enum$FilterIs? $is,
  }) =>
      _res;
}

class Input$PartnerFilter {
  factory Input$PartnerFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? partnerTypeId,
    Input$StringFilter? name,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? webSiteUrl,
    Input$StringFilter? phone,
    Input$IDFilter? nodeId,
    List<Input$PartnerFilter>? and,
    List<Input$PartnerFilter>? or,
    Input$PartnerFilter? not,
  }) =>
      Input$PartnerFilter._({
        if (id != null) r'id': id,
        if (partnerTypeId != null) r'partnerTypeId': partnerTypeId,
        if (name != null) r'name': name,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (webSiteUrl != null) r'webSiteUrl': webSiteUrl,
        if (phone != null) r'phone': phone,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PartnerFilter._(this._$data);

  factory Input$PartnerFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = data['partnerTypeId'];
      result$data['partnerTypeId'] = l$partnerTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$partnerTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = data['webSiteUrl'];
      result$data['webSiteUrl'] = l$webSiteUrl == null
          ? null
          : Input$StringFilter.fromJson((l$webSiteUrl as Map<String, dynamic>));
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = l$phone == null
          ? null
          : Input$StringFilter.fromJson((l$phone as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$PartnerFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$PartnerFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PartnerFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$PartnerFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get partnerTypeId =>
      (_$data['partnerTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get webSiteUrl =>
      (_$data['webSiteUrl'] as Input$StringFilter?);

  Input$StringFilter? get phone => (_$data['phone'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PartnerFilter>? get and =>
      (_$data['and'] as List<Input$PartnerFilter>?);

  List<Input$PartnerFilter>? get or =>
      (_$data['or'] as List<Input$PartnerFilter>?);

  Input$PartnerFilter? get not => (_$data['not'] as Input$PartnerFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = partnerTypeId;
      result$data['partnerTypeId'] = l$partnerTypeId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = webSiteUrl;
      result$data['webSiteUrl'] = l$webSiteUrl?.toJson();
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PartnerFilter<Input$PartnerFilter> get copyWith =>
      CopyWith$Input$PartnerFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$partnerTypeId = partnerTypeId;
    final lOther$partnerTypeId = other.partnerTypeId;
    if (_$data.containsKey('partnerTypeId') !=
        other._$data.containsKey('partnerTypeId')) {
      return false;
    }
    if (l$partnerTypeId != lOther$partnerTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$webSiteUrl = webSiteUrl;
    final lOther$webSiteUrl = other.webSiteUrl;
    if (_$data.containsKey('webSiteUrl') !=
        other._$data.containsKey('webSiteUrl')) {
      return false;
    }
    if (l$webSiteUrl != lOther$webSiteUrl) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$partnerTypeId = partnerTypeId;
    final l$name = name;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$webSiteUrl = webSiteUrl;
    final l$phone = phone;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('partnerTypeId') ? l$partnerTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('webSiteUrl') ? l$webSiteUrl : const {},
      _$data.containsKey('phone') ? l$phone : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerFilter<TRes> {
  factory CopyWith$Input$PartnerFilter(
    Input$PartnerFilter instance,
    TRes Function(Input$PartnerFilter) then,
  ) = _CopyWithImpl$Input$PartnerFilter;

  factory CopyWith$Input$PartnerFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? partnerTypeId,
    Input$StringFilter? name,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? webSiteUrl,
    Input$StringFilter? phone,
    Input$IDFilter? nodeId,
    List<Input$PartnerFilter>? and,
    List<Input$PartnerFilter>? or,
    Input$PartnerFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get partnerTypeId;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringFilter<TRes> get webSiteUrl;
  CopyWith$Input$StringFilter<TRes> get phone;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PartnerFilter>? Function(
              Iterable<CopyWith$Input$PartnerFilter<Input$PartnerFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PartnerFilter>? Function(
              Iterable<CopyWith$Input$PartnerFilter<Input$PartnerFilter>>?)
          _fn);
  CopyWith$Input$PartnerFilter<TRes> get not;
}

class _CopyWithImpl$Input$PartnerFilter<TRes>
    implements CopyWith$Input$PartnerFilter<TRes> {
  _CopyWithImpl$Input$PartnerFilter(
    this._instance,
    this._then,
  );

  final Input$PartnerFilter _instance;

  final TRes Function(Input$PartnerFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? partnerTypeId = _undefined,
    Object? name = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? webSiteUrl = _undefined,
    Object? phone = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PartnerFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (partnerTypeId != _undefined)
          'partnerTypeId': (partnerTypeId as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (webSiteUrl != _undefined)
          'webSiteUrl': (webSiteUrl as Input$StringFilter?),
        if (phone != _undefined) 'phone': (phone as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$PartnerFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PartnerFilter>?),
        if (not != _undefined) 'not': (not as Input$PartnerFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get partnerTypeId {
    final local$partnerTypeId = _instance.partnerTypeId;
    return local$partnerTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$partnerTypeId, (e) => call(partnerTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get webSiteUrl {
    final local$webSiteUrl = _instance.webSiteUrl;
    return local$webSiteUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$webSiteUrl, (e) => call(webSiteUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get phone {
    final local$phone = _instance.phone;
    return local$phone == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$phone, (e) => call(phone: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PartnerFilter>? Function(
                  Iterable<CopyWith$Input$PartnerFilter<Input$PartnerFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$PartnerFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$PartnerFilter>? Function(
                  Iterable<CopyWith$Input$PartnerFilter<Input$PartnerFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PartnerFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$PartnerFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PartnerFilter.stub(_then(_instance))
        : CopyWith$Input$PartnerFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PartnerFilter<TRes>
    implements CopyWith$Input$PartnerFilter<TRes> {
  _CopyWithStubImpl$Input$PartnerFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? partnerTypeId,
    Input$StringFilter? name,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? updatedAt,
    Input$StringFilter? webSiteUrl,
    Input$StringFilter? phone,
    Input$IDFilter? nodeId,
    List<Input$PartnerFilter>? and,
    List<Input$PartnerFilter>? or,
    Input$PartnerFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get partnerTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get webSiteUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get phone =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PartnerFilter<TRes> get not =>
      CopyWith$Input$PartnerFilter.stub(_res);
}

class Input$PartnerInsertInput {
  factory Input$PartnerInsertInput({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  }) =>
      Input$PartnerInsertInput._({
        if (id != null) r'id': id,
        if (partnerTypeId != null) r'partnerTypeId': partnerTypeId,
        if (name != null) r'name': name,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (data != null) r'data': data,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (webSiteUrl != null) r'webSiteUrl': webSiteUrl,
        if (phone != null) r'phone': phone,
      });

  Input$PartnerInsertInput._(this._$data);

  factory Input$PartnerInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = data['partnerTypeId'];
      result$data['partnerTypeId'] = (l$partnerTypeId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = data['webSiteUrl'];
      result$data['webSiteUrl'] = (l$webSiteUrl as String?);
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = (l$phone as String?);
    }
    return Input$PartnerInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get partnerTypeId => (_$data['partnerTypeId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get webSiteUrl => (_$data['webSiteUrl'] as String?);

  String? get phone => (_$data['phone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = partnerTypeId;
      result$data['partnerTypeId'] = l$partnerTypeId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = webSiteUrl;
      result$data['webSiteUrl'] = l$webSiteUrl;
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone;
    }
    return result$data;
  }

  CopyWith$Input$PartnerInsertInput<Input$PartnerInsertInput> get copyWith =>
      CopyWith$Input$PartnerInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$partnerTypeId = partnerTypeId;
    final lOther$partnerTypeId = other.partnerTypeId;
    if (_$data.containsKey('partnerTypeId') !=
        other._$data.containsKey('partnerTypeId')) {
      return false;
    }
    if (l$partnerTypeId != lOther$partnerTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$webSiteUrl = webSiteUrl;
    final lOther$webSiteUrl = other.webSiteUrl;
    if (_$data.containsKey('webSiteUrl') !=
        other._$data.containsKey('webSiteUrl')) {
      return false;
    }
    if (l$webSiteUrl != lOther$webSiteUrl) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$partnerTypeId = partnerTypeId;
    final l$name = name;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$data = data;
    final l$updatedAt = updatedAt;
    final l$webSiteUrl = webSiteUrl;
    final l$phone = phone;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('partnerTypeId') ? l$partnerTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('webSiteUrl') ? l$webSiteUrl : const {},
      _$data.containsKey('phone') ? l$phone : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerInsertInput<TRes> {
  factory CopyWith$Input$PartnerInsertInput(
    Input$PartnerInsertInput instance,
    TRes Function(Input$PartnerInsertInput) then,
  ) = _CopyWithImpl$Input$PartnerInsertInput;

  factory CopyWith$Input$PartnerInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerInsertInput;

  TRes call({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  });
}

class _CopyWithImpl$Input$PartnerInsertInput<TRes>
    implements CopyWith$Input$PartnerInsertInput<TRes> {
  _CopyWithImpl$Input$PartnerInsertInput(
    this._instance,
    this._then,
  );

  final Input$PartnerInsertInput _instance;

  final TRes Function(Input$PartnerInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? partnerTypeId = _undefined,
    Object? name = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? data = _undefined,
    Object? updatedAt = _undefined,
    Object? webSiteUrl = _undefined,
    Object? phone = _undefined,
  }) =>
      _then(Input$PartnerInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (partnerTypeId != _undefined)
          'partnerTypeId': (partnerTypeId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (webSiteUrl != _undefined) 'webSiteUrl': (webSiteUrl as String?),
        if (phone != _undefined) 'phone': (phone as String?),
      }));
}

class _CopyWithStubImpl$Input$PartnerInsertInput<TRes>
    implements CopyWith$Input$PartnerInsertInput<TRes> {
  _CopyWithStubImpl$Input$PartnerInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  }) =>
      _res;
}

class Input$PartnerOrderBy {
  factory Input$PartnerOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? partnerTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? webSiteUrl,
    Enum$OrderByDirection? phone,
  }) =>
      Input$PartnerOrderBy._({
        if (id != null) r'id': id,
        if (partnerTypeId != null) r'partnerTypeId': partnerTypeId,
        if (name != null) r'name': name,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (webSiteUrl != null) r'webSiteUrl': webSiteUrl,
        if (phone != null) r'phone': phone,
      });

  Input$PartnerOrderBy._(this._$data);

  factory Input$PartnerOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = data['partnerTypeId'];
      result$data['partnerTypeId'] = l$partnerTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$partnerTypeId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = data['webSiteUrl'];
      result$data['webSiteUrl'] = l$webSiteUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$webSiteUrl as String));
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = l$phone == null
          ? null
          : fromJson$Enum$OrderByDirection((l$phone as String));
    }
    return Input$PartnerOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get partnerTypeId =>
      (_$data['partnerTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get webSiteUrl =>
      (_$data['webSiteUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get phone =>
      (_$data['phone'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = partnerTypeId;
      result$data['partnerTypeId'] = l$partnerTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$partnerTypeId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = webSiteUrl;
      result$data['webSiteUrl'] = l$webSiteUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$webSiteUrl);
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] =
          l$phone == null ? null : toJson$Enum$OrderByDirection(l$phone);
    }
    return result$data;
  }

  CopyWith$Input$PartnerOrderBy<Input$PartnerOrderBy> get copyWith =>
      CopyWith$Input$PartnerOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$partnerTypeId = partnerTypeId;
    final lOther$partnerTypeId = other.partnerTypeId;
    if (_$data.containsKey('partnerTypeId') !=
        other._$data.containsKey('partnerTypeId')) {
      return false;
    }
    if (l$partnerTypeId != lOther$partnerTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$webSiteUrl = webSiteUrl;
    final lOther$webSiteUrl = other.webSiteUrl;
    if (_$data.containsKey('webSiteUrl') !=
        other._$data.containsKey('webSiteUrl')) {
      return false;
    }
    if (l$webSiteUrl != lOther$webSiteUrl) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$partnerTypeId = partnerTypeId;
    final l$name = name;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$updatedAt = updatedAt;
    final l$webSiteUrl = webSiteUrl;
    final l$phone = phone;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('partnerTypeId') ? l$partnerTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('webSiteUrl') ? l$webSiteUrl : const {},
      _$data.containsKey('phone') ? l$phone : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerOrderBy<TRes> {
  factory CopyWith$Input$PartnerOrderBy(
    Input$PartnerOrderBy instance,
    TRes Function(Input$PartnerOrderBy) then,
  ) = _CopyWithImpl$Input$PartnerOrderBy;

  factory CopyWith$Input$PartnerOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? partnerTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? webSiteUrl,
    Enum$OrderByDirection? phone,
  });
}

class _CopyWithImpl$Input$PartnerOrderBy<TRes>
    implements CopyWith$Input$PartnerOrderBy<TRes> {
  _CopyWithImpl$Input$PartnerOrderBy(
    this._instance,
    this._then,
  );

  final Input$PartnerOrderBy _instance;

  final TRes Function(Input$PartnerOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? partnerTypeId = _undefined,
    Object? name = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? updatedAt = _undefined,
    Object? webSiteUrl = _undefined,
    Object? phone = _undefined,
  }) =>
      _then(Input$PartnerOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (partnerTypeId != _undefined)
          'partnerTypeId': (partnerTypeId as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (webSiteUrl != _undefined)
          'webSiteUrl': (webSiteUrl as Enum$OrderByDirection?),
        if (phone != _undefined) 'phone': (phone as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PartnerOrderBy<TRes>
    implements CopyWith$Input$PartnerOrderBy<TRes> {
  _CopyWithStubImpl$Input$PartnerOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? partnerTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? webSiteUrl,
    Enum$OrderByDirection? phone,
  }) =>
      _res;
}

class Input$PartnerTypeFilter {
  factory Input$PartnerTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PartnerTypeFilter>? and,
    List<Input$PartnerTypeFilter>? or,
    Input$PartnerTypeFilter? not,
  }) =>
      Input$PartnerTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PartnerTypeFilter._(this._$data);

  factory Input$PartnerTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$PartnerTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$PartnerTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PartnerTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$PartnerTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PartnerTypeFilter>? get and =>
      (_$data['and'] as List<Input$PartnerTypeFilter>?);

  List<Input$PartnerTypeFilter>? get or =>
      (_$data['or'] as List<Input$PartnerTypeFilter>?);

  Input$PartnerTypeFilter? get not =>
      (_$data['not'] as Input$PartnerTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PartnerTypeFilter<Input$PartnerTypeFilter> get copyWith =>
      CopyWith$Input$PartnerTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerTypeFilter<TRes> {
  factory CopyWith$Input$PartnerTypeFilter(
    Input$PartnerTypeFilter instance,
    TRes Function(Input$PartnerTypeFilter) then,
  ) = _CopyWithImpl$Input$PartnerTypeFilter;

  factory CopyWith$Input$PartnerTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PartnerTypeFilter>? and,
    List<Input$PartnerTypeFilter>? or,
    Input$PartnerTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PartnerTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$PartnerTypeFilter<Input$PartnerTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PartnerTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$PartnerTypeFilter<Input$PartnerTypeFilter>>?)
          _fn);
  CopyWith$Input$PartnerTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$PartnerTypeFilter<TRes>
    implements CopyWith$Input$PartnerTypeFilter<TRes> {
  _CopyWithImpl$Input$PartnerTypeFilter(
    this._instance,
    this._then,
  );

  final Input$PartnerTypeFilter _instance;

  final TRes Function(Input$PartnerTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PartnerTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$PartnerTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PartnerTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$PartnerTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PartnerTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$PartnerTypeFilter<
                          Input$PartnerTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$PartnerTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$PartnerTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$PartnerTypeFilter<
                          Input$PartnerTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PartnerTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$PartnerTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PartnerTypeFilter.stub(_then(_instance))
        : CopyWith$Input$PartnerTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PartnerTypeFilter<TRes>
    implements CopyWith$Input$PartnerTypeFilter<TRes> {
  _CopyWithStubImpl$Input$PartnerTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? description,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PartnerTypeFilter>? and,
    List<Input$PartnerTypeFilter>? or,
    Input$PartnerTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PartnerTypeFilter<TRes> get not =>
      CopyWith$Input$PartnerTypeFilter.stub(_res);
}

class Input$PartnerTypeInsertInput {
  factory Input$PartnerTypeInsertInput({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$PartnerTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PartnerTypeInsertInput._(this._$data);

  factory Input$PartnerTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PartnerTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PartnerTypeInsertInput<Input$PartnerTypeInsertInput>
      get copyWith => CopyWith$Input$PartnerTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerTypeInsertInput<TRes> {
  factory CopyWith$Input$PartnerTypeInsertInput(
    Input$PartnerTypeInsertInput instance,
    TRes Function(Input$PartnerTypeInsertInput) then,
  ) = _CopyWithImpl$Input$PartnerTypeInsertInput;

  factory CopyWith$Input$PartnerTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PartnerTypeInsertInput<TRes>
    implements CopyWith$Input$PartnerTypeInsertInput<TRes> {
  _CopyWithImpl$Input$PartnerTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$PartnerTypeInsertInput _instance;

  final TRes Function(Input$PartnerTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PartnerTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PartnerTypeInsertInput<TRes>
    implements CopyWith$Input$PartnerTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$PartnerTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PartnerTypeOrderBy {
  factory Input$PartnerTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$PartnerTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PartnerTypeOrderBy._(this._$data);

  factory Input$PartnerTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$PartnerTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$PartnerTypeOrderBy<Input$PartnerTypeOrderBy> get copyWith =>
      CopyWith$Input$PartnerTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerTypeOrderBy<TRes> {
  factory CopyWith$Input$PartnerTypeOrderBy(
    Input$PartnerTypeOrderBy instance,
    TRes Function(Input$PartnerTypeOrderBy) then,
  ) = _CopyWithImpl$Input$PartnerTypeOrderBy;

  factory CopyWith$Input$PartnerTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$PartnerTypeOrderBy<TRes>
    implements CopyWith$Input$PartnerTypeOrderBy<TRes> {
  _CopyWithImpl$Input$PartnerTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$PartnerTypeOrderBy _instance;

  final TRes Function(Input$PartnerTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PartnerTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PartnerTypeOrderBy<TRes>
    implements CopyWith$Input$PartnerTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$PartnerTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$PartnerTypeUpdateInput {
  factory Input$PartnerTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$PartnerTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PartnerTypeUpdateInput._(this._$data);

  factory Input$PartnerTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PartnerTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PartnerTypeUpdateInput<Input$PartnerTypeUpdateInput>
      get copyWith => CopyWith$Input$PartnerTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerTypeUpdateInput<TRes> {
  factory CopyWith$Input$PartnerTypeUpdateInput(
    Input$PartnerTypeUpdateInput instance,
    TRes Function(Input$PartnerTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$PartnerTypeUpdateInput;

  factory CopyWith$Input$PartnerTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PartnerTypeUpdateInput<TRes>
    implements CopyWith$Input$PartnerTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$PartnerTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PartnerTypeUpdateInput _instance;

  final TRes Function(Input$PartnerTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PartnerTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PartnerTypeUpdateInput<TRes>
    implements CopyWith$Input$PartnerTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PartnerTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PartnerUpdateInput {
  factory Input$PartnerUpdateInput({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  }) =>
      Input$PartnerUpdateInput._({
        if (id != null) r'id': id,
        if (partnerTypeId != null) r'partnerTypeId': partnerTypeId,
        if (name != null) r'name': name,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (data != null) r'data': data,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (webSiteUrl != null) r'webSiteUrl': webSiteUrl,
        if (phone != null) r'phone': phone,
      });

  Input$PartnerUpdateInput._(this._$data);

  factory Input$PartnerUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = data['partnerTypeId'];
      result$data['partnerTypeId'] = (l$partnerTypeId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = data['webSiteUrl'];
      result$data['webSiteUrl'] = (l$webSiteUrl as String?);
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = (l$phone as String?);
    }
    return Input$PartnerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get partnerTypeId => (_$data['partnerTypeId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get description => (_$data['description'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get webSiteUrl => (_$data['webSiteUrl'] as String?);

  String? get phone => (_$data['phone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('partnerTypeId')) {
      final l$partnerTypeId = partnerTypeId;
      result$data['partnerTypeId'] = l$partnerTypeId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('webSiteUrl')) {
      final l$webSiteUrl = webSiteUrl;
      result$data['webSiteUrl'] = l$webSiteUrl;
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone;
    }
    return result$data;
  }

  CopyWith$Input$PartnerUpdateInput<Input$PartnerUpdateInput> get copyWith =>
      CopyWith$Input$PartnerUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PartnerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$partnerTypeId = partnerTypeId;
    final lOther$partnerTypeId = other.partnerTypeId;
    if (_$data.containsKey('partnerTypeId') !=
        other._$data.containsKey('partnerTypeId')) {
      return false;
    }
    if (l$partnerTypeId != lOther$partnerTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$webSiteUrl = webSiteUrl;
    final lOther$webSiteUrl = other.webSiteUrl;
    if (_$data.containsKey('webSiteUrl') !=
        other._$data.containsKey('webSiteUrl')) {
      return false;
    }
    if (l$webSiteUrl != lOther$webSiteUrl) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$partnerTypeId = partnerTypeId;
    final l$name = name;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$data = data;
    final l$updatedAt = updatedAt;
    final l$webSiteUrl = webSiteUrl;
    final l$phone = phone;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('partnerTypeId') ? l$partnerTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('webSiteUrl') ? l$webSiteUrl : const {},
      _$data.containsKey('phone') ? l$phone : const {},
    ]);
  }
}

abstract class CopyWith$Input$PartnerUpdateInput<TRes> {
  factory CopyWith$Input$PartnerUpdateInput(
    Input$PartnerUpdateInput instance,
    TRes Function(Input$PartnerUpdateInput) then,
  ) = _CopyWithImpl$Input$PartnerUpdateInput;

  factory CopyWith$Input$PartnerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PartnerUpdateInput;

  TRes call({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  });
}

class _CopyWithImpl$Input$PartnerUpdateInput<TRes>
    implements CopyWith$Input$PartnerUpdateInput<TRes> {
  _CopyWithImpl$Input$PartnerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PartnerUpdateInput _instance;

  final TRes Function(Input$PartnerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? partnerTypeId = _undefined,
    Object? name = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? data = _undefined,
    Object? updatedAt = _undefined,
    Object? webSiteUrl = _undefined,
    Object? phone = _undefined,
  }) =>
      _then(Input$PartnerUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (partnerTypeId != _undefined)
          'partnerTypeId': (partnerTypeId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (description != _undefined) 'description': (description as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (webSiteUrl != _undefined) 'webSiteUrl': (webSiteUrl as String?),
        if (phone != _undefined) 'phone': (phone as String?),
      }));
}

class _CopyWithStubImpl$Input$PartnerUpdateInput<TRes>
    implements CopyWith$Input$PartnerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PartnerUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? partnerTypeId,
    String? name,
    String? iconUrl,
    String? coverUrl,
    DateTime? createdAt,
    String? description,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? data,
    DateTime? updatedAt,
    String? webSiteUrl,
    String? phone,
  }) =>
      _res;
}

class Input$PersonaFilter {
  factory Input$PersonaFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$PersonaFilter>? and,
    List<Input$PersonaFilter>? or,
    Input$PersonaFilter? not,
  }) =>
      Input$PersonaFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PersonaFilter._(this._$data);

  factory Input$PersonaFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : Input$StringFilter.fromJson((l$coverUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$PersonaFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$PersonaFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PersonaFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$PersonaFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get applicationId =>
      (_$data['applicationId'] as Input$UUIDFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$StringFilter? get coverUrl =>
      (_$data['coverUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PersonaFilter>? get and =>
      (_$data['and'] as List<Input$PersonaFilter>?);

  List<Input$PersonaFilter>? get or =>
      (_$data['or'] as List<Input$PersonaFilter>?);

  Input$PersonaFilter? get not => (_$data['not'] as Input$PersonaFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PersonaFilter<Input$PersonaFilter> get copyWith =>
      CopyWith$Input$PersonaFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaFilter<TRes> {
  factory CopyWith$Input$PersonaFilter(
    Input$PersonaFilter instance,
    TRes Function(Input$PersonaFilter) then,
  ) = _CopyWithImpl$Input$PersonaFilter;

  factory CopyWith$Input$PersonaFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$PersonaFilter>? and,
    List<Input$PersonaFilter>? or,
    Input$PersonaFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get applicationId;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$StringFilter<TRes> get coverUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PersonaFilter>? Function(
              Iterable<CopyWith$Input$PersonaFilter<Input$PersonaFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PersonaFilter>? Function(
              Iterable<CopyWith$Input$PersonaFilter<Input$PersonaFilter>>?)
          _fn);
  CopyWith$Input$PersonaFilter<TRes> get not;
}

class _CopyWithImpl$Input$PersonaFilter<TRes>
    implements CopyWith$Input$PersonaFilter<TRes> {
  _CopyWithImpl$Input$PersonaFilter(
    this._instance,
    this._then,
  );

  final Input$PersonaFilter _instance;

  final TRes Function(Input$PersonaFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PersonaFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Input$UUIDFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$PersonaFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PersonaFilter>?),
        if (not != _undefined) 'not': (not as Input$PersonaFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get coverUrl {
    final local$coverUrl = _instance.coverUrl;
    return local$coverUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$coverUrl, (e) => call(coverUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PersonaFilter>? Function(
                  Iterable<CopyWith$Input$PersonaFilter<Input$PersonaFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$PersonaFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$PersonaFilter>? Function(
                  Iterable<CopyWith$Input$PersonaFilter<Input$PersonaFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PersonaFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$PersonaFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PersonaFilter.stub(_then(_instance))
        : CopyWith$Input$PersonaFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PersonaFilter<TRes>
    implements CopyWith$Input$PersonaFilter<TRes> {
  _CopyWithStubImpl$Input$PersonaFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? applicationId,
    Input$StringFilter? iconUrl,
    Input$StringFilter? coverUrl,
    Input$IDFilter? nodeId,
    List<Input$PersonaFilter>? and,
    List<Input$PersonaFilter>? or,
    Input$PersonaFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get applicationId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get coverUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PersonaFilter<TRes> get not =>
      CopyWith$Input$PersonaFilter.stub(_res);
}

class Input$PersonaInsertInput {
  factory Input$PersonaInsertInput({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  }) =>
      Input$PersonaInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (schema != null) r'schema': schema,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$PersonaInsertInput._(this._$data);

  factory Input$PersonaInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    return Input$PersonaInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    return result$data;
  }

  CopyWith$Input$PersonaInsertInput<Input$PersonaInsertInput> get copyWith =>
      CopyWith$Input$PersonaInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$schema = schema;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaInsertInput<TRes> {
  factory CopyWith$Input$PersonaInsertInput(
    Input$PersonaInsertInput instance,
    TRes Function(Input$PersonaInsertInput) then,
  ) = _CopyWithImpl$Input$PersonaInsertInput;

  factory CopyWith$Input$PersonaInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  });
}

class _CopyWithImpl$Input$PersonaInsertInput<TRes>
    implements CopyWith$Input$PersonaInsertInput<TRes> {
  _CopyWithImpl$Input$PersonaInsertInput(
    this._instance,
    this._then,
  );

  final Input$PersonaInsertInput _instance;

  final TRes Function(Input$PersonaInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? schema = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$PersonaInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$PersonaInsertInput<TRes>
    implements CopyWith$Input$PersonaInsertInput<TRes> {
  _CopyWithStubImpl$Input$PersonaInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  }) =>
      _res;
}

class Input$PersonaOnboardingFilter {
  factory Input$PersonaOnboardingFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$UUIDFilter? onboardingId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PersonaOnboardingFilter>? and,
    List<Input$PersonaOnboardingFilter>? or,
    Input$PersonaOnboardingFilter? not,
  }) =>
      Input$PersonaOnboardingFilter._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PersonaOnboardingFilter._(this._$data);

  factory Input$PersonaOnboardingFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : Input$UUIDFilter.fromJson((l$personaId as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : Input$UUIDFilter.fromJson((l$onboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isRequired as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PersonaOnboardingFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PersonaOnboardingFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PersonaOnboardingFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$PersonaOnboardingFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get personaId => (_$data['personaId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingId =>
      (_$data['onboardingId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$BooleanFilter? get isRequired =>
      (_$data['isRequired'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PersonaOnboardingFilter>? get and =>
      (_$data['and'] as List<Input$PersonaOnboardingFilter>?);

  List<Input$PersonaOnboardingFilter>? get or =>
      (_$data['or'] as List<Input$PersonaOnboardingFilter>?);

  Input$PersonaOnboardingFilter? get not =>
      (_$data['not'] as Input$PersonaOnboardingFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId?.toJson();
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PersonaOnboardingFilter<Input$PersonaOnboardingFilter>
      get copyWith => CopyWith$Input$PersonaOnboardingFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaOnboardingFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$onboardingId = onboardingId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaOnboardingFilter<TRes> {
  factory CopyWith$Input$PersonaOnboardingFilter(
    Input$PersonaOnboardingFilter instance,
    TRes Function(Input$PersonaOnboardingFilter) then,
  ) = _CopyWithImpl$Input$PersonaOnboardingFilter;

  factory CopyWith$Input$PersonaOnboardingFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaOnboardingFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$UUIDFilter? onboardingId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PersonaOnboardingFilter>? and,
    List<Input$PersonaOnboardingFilter>? or,
    Input$PersonaOnboardingFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get personaId;
  CopyWith$Input$UUIDFilter<TRes> get onboardingId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$BooleanFilter<TRes> get isRequired;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PersonaOnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$PersonaOnboardingFilter<
                      Input$PersonaOnboardingFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PersonaOnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$PersonaOnboardingFilter<
                      Input$PersonaOnboardingFilter>>?)
          _fn);
  CopyWith$Input$PersonaOnboardingFilter<TRes> get not;
}

class _CopyWithImpl$Input$PersonaOnboardingFilter<TRes>
    implements CopyWith$Input$PersonaOnboardingFilter<TRes> {
  _CopyWithImpl$Input$PersonaOnboardingFilter(
    this._instance,
    this._then,
  );

  final Input$PersonaOnboardingFilter _instance;

  final TRes Function(Input$PersonaOnboardingFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? onboardingId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PersonaOnboardingFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (personaId != _undefined)
          'personaId': (personaId as Input$UUIDFilter?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Input$BooleanFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$PersonaOnboardingFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$PersonaOnboardingFilter>?),
        if (not != _undefined) 'not': (not as Input$PersonaOnboardingFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get personaId {
    final local$personaId = _instance.personaId;
    return local$personaId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$personaId, (e) => call(personaId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingId {
    final local$onboardingId = _instance.onboardingId;
    return local$onboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingId, (e) => call(onboardingId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isRequired {
    final local$isRequired = _instance.isRequired;
    return local$isRequired == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isRequired, (e) => call(isRequired: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PersonaOnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$PersonaOnboardingFilter<
                          Input$PersonaOnboardingFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$PersonaOnboardingFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$PersonaOnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$PersonaOnboardingFilter<
                          Input$PersonaOnboardingFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$PersonaOnboardingFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PersonaOnboardingFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PersonaOnboardingFilter.stub(_then(_instance))
        : CopyWith$Input$PersonaOnboardingFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PersonaOnboardingFilter<TRes>
    implements CopyWith$Input$PersonaOnboardingFilter<TRes> {
  _CopyWithStubImpl$Input$PersonaOnboardingFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$UUIDFilter? onboardingId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PersonaOnboardingFilter>? and,
    List<Input$PersonaOnboardingFilter>? or,
    Input$PersonaOnboardingFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get personaId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isRequired =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PersonaOnboardingFilter<TRes> get not =>
      CopyWith$Input$PersonaOnboardingFilter.stub(_res);
}

class Input$PersonaOnboardingInsertInput {
  factory Input$PersonaOnboardingInsertInput({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      Input$PersonaOnboardingInsertInput._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PersonaOnboardingInsertInput._(this._$data);

  factory Input$PersonaOnboardingInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PersonaOnboardingInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  int? get index => (_$data['index'] as int?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PersonaOnboardingInsertInput<
          Input$PersonaOnboardingInsertInput>
      get copyWith => CopyWith$Input$PersonaOnboardingInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaOnboardingInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$onboardingId = onboardingId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaOnboardingInsertInput<TRes> {
  factory CopyWith$Input$PersonaOnboardingInsertInput(
    Input$PersonaOnboardingInsertInput instance,
    TRes Function(Input$PersonaOnboardingInsertInput) then,
  ) = _CopyWithImpl$Input$PersonaOnboardingInsertInput;

  factory CopyWith$Input$PersonaOnboardingInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaOnboardingInsertInput;

  TRes call({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PersonaOnboardingInsertInput<TRes>
    implements CopyWith$Input$PersonaOnboardingInsertInput<TRes> {
  _CopyWithImpl$Input$PersonaOnboardingInsertInput(
    this._instance,
    this._then,
  );

  final Input$PersonaOnboardingInsertInput _instance;

  final TRes Function(Input$PersonaOnboardingInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? onboardingId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PersonaOnboardingInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PersonaOnboardingInsertInput<TRes>
    implements CopyWith$Input$PersonaOnboardingInsertInput<TRes> {
  _CopyWithStubImpl$Input$PersonaOnboardingInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PersonaOnboardingOrderBy {
  factory Input$PersonaOnboardingOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$PersonaOnboardingOrderBy._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PersonaOnboardingOrderBy._(this._$data);

  factory Input$PersonaOnboardingOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$personaId as String));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isRequired as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$PersonaOnboardingOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get personaId =>
      (_$data['personaId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingId =>
      (_$data['onboardingId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isRequired =>
      (_$data['isRequired'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId == null
          ? null
          : toJson$Enum$OrderByDirection(l$personaId);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired == null
          ? null
          : toJson$Enum$OrderByDirection(l$isRequired);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$PersonaOnboardingOrderBy<Input$PersonaOnboardingOrderBy>
      get copyWith => CopyWith$Input$PersonaOnboardingOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaOnboardingOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$onboardingId = onboardingId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaOnboardingOrderBy<TRes> {
  factory CopyWith$Input$PersonaOnboardingOrderBy(
    Input$PersonaOnboardingOrderBy instance,
    TRes Function(Input$PersonaOnboardingOrderBy) then,
  ) = _CopyWithImpl$Input$PersonaOnboardingOrderBy;

  factory CopyWith$Input$PersonaOnboardingOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaOnboardingOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$PersonaOnboardingOrderBy<TRes>
    implements CopyWith$Input$PersonaOnboardingOrderBy<TRes> {
  _CopyWithImpl$Input$PersonaOnboardingOrderBy(
    this._instance,
    this._then,
  );

  final Input$PersonaOnboardingOrderBy _instance;

  final TRes Function(Input$PersonaOnboardingOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? onboardingId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PersonaOnboardingOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (personaId != _undefined)
          'personaId': (personaId as Enum$OrderByDirection?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PersonaOnboardingOrderBy<TRes>
    implements CopyWith$Input$PersonaOnboardingOrderBy<TRes> {
  _CopyWithStubImpl$Input$PersonaOnboardingOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$PersonaOnboardingUpdateInput {
  factory Input$PersonaOnboardingUpdateInput({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      Input$PersonaOnboardingUpdateInput._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PersonaOnboardingUpdateInput._(this._$data);

  factory Input$PersonaOnboardingUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PersonaOnboardingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  int? get index => (_$data['index'] as int?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PersonaOnboardingUpdateInput<
          Input$PersonaOnboardingUpdateInput>
      get copyWith => CopyWith$Input$PersonaOnboardingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaOnboardingUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$onboardingId = onboardingId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaOnboardingUpdateInput<TRes> {
  factory CopyWith$Input$PersonaOnboardingUpdateInput(
    Input$PersonaOnboardingUpdateInput instance,
    TRes Function(Input$PersonaOnboardingUpdateInput) then,
  ) = _CopyWithImpl$Input$PersonaOnboardingUpdateInput;

  factory CopyWith$Input$PersonaOnboardingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaOnboardingUpdateInput;

  TRes call({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PersonaOnboardingUpdateInput<TRes>
    implements CopyWith$Input$PersonaOnboardingUpdateInput<TRes> {
  _CopyWithImpl$Input$PersonaOnboardingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PersonaOnboardingUpdateInput _instance;

  final TRes Function(Input$PersonaOnboardingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? onboardingId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PersonaOnboardingUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PersonaOnboardingUpdateInput<TRes>
    implements CopyWith$Input$PersonaOnboardingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PersonaOnboardingUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? personaId,
    String? onboardingId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PersonaOrderBy {
  factory Input$PersonaOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  }) =>
      Input$PersonaOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$PersonaOrderBy._(this._$data);

  factory Input$PersonaOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$applicationId as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = l$coverUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$coverUrl as String));
    }
    return Input$PersonaOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get applicationId =>
      (_$data['applicationId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get coverUrl =>
      (_$data['coverUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$OrderByDirection(l$applicationId);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] =
          l$coverUrl == null ? null : toJson$Enum$OrderByDirection(l$coverUrl);
    }
    return result$data;
  }

  CopyWith$Input$PersonaOrderBy<Input$PersonaOrderBy> get copyWith =>
      CopyWith$Input$PersonaOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaOrderBy<TRes> {
  factory CopyWith$Input$PersonaOrderBy(
    Input$PersonaOrderBy instance,
    TRes Function(Input$PersonaOrderBy) then,
  ) = _CopyWithImpl$Input$PersonaOrderBy;

  factory CopyWith$Input$PersonaOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  });
}

class _CopyWithImpl$Input$PersonaOrderBy<TRes>
    implements CopyWith$Input$PersonaOrderBy<TRes> {
  _CopyWithImpl$Input$PersonaOrderBy(
    this._instance,
    this._then,
  );

  final Input$PersonaOrderBy _instance;

  final TRes Function(Input$PersonaOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$PersonaOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
        if (coverUrl != _undefined)
          'coverUrl': (coverUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PersonaOrderBy<TRes>
    implements CopyWith$Input$PersonaOrderBy<TRes> {
  _CopyWithStubImpl$Input$PersonaOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? applicationId,
    Enum$OrderByDirection? iconUrl,
    Enum$OrderByDirection? coverUrl,
  }) =>
      _res;
}

class Input$PersonaUpdateInput {
  factory Input$PersonaUpdateInput({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  }) =>
      Input$PersonaUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (applicationId != null) r'applicationId': applicationId,
        if (schema != null) r'schema': schema,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (coverUrl != null) r'coverUrl': coverUrl,
      });

  Input$PersonaUpdateInput._(this._$data);

  factory Input$PersonaUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = (l$applicationId as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    if (data.containsKey('coverUrl')) {
      final l$coverUrl = data['coverUrl'];
      result$data['coverUrl'] = (l$coverUrl as String?);
    }
    return Input$PersonaUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get applicationId => (_$data['applicationId'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  String? get coverUrl => (_$data['coverUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    if (_$data.containsKey('coverUrl')) {
      final l$coverUrl = coverUrl;
      result$data['coverUrl'] = l$coverUrl;
    }
    return result$data;
  }

  CopyWith$Input$PersonaUpdateInput<Input$PersonaUpdateInput> get copyWith =>
      CopyWith$Input$PersonaUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonaUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$coverUrl = coverUrl;
    final lOther$coverUrl = other.coverUrl;
    if (_$data.containsKey('coverUrl') !=
        other._$data.containsKey('coverUrl')) {
      return false;
    }
    if (l$coverUrl != lOther$coverUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$applicationId = applicationId;
    final l$schema = schema;
    final l$iconUrl = iconUrl;
    final l$coverUrl = coverUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('coverUrl') ? l$coverUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonaUpdateInput<TRes> {
  factory CopyWith$Input$PersonaUpdateInput(
    Input$PersonaUpdateInput instance,
    TRes Function(Input$PersonaUpdateInput) then,
  ) = _CopyWithImpl$Input$PersonaUpdateInput;

  factory CopyWith$Input$PersonaUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonaUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  });
}

class _CopyWithImpl$Input$PersonaUpdateInput<TRes>
    implements CopyWith$Input$PersonaUpdateInput<TRes> {
  _CopyWithImpl$Input$PersonaUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PersonaUpdateInput _instance;

  final TRes Function(Input$PersonaUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? applicationId = _undefined,
    Object? schema = _undefined,
    Object? iconUrl = _undefined,
    Object? coverUrl = _undefined,
  }) =>
      _then(Input$PersonaUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
        if (coverUrl != _undefined) 'coverUrl': (coverUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$PersonaUpdateInput<TRes>
    implements CopyWith$Input$PersonaUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PersonaUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
    String? applicationId,
    Map<String, dynamic>? schema,
    String? iconUrl,
    String? coverUrl,
  }) =>
      _res;
}

class Input$ProfileTypeFilter {
  factory Input$ProfileTypeFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ProfileTypeFilter>? and,
    List<Input$ProfileTypeFilter>? or,
    Input$ProfileTypeFilter? not,
  }) =>
      Input$ProfileTypeFilter._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ProfileTypeFilter._(this._$data);

  factory Input$ProfileTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : Input$UUIDFilter.fromJson((l$personaId as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ProfileTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ProfileTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ProfileTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ProfileTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get personaId => (_$data['personaId'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ProfileTypeFilter>? get and =>
      (_$data['and'] as List<Input$ProfileTypeFilter>?);

  List<Input$ProfileTypeFilter>? get or =>
      (_$data['or'] as List<Input$ProfileTypeFilter>?);

  Input$ProfileTypeFilter? get not =>
      (_$data['not'] as Input$ProfileTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProfileTypeFilter<Input$ProfileTypeFilter> get copyWith =>
      CopyWith$Input$ProfileTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProfileTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProfileTypeFilter<TRes> {
  factory CopyWith$Input$ProfileTypeFilter(
    Input$ProfileTypeFilter instance,
    TRes Function(Input$ProfileTypeFilter) then,
  ) = _CopyWithImpl$Input$ProfileTypeFilter;

  factory CopyWith$Input$ProfileTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ProfileTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ProfileTypeFilter>? and,
    List<Input$ProfileTypeFilter>? or,
    Input$ProfileTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get personaId;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ProfileTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ProfileTypeFilter<Input$ProfileTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ProfileTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$ProfileTypeFilter<Input$ProfileTypeFilter>>?)
          _fn);
  CopyWith$Input$ProfileTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$ProfileTypeFilter<TRes>
    implements CopyWith$Input$ProfileTypeFilter<TRes> {
  _CopyWithImpl$Input$ProfileTypeFilter(
    this._instance,
    this._then,
  );

  final Input$ProfileTypeFilter _instance;

  final TRes Function(Input$ProfileTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ProfileTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (personaId != _undefined)
          'personaId': (personaId as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ProfileTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ProfileTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$ProfileTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get personaId {
    final local$personaId = _instance.personaId;
    return local$personaId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$personaId, (e) => call(personaId: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ProfileTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ProfileTypeFilter<
                          Input$ProfileTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ProfileTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ProfileTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ProfileTypeFilter<
                          Input$ProfileTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ProfileTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ProfileTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ProfileTypeFilter.stub(_then(_instance))
        : CopyWith$Input$ProfileTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ProfileTypeFilter<TRes>
    implements CopyWith$Input$ProfileTypeFilter<TRes> {
  _CopyWithStubImpl$Input$ProfileTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? personaId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ProfileTypeFilter>? and,
    List<Input$ProfileTypeFilter>? or,
    Input$ProfileTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get personaId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ProfileTypeFilter<TRes> get not =>
      CopyWith$Input$ProfileTypeFilter.stub(_res);
}

class Input$ProfileTypeInsertInput {
  factory Input$ProfileTypeInsertInput({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ProfileTypeInsertInput._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ProfileTypeInsertInput._(this._$data);

  factory Input$ProfileTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ProfileTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ProfileTypeInsertInput<Input$ProfileTypeInsertInput>
      get copyWith => CopyWith$Input$ProfileTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProfileTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProfileTypeInsertInput<TRes> {
  factory CopyWith$Input$ProfileTypeInsertInput(
    Input$ProfileTypeInsertInput instance,
    TRes Function(Input$ProfileTypeInsertInput) then,
  ) = _CopyWithImpl$Input$ProfileTypeInsertInput;

  factory CopyWith$Input$ProfileTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProfileTypeInsertInput;

  TRes call({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ProfileTypeInsertInput<TRes>
    implements CopyWith$Input$ProfileTypeInsertInput<TRes> {
  _CopyWithImpl$Input$ProfileTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$ProfileTypeInsertInput _instance;

  final TRes Function(Input$ProfileTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ProfileTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ProfileTypeInsertInput<TRes>
    implements CopyWith$Input$ProfileTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$ProfileTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ProfileTypeOrderBy {
  factory Input$ProfileTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ProfileTypeOrderBy._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ProfileTypeOrderBy._(this._$data);

  factory Input$ProfileTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$personaId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ProfileTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get personaId =>
      (_$data['personaId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId == null
          ? null
          : toJson$Enum$OrderByDirection(l$personaId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ProfileTypeOrderBy<Input$ProfileTypeOrderBy> get copyWith =>
      CopyWith$Input$ProfileTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProfileTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProfileTypeOrderBy<TRes> {
  factory CopyWith$Input$ProfileTypeOrderBy(
    Input$ProfileTypeOrderBy instance,
    TRes Function(Input$ProfileTypeOrderBy) then,
  ) = _CopyWithImpl$Input$ProfileTypeOrderBy;

  factory CopyWith$Input$ProfileTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ProfileTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ProfileTypeOrderBy<TRes>
    implements CopyWith$Input$ProfileTypeOrderBy<TRes> {
  _CopyWithImpl$Input$ProfileTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$ProfileTypeOrderBy _instance;

  final TRes Function(Input$ProfileTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ProfileTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (personaId != _undefined)
          'personaId': (personaId as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ProfileTypeOrderBy<TRes>
    implements CopyWith$Input$ProfileTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$ProfileTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ProfileTypeUpdateInput {
  factory Input$ProfileTypeUpdateInput({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$ProfileTypeUpdateInput._({
        if (id != null) r'id': id,
        if (personaId != null) r'personaId': personaId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ProfileTypeUpdateInput._(this._$data);

  factory Input$ProfileTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ProfileTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ProfileTypeUpdateInput<Input$ProfileTypeUpdateInput>
      get copyWith => CopyWith$Input$ProfileTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProfileTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$personaId = personaId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProfileTypeUpdateInput<TRes> {
  factory CopyWith$Input$ProfileTypeUpdateInput(
    Input$ProfileTypeUpdateInput instance,
    TRes Function(Input$ProfileTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$ProfileTypeUpdateInput;

  factory CopyWith$Input$ProfileTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProfileTypeUpdateInput;

  TRes call({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ProfileTypeUpdateInput<TRes>
    implements CopyWith$Input$ProfileTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$ProfileTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProfileTypeUpdateInput _instance;

  final TRes Function(Input$ProfileTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? personaId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ProfileTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ProfileTypeUpdateInput<TRes>
    implements CopyWith$Input$ProfileTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProfileTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? personaId,
    String? name,
    String? key,
    String? shortDescription,
    String? longDescriptionMarkdown,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PromptFilter {
  factory Input$PromptFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? content,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$PromptFilter>? and,
    List<Input$PromptFilter>? or,
    Input$PromptFilter? not,
  }) =>
      Input$PromptFilter._({
        if (id != null) r'id': id,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (content != null) r'content': content,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (ownerId != null) r'ownerId': ownerId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PromptFilter._(this._$data);

  factory Input$PromptFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$promptTemplateId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringFilter.fromJson((l$content as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PromptFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PromptFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PromptFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$PromptFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get promptTemplateId =>
      (_$data['promptTemplateId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get content => (_$data['content'] as Input$StringFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PromptFilter>? get and =>
      (_$data['and'] as List<Input$PromptFilter>?);

  List<Input$PromptFilter>? get or =>
      (_$data['or'] as List<Input$PromptFilter>?);

  Input$PromptFilter? get not => (_$data['not'] as Input$PromptFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PromptFilter<Input$PromptFilter> get copyWith =>
      CopyWith$Input$PromptFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    final l$content = content;
    final l$updatedAt = updatedAt;
    final l$ownerId = ownerId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptFilter<TRes> {
  factory CopyWith$Input$PromptFilter(
    Input$PromptFilter instance,
    TRes Function(Input$PromptFilter) then,
  ) = _CopyWithImpl$Input$PromptFilter;

  factory CopyWith$Input$PromptFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? content,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$PromptFilter>? and,
    List<Input$PromptFilter>? or,
    Input$PromptFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get content;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PromptFilter>? Function(
              Iterable<CopyWith$Input$PromptFilter<Input$PromptFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PromptFilter>? Function(
              Iterable<CopyWith$Input$PromptFilter<Input$PromptFilter>>?)
          _fn);
  CopyWith$Input$PromptFilter<TRes> get not;
}

class _CopyWithImpl$Input$PromptFilter<TRes>
    implements CopyWith$Input$PromptFilter<TRes> {
  _CopyWithImpl$Input$PromptFilter(
    this._instance,
    this._then,
  );

  final Input$PromptFilter _instance;

  final TRes Function(Input$PromptFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? content = _undefined,
    Object? updatedAt = _undefined,
    Object? ownerId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PromptFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (content != _undefined) 'content': (content as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$PromptFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PromptFilter>?),
        if (not != _undefined) 'not': (not as Input$PromptFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId {
    final local$promptTemplateId = _instance.promptTemplateId;
    return local$promptTemplateId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$promptTemplateId, (e) => call(promptTemplateId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$content, (e) => call(content: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PromptFilter>? Function(
                  Iterable<CopyWith$Input$PromptFilter<Input$PromptFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$PromptFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$PromptFilter>? Function(
                  Iterable<CopyWith$Input$PromptFilter<Input$PromptFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PromptFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$PromptFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PromptFilter.stub(_then(_instance))
        : CopyWith$Input$PromptFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PromptFilter<TRes>
    implements CopyWith$Input$PromptFilter<TRes> {
  _CopyWithStubImpl$Input$PromptFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? content,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? ownerId,
    Input$IDFilter? nodeId,
    List<Input$PromptFilter>? and,
    List<Input$PromptFilter>? or,
    Input$PromptFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get content =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PromptFilter<TRes> get not =>
      CopyWith$Input$PromptFilter.stub(_res);
}

class Input$PromptInsertInput {
  factory Input$PromptInsertInput({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  }) =>
      Input$PromptInsertInput._({
        if (id != null) r'id': id,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (content != null) r'content': content,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$PromptInsertInput._(this._$data);

  factory Input$PromptInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = (l$promptTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    return Input$PromptInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get promptTemplateId => (_$data['promptTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get content => (_$data['content'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get ownerId => (_$data['ownerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    return result$data;
  }

  CopyWith$Input$PromptInsertInput<Input$PromptInsertInput> get copyWith =>
      CopyWith$Input$PromptInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    final l$content = content;
    final l$updatedAt = updatedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptInsertInput<TRes> {
  factory CopyWith$Input$PromptInsertInput(
    Input$PromptInsertInput instance,
    TRes Function(Input$PromptInsertInput) then,
  ) = _CopyWithImpl$Input$PromptInsertInput;

  factory CopyWith$Input$PromptInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptInsertInput;

  TRes call({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$PromptInsertInput<TRes>
    implements CopyWith$Input$PromptInsertInput<TRes> {
  _CopyWithImpl$Input$PromptInsertInput(
    this._instance,
    this._then,
  );

  final Input$PromptInsertInput _instance;

  final TRes Function(Input$PromptInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? content = _undefined,
    Object? updatedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$PromptInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (content != _undefined) 'content': (content as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
      }));
}

class _CopyWithStubImpl$Input$PromptInsertInput<TRes>
    implements CopyWith$Input$PromptInsertInput<TRes> {
  _CopyWithStubImpl$Input$PromptInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  }) =>
      _res;
}

class Input$PromptOrderBy {
  factory Input$PromptOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? ownerId,
  }) =>
      Input$PromptOrderBy._({
        if (id != null) r'id': id,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (content != null) r'content': content,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$PromptOrderBy._(this._$data);

  factory Input$PromptOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$promptTemplateId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$OrderByDirection((l$content as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    return Input$PromptOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get promptTemplateId =>
      (_$data['promptTemplateId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get content =>
      (_$data['content'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : toJson$Enum$OrderByDirection(l$promptTemplateId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$OrderByDirection(l$content);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    return result$data;
  }

  CopyWith$Input$PromptOrderBy<Input$PromptOrderBy> get copyWith =>
      CopyWith$Input$PromptOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    final l$content = content;
    final l$updatedAt = updatedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptOrderBy<TRes> {
  factory CopyWith$Input$PromptOrderBy(
    Input$PromptOrderBy instance,
    TRes Function(Input$PromptOrderBy) then,
  ) = _CopyWithImpl$Input$PromptOrderBy;

  factory CopyWith$Input$PromptOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? ownerId,
  });
}

class _CopyWithImpl$Input$PromptOrderBy<TRes>
    implements CopyWith$Input$PromptOrderBy<TRes> {
  _CopyWithImpl$Input$PromptOrderBy(
    this._instance,
    this._then,
  );

  final Input$PromptOrderBy _instance;

  final TRes Function(Input$PromptOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? content = _undefined,
    Object? updatedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$PromptOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (content != _undefined)
          'content': (content as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PromptOrderBy<TRes>
    implements CopyWith$Input$PromptOrderBy<TRes> {
  _CopyWithStubImpl$Input$PromptOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? ownerId,
  }) =>
      _res;
}

class Input$PromptTemplateFilter {
  factory Input$PromptTemplateFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? roleId,
    Input$StringFilter? content,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateFilter>? and,
    List<Input$PromptTemplateFilter>? or,
    Input$PromptTemplateFilter? not,
  }) =>
      Input$PromptTemplateFilter._({
        if (id != null) r'id': id,
        if (roleId != null) r'roleId': roleId,
        if (content != null) r'content': content,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PromptTemplateFilter._(this._$data);

  factory Input$PromptTemplateFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : Input$UUIDFilter.fromJson((l$roleId as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringFilter.fromJson((l$content as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$PromptTemplateFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$PromptTemplateFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PromptTemplateFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$PromptTemplateFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get roleId => (_$data['roleId'] as Input$UUIDFilter?);

  Input$StringFilter? get content => (_$data['content'] as Input$StringFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PromptTemplateFilter>? get and =>
      (_$data['and'] as List<Input$PromptTemplateFilter>?);

  List<Input$PromptTemplateFilter>? get or =>
      (_$data['or'] as List<Input$PromptTemplateFilter>?);

  Input$PromptTemplateFilter? get not =>
      (_$data['not'] as Input$PromptTemplateFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateFilter<Input$PromptTemplateFilter>
      get copyWith => CopyWith$Input$PromptTemplateFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$roleId = roleId;
    final l$content = content;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateFilter<TRes> {
  factory CopyWith$Input$PromptTemplateFilter(
    Input$PromptTemplateFilter instance,
    TRes Function(Input$PromptTemplateFilter) then,
  ) = _CopyWithImpl$Input$PromptTemplateFilter;

  factory CopyWith$Input$PromptTemplateFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? roleId,
    Input$StringFilter? content,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateFilter>? and,
    List<Input$PromptTemplateFilter>? or,
    Input$PromptTemplateFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get roleId;
  CopyWith$Input$StringFilter<TRes> get content;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PromptTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$PromptTemplateFilter<
                      Input$PromptTemplateFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PromptTemplateFilter>? Function(
              Iterable<
                  CopyWith$Input$PromptTemplateFilter<
                      Input$PromptTemplateFilter>>?)
          _fn);
  CopyWith$Input$PromptTemplateFilter<TRes> get not;
}

class _CopyWithImpl$Input$PromptTemplateFilter<TRes>
    implements CopyWith$Input$PromptTemplateFilter<TRes> {
  _CopyWithImpl$Input$PromptTemplateFilter(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateFilter _instance;

  final TRes Function(Input$PromptTemplateFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? roleId = _undefined,
    Object? content = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PromptTemplateFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (roleId != _undefined) 'roleId': (roleId as Input$UUIDFilter?),
        if (content != _undefined) 'content': (content as Input$StringFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$PromptTemplateFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PromptTemplateFilter>?),
        if (not != _undefined) 'not': (not as Input$PromptTemplateFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get roleId {
    final local$roleId = _instance.roleId;
    return local$roleId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$roleId, (e) => call(roleId: e));
  }

  CopyWith$Input$StringFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$content, (e) => call(content: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PromptTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$PromptTemplateFilter<
                          Input$PromptTemplateFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$PromptTemplateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$PromptTemplateFilter>? Function(
                  Iterable<
                      CopyWith$Input$PromptTemplateFilter<
                          Input$PromptTemplateFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PromptTemplateFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$PromptTemplateFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PromptTemplateFilter.stub(_then(_instance))
        : CopyWith$Input$PromptTemplateFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PromptTemplateFilter<TRes>
    implements CopyWith$Input$PromptTemplateFilter<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? roleId,
    Input$StringFilter? content,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateFilter>? and,
    List<Input$PromptTemplateFilter>? or,
    Input$PromptTemplateFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get roleId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get content =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PromptTemplateFilter<TRes> get not =>
      CopyWith$Input$PromptTemplateFilter.stub(_res);
}

class Input$PromptTemplateInsertInput {
  factory Input$PromptTemplateInsertInput({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$PromptTemplateInsertInput._({
        if (id != null) r'id': id,
        if (roleId != null) r'roleId': roleId,
        if (content != null) r'content': content,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$PromptTemplateInsertInput._(this._$data);

  factory Input$PromptTemplateInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$PromptTemplateInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateInsertInput<Input$PromptTemplateInsertInput>
      get copyWith => CopyWith$Input$PromptTemplateInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$roleId = roleId;
    final l$content = content;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateInsertInput<TRes> {
  factory CopyWith$Input$PromptTemplateInsertInput(
    Input$PromptTemplateInsertInput instance,
    TRes Function(Input$PromptTemplateInsertInput) then,
  ) = _CopyWithImpl$Input$PromptTemplateInsertInput;

  factory CopyWith$Input$PromptTemplateInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateInsertInput;

  TRes call({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateInsertInput<TRes>
    implements CopyWith$Input$PromptTemplateInsertInput<TRes> {
  _CopyWithImpl$Input$PromptTemplateInsertInput(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateInsertInput _instance;

  final TRes Function(Input$PromptTemplateInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? roleId = _undefined,
    Object? content = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$PromptTemplateInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (content != _undefined) 'content': (content as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateInsertInput<TRes>
    implements CopyWith$Input$PromptTemplateInsertInput<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$PromptTemplateOrderBy {
  factory Input$PromptTemplateOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$PromptTemplateOrderBy._({
        if (id != null) r'id': id,
        if (roleId != null) r'roleId': roleId,
        if (content != null) r'content': content,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$PromptTemplateOrderBy._(this._$data);

  factory Input$PromptTemplateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$roleId as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$OrderByDirection((l$content as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$PromptTemplateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get roleId =>
      (_$data['roleId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get content =>
      (_$data['content'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] =
          l$roleId == null ? null : toJson$Enum$OrderByDirection(l$roleId);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$OrderByDirection(l$content);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateOrderBy<Input$PromptTemplateOrderBy>
      get copyWith => CopyWith$Input$PromptTemplateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$roleId = roleId;
    final l$content = content;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateOrderBy<TRes> {
  factory CopyWith$Input$PromptTemplateOrderBy(
    Input$PromptTemplateOrderBy instance,
    TRes Function(Input$PromptTemplateOrderBy) then,
  ) = _CopyWithImpl$Input$PromptTemplateOrderBy;

  factory CopyWith$Input$PromptTemplateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateOrderBy<TRes>
    implements CopyWith$Input$PromptTemplateOrderBy<TRes> {
  _CopyWithImpl$Input$PromptTemplateOrderBy(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateOrderBy _instance;

  final TRes Function(Input$PromptTemplateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? roleId = _undefined,
    Object? content = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$PromptTemplateOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (roleId != _undefined) 'roleId': (roleId as Enum$OrderByDirection?),
        if (content != _undefined)
          'content': (content as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateOrderBy<TRes>
    implements CopyWith$Input$PromptTemplateOrderBy<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? roleId,
    Enum$OrderByDirection? content,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$PromptTemplateUpdateInput {
  factory Input$PromptTemplateUpdateInput({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$PromptTemplateUpdateInput._({
        if (id != null) r'id': id,
        if (roleId != null) r'roleId': roleId,
        if (content != null) r'content': content,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$PromptTemplateUpdateInput._(this._$data);

  factory Input$PromptTemplateUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$PromptTemplateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  String? get content => (_$data['content'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateUpdateInput<Input$PromptTemplateUpdateInput>
      get copyWith => CopyWith$Input$PromptTemplateUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$roleId = roleId;
    final l$content = content;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateUpdateInput<TRes> {
  factory CopyWith$Input$PromptTemplateUpdateInput(
    Input$PromptTemplateUpdateInput instance,
    TRes Function(Input$PromptTemplateUpdateInput) then,
  ) = _CopyWithImpl$Input$PromptTemplateUpdateInput;

  factory CopyWith$Input$PromptTemplateUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateUpdateInput;

  TRes call({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateUpdateInput<TRes>
    implements CopyWith$Input$PromptTemplateUpdateInput<TRes> {
  _CopyWithImpl$Input$PromptTemplateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateUpdateInput _instance;

  final TRes Function(Input$PromptTemplateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? roleId = _undefined,
    Object? content = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$PromptTemplateUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (content != _undefined) 'content': (content as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateUpdateInput<TRes>
    implements CopyWith$Input$PromptTemplateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? roleId,
    String? content,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$PromptTemplateVariableFilter {
  factory Input$PromptTemplateVariableFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableId,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateVariableFilter>? and,
    List<Input$PromptTemplateVariableFilter>? or,
    Input$PromptTemplateVariableFilter? not,
  }) =>
      Input$PromptTemplateVariableFilter._({
        if (id != null) r'id': id,
        if (templateVariableId != null)
          r'templateVariableId': templateVariableId,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PromptTemplateVariableFilter._(this._$data);

  factory Input$PromptTemplateVariableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('templateVariableId')) {
      final l$templateVariableId = data['templateVariableId'];
      result$data['templateVariableId'] = l$templateVariableId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$templateVariableId as Map<String, dynamic>));
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$promptTemplateId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PromptTemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PromptTemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PromptTemplateVariableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$PromptTemplateVariableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get templateVariableId =>
      (_$data['templateVariableId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get promptTemplateId =>
      (_$data['promptTemplateId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PromptTemplateVariableFilter>? get and =>
      (_$data['and'] as List<Input$PromptTemplateVariableFilter>?);

  List<Input$PromptTemplateVariableFilter>? get or =>
      (_$data['or'] as List<Input$PromptTemplateVariableFilter>?);

  Input$PromptTemplateVariableFilter? get not =>
      (_$data['not'] as Input$PromptTemplateVariableFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('templateVariableId')) {
      final l$templateVariableId = templateVariableId;
      result$data['templateVariableId'] = l$templateVariableId?.toJson();
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateVariableFilter<
          Input$PromptTemplateVariableFilter>
      get copyWith => CopyWith$Input$PromptTemplateVariableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateVariableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableId = templateVariableId;
    final lOther$templateVariableId = other.templateVariableId;
    if (_$data.containsKey('templateVariableId') !=
        other._$data.containsKey('templateVariableId')) {
      return false;
    }
    if (l$templateVariableId != lOther$templateVariableId) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableId = templateVariableId;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableId')
          ? l$templateVariableId
          : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateVariableFilter<TRes> {
  factory CopyWith$Input$PromptTemplateVariableFilter(
    Input$PromptTemplateVariableFilter instance,
    TRes Function(Input$PromptTemplateVariableFilter) then,
  ) = _CopyWithImpl$Input$PromptTemplateVariableFilter;

  factory CopyWith$Input$PromptTemplateVariableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateVariableFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableId,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateVariableFilter>? and,
    List<Input$PromptTemplateVariableFilter>? or,
    Input$PromptTemplateVariableFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get templateVariableId;
  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PromptTemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$PromptTemplateVariableFilter<
                      Input$PromptTemplateVariableFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PromptTemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$PromptTemplateVariableFilter<
                      Input$PromptTemplateVariableFilter>>?)
          _fn);
  CopyWith$Input$PromptTemplateVariableFilter<TRes> get not;
}

class _CopyWithImpl$Input$PromptTemplateVariableFilter<TRes>
    implements CopyWith$Input$PromptTemplateVariableFilter<TRes> {
  _CopyWithImpl$Input$PromptTemplateVariableFilter(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateVariableFilter _instance;

  final TRes Function(Input$PromptTemplateVariableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableId = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PromptTemplateVariableFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (templateVariableId != _undefined)
          'templateVariableId': (templateVariableId as Input$UUIDFilter?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$PromptTemplateVariableFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$PromptTemplateVariableFilter>?),
        if (not != _undefined)
          'not': (not as Input$PromptTemplateVariableFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get templateVariableId {
    final local$templateVariableId = _instance.templateVariableId;
    return local$templateVariableId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$templateVariableId, (e) => call(templateVariableId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId {
    final local$promptTemplateId = _instance.promptTemplateId;
    return local$promptTemplateId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$promptTemplateId, (e) => call(promptTemplateId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PromptTemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$PromptTemplateVariableFilter<
                          Input$PromptTemplateVariableFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$PromptTemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$PromptTemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$PromptTemplateVariableFilter<
                          Input$PromptTemplateVariableFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$PromptTemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PromptTemplateVariableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PromptTemplateVariableFilter.stub(_then(_instance))
        : CopyWith$Input$PromptTemplateVariableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PromptTemplateVariableFilter<TRes>
    implements CopyWith$Input$PromptTemplateVariableFilter<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateVariableFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? templateVariableId,
    Input$UUIDFilter? promptTemplateId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$PromptTemplateVariableFilter>? and,
    List<Input$PromptTemplateVariableFilter>? or,
    Input$PromptTemplateVariableFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get templateVariableId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get promptTemplateId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PromptTemplateVariableFilter<TRes> get not =>
      CopyWith$Input$PromptTemplateVariableFilter.stub(_res);
}

class Input$PromptTemplateVariableInsertInput {
  factory Input$PromptTemplateVariableInsertInput({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  }) =>
      Input$PromptTemplateVariableInsertInput._({
        if (id != null) r'id': id,
        if (templateVariableId != null)
          r'templateVariableId': templateVariableId,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PromptTemplateVariableInsertInput._(this._$data);

  factory Input$PromptTemplateVariableInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('templateVariableId')) {
      final l$templateVariableId = data['templateVariableId'];
      result$data['templateVariableId'] = (l$templateVariableId as String?);
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = (l$promptTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PromptTemplateVariableInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get templateVariableId => (_$data['templateVariableId'] as String?);

  String? get promptTemplateId => (_$data['promptTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('templateVariableId')) {
      final l$templateVariableId = templateVariableId;
      result$data['templateVariableId'] = l$templateVariableId;
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateVariableInsertInput<
          Input$PromptTemplateVariableInsertInput>
      get copyWith => CopyWith$Input$PromptTemplateVariableInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateVariableInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableId = templateVariableId;
    final lOther$templateVariableId = other.templateVariableId;
    if (_$data.containsKey('templateVariableId') !=
        other._$data.containsKey('templateVariableId')) {
      return false;
    }
    if (l$templateVariableId != lOther$templateVariableId) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableId = templateVariableId;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableId')
          ? l$templateVariableId
          : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateVariableInsertInput<TRes> {
  factory CopyWith$Input$PromptTemplateVariableInsertInput(
    Input$PromptTemplateVariableInsertInput instance,
    TRes Function(Input$PromptTemplateVariableInsertInput) then,
  ) = _CopyWithImpl$Input$PromptTemplateVariableInsertInput;

  factory CopyWith$Input$PromptTemplateVariableInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateVariableInsertInput;

  TRes call({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateVariableInsertInput<TRes>
    implements CopyWith$Input$PromptTemplateVariableInsertInput<TRes> {
  _CopyWithImpl$Input$PromptTemplateVariableInsertInput(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateVariableInsertInput _instance;

  final TRes Function(Input$PromptTemplateVariableInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableId = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PromptTemplateVariableInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (templateVariableId != _undefined)
          'templateVariableId': (templateVariableId as String?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateVariableInsertInput<TRes>
    implements CopyWith$Input$PromptTemplateVariableInsertInput<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateVariableInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PromptTemplateVariableOrderBy {
  factory Input$PromptTemplateVariableOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableId,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$PromptTemplateVariableOrderBy._({
        if (id != null) r'id': id,
        if (templateVariableId != null)
          r'templateVariableId': templateVariableId,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PromptTemplateVariableOrderBy._(this._$data);

  factory Input$PromptTemplateVariableOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('templateVariableId')) {
      final l$templateVariableId = data['templateVariableId'];
      result$data['templateVariableId'] = l$templateVariableId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$templateVariableId as String));
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$promptTemplateId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$PromptTemplateVariableOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get templateVariableId =>
      (_$data['templateVariableId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get promptTemplateId =>
      (_$data['promptTemplateId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('templateVariableId')) {
      final l$templateVariableId = templateVariableId;
      result$data['templateVariableId'] = l$templateVariableId == null
          ? null
          : toJson$Enum$OrderByDirection(l$templateVariableId);
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId == null
          ? null
          : toJson$Enum$OrderByDirection(l$promptTemplateId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateVariableOrderBy<
          Input$PromptTemplateVariableOrderBy>
      get copyWith => CopyWith$Input$PromptTemplateVariableOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateVariableOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableId = templateVariableId;
    final lOther$templateVariableId = other.templateVariableId;
    if (_$data.containsKey('templateVariableId') !=
        other._$data.containsKey('templateVariableId')) {
      return false;
    }
    if (l$templateVariableId != lOther$templateVariableId) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableId = templateVariableId;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableId')
          ? l$templateVariableId
          : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateVariableOrderBy<TRes> {
  factory CopyWith$Input$PromptTemplateVariableOrderBy(
    Input$PromptTemplateVariableOrderBy instance,
    TRes Function(Input$PromptTemplateVariableOrderBy) then,
  ) = _CopyWithImpl$Input$PromptTemplateVariableOrderBy;

  factory CopyWith$Input$PromptTemplateVariableOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateVariableOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableId,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateVariableOrderBy<TRes>
    implements CopyWith$Input$PromptTemplateVariableOrderBy<TRes> {
  _CopyWithImpl$Input$PromptTemplateVariableOrderBy(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateVariableOrderBy _instance;

  final TRes Function(Input$PromptTemplateVariableOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableId = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PromptTemplateVariableOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (templateVariableId != _undefined)
          'templateVariableId': (templateVariableId as Enum$OrderByDirection?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateVariableOrderBy<TRes>
    implements CopyWith$Input$PromptTemplateVariableOrderBy<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateVariableOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? templateVariableId,
    Enum$OrderByDirection? promptTemplateId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$PromptTemplateVariableUpdateInput {
  factory Input$PromptTemplateVariableUpdateInput({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  }) =>
      Input$PromptTemplateVariableUpdateInput._({
        if (id != null) r'id': id,
        if (templateVariableId != null)
          r'templateVariableId': templateVariableId,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$PromptTemplateVariableUpdateInput._(this._$data);

  factory Input$PromptTemplateVariableUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('templateVariableId')) {
      final l$templateVariableId = data['templateVariableId'];
      result$data['templateVariableId'] = (l$templateVariableId as String?);
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = (l$promptTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$PromptTemplateVariableUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get templateVariableId => (_$data['templateVariableId'] as String?);

  String? get promptTemplateId => (_$data['promptTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('templateVariableId')) {
      final l$templateVariableId = templateVariableId;
      result$data['templateVariableId'] = l$templateVariableId;
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PromptTemplateVariableUpdateInput<
          Input$PromptTemplateVariableUpdateInput>
      get copyWith => CopyWith$Input$PromptTemplateVariableUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptTemplateVariableUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$templateVariableId = templateVariableId;
    final lOther$templateVariableId = other.templateVariableId;
    if (_$data.containsKey('templateVariableId') !=
        other._$data.containsKey('templateVariableId')) {
      return false;
    }
    if (l$templateVariableId != lOther$templateVariableId) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$templateVariableId = templateVariableId;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('templateVariableId')
          ? l$templateVariableId
          : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptTemplateVariableUpdateInput<TRes> {
  factory CopyWith$Input$PromptTemplateVariableUpdateInput(
    Input$PromptTemplateVariableUpdateInput instance,
    TRes Function(Input$PromptTemplateVariableUpdateInput) then,
  ) = _CopyWithImpl$Input$PromptTemplateVariableUpdateInput;

  factory CopyWith$Input$PromptTemplateVariableUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptTemplateVariableUpdateInput;

  TRes call({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$PromptTemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$PromptTemplateVariableUpdateInput<TRes> {
  _CopyWithImpl$Input$PromptTemplateVariableUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PromptTemplateVariableUpdateInput _instance;

  final TRes Function(Input$PromptTemplateVariableUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? templateVariableId = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$PromptTemplateVariableUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (templateVariableId != _undefined)
          'templateVariableId': (templateVariableId as String?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$PromptTemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$PromptTemplateVariableUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PromptTemplateVariableUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? templateVariableId,
    String? promptTemplateId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$PromptUpdateInput {
  factory Input$PromptUpdateInput({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  }) =>
      Input$PromptUpdateInput._({
        if (id != null) r'id': id,
        if (promptTemplateId != null) r'promptTemplateId': promptTemplateId,
        if (createdAt != null) r'createdAt': createdAt,
        if (content != null) r'content': content,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (ownerId != null) r'ownerId': ownerId,
      });

  Input$PromptUpdateInput._(this._$data);

  factory Input$PromptUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = data['promptTemplateId'];
      result$data['promptTemplateId'] = (l$promptTemplateId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    return Input$PromptUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get promptTemplateId => (_$data['promptTemplateId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get content => (_$data['content'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get ownerId => (_$data['ownerId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('promptTemplateId')) {
      final l$promptTemplateId = promptTemplateId;
      result$data['promptTemplateId'] = l$promptTemplateId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    return result$data;
  }

  CopyWith$Input$PromptUpdateInput<Input$PromptUpdateInput> get copyWith =>
      CopyWith$Input$PromptUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$promptTemplateId = promptTemplateId;
    final lOther$promptTemplateId = other.promptTemplateId;
    if (_$data.containsKey('promptTemplateId') !=
        other._$data.containsKey('promptTemplateId')) {
      return false;
    }
    if (l$promptTemplateId != lOther$promptTemplateId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$promptTemplateId = promptTemplateId;
    final l$createdAt = createdAt;
    final l$content = content;
    final l$updatedAt = updatedAt;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('promptTemplateId') ? l$promptTemplateId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromptUpdateInput<TRes> {
  factory CopyWith$Input$PromptUpdateInput(
    Input$PromptUpdateInput instance,
    TRes Function(Input$PromptUpdateInput) then,
  ) = _CopyWithImpl$Input$PromptUpdateInput;

  factory CopyWith$Input$PromptUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptUpdateInput;

  TRes call({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$PromptUpdateInput<TRes>
    implements CopyWith$Input$PromptUpdateInput<TRes> {
  _CopyWithImpl$Input$PromptUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PromptUpdateInput _instance;

  final TRes Function(Input$PromptUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? promptTemplateId = _undefined,
    Object? createdAt = _undefined,
    Object? content = _undefined,
    Object? updatedAt = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$PromptUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (promptTemplateId != _undefined)
          'promptTemplateId': (promptTemplateId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (content != _undefined) 'content': (content as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
      }));
}

class _CopyWithStubImpl$Input$PromptUpdateInput<TRes>
    implements CopyWith$Input$PromptUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PromptUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? promptTemplateId,
    DateTime? createdAt,
    String? content,
    DateTime? updatedAt,
    String? ownerId,
  }) =>
      _res;
}

class Input$PublicationStateFilter {
  factory Input$PublicationStateFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$PublicationStateFilter>? and,
    List<Input$PublicationStateFilter>? or,
    Input$PublicationStateFilter? not,
  }) =>
      Input$PublicationStateFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$PublicationStateFilter._(this._$data);

  factory Input$PublicationStateFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PublicationStateFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PublicationStateFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$PublicationStateFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$PublicationStateFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$PublicationStateFilter>? get and =>
      (_$data['and'] as List<Input$PublicationStateFilter>?);

  List<Input$PublicationStateFilter>? get or =>
      (_$data['or'] as List<Input$PublicationStateFilter>?);

  Input$PublicationStateFilter? get not =>
      (_$data['not'] as Input$PublicationStateFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PublicationStateFilter<Input$PublicationStateFilter>
      get copyWith => CopyWith$Input$PublicationStateFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PublicationStateFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$PublicationStateFilter<TRes> {
  factory CopyWith$Input$PublicationStateFilter(
    Input$PublicationStateFilter instance,
    TRes Function(Input$PublicationStateFilter) then,
  ) = _CopyWithImpl$Input$PublicationStateFilter;

  factory CopyWith$Input$PublicationStateFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PublicationStateFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$PublicationStateFilter>? and,
    List<Input$PublicationStateFilter>? or,
    Input$PublicationStateFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$PublicationStateFilter>? Function(
              Iterable<
                  CopyWith$Input$PublicationStateFilter<
                      Input$PublicationStateFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$PublicationStateFilter>? Function(
              Iterable<
                  CopyWith$Input$PublicationStateFilter<
                      Input$PublicationStateFilter>>?)
          _fn);
  CopyWith$Input$PublicationStateFilter<TRes> get not;
}

class _CopyWithImpl$Input$PublicationStateFilter<TRes>
    implements CopyWith$Input$PublicationStateFilter<TRes> {
  _CopyWithImpl$Input$PublicationStateFilter(
    this._instance,
    this._then,
  );

  final Input$PublicationStateFilter _instance;

  final TRes Function(Input$PublicationStateFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$PublicationStateFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$PublicationStateFilter>?),
        if (or != _undefined) 'or': (or as List<Input$PublicationStateFilter>?),
        if (not != _undefined) 'not': (not as Input$PublicationStateFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$PublicationStateFilter>? Function(
                  Iterable<
                      CopyWith$Input$PublicationStateFilter<
                          Input$PublicationStateFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$PublicationStateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$PublicationStateFilter>? Function(
                  Iterable<
                      CopyWith$Input$PublicationStateFilter<
                          Input$PublicationStateFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$PublicationStateFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PublicationStateFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$PublicationStateFilter.stub(_then(_instance))
        : CopyWith$Input$PublicationStateFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$PublicationStateFilter<TRes>
    implements CopyWith$Input$PublicationStateFilter<TRes> {
  _CopyWithStubImpl$Input$PublicationStateFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$PublicationStateFilter>? and,
    List<Input$PublicationStateFilter>? or,
    Input$PublicationStateFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$PublicationStateFilter<TRes> get not =>
      CopyWith$Input$PublicationStateFilter.stub(_res);
}

class Input$PublicationStateInsertInput {
  factory Input$PublicationStateInsertInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  }) =>
      Input$PublicationStateInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
      });

  Input$PublicationStateInsertInput._(this._$data);

  factory Input$PublicationStateInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    return Input$PublicationStateInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    return result$data;
  }

  CopyWith$Input$PublicationStateInsertInput<Input$PublicationStateInsertInput>
      get copyWith => CopyWith$Input$PublicationStateInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PublicationStateInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
    ]);
  }
}

abstract class CopyWith$Input$PublicationStateInsertInput<TRes> {
  factory CopyWith$Input$PublicationStateInsertInput(
    Input$PublicationStateInsertInput instance,
    TRes Function(Input$PublicationStateInsertInput) then,
  ) = _CopyWithImpl$Input$PublicationStateInsertInput;

  factory CopyWith$Input$PublicationStateInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PublicationStateInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  });
}

class _CopyWithImpl$Input$PublicationStateInsertInput<TRes>
    implements CopyWith$Input$PublicationStateInsertInput<TRes> {
  _CopyWithImpl$Input$PublicationStateInsertInput(
    this._instance,
    this._then,
  );

  final Input$PublicationStateInsertInput _instance;

  final TRes Function(Input$PublicationStateInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
  }) =>
      _then(Input$PublicationStateInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
      }));
}

class _CopyWithStubImpl$Input$PublicationStateInsertInput<TRes>
    implements CopyWith$Input$PublicationStateInsertInput<TRes> {
  _CopyWithStubImpl$Input$PublicationStateInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  }) =>
      _res;
}

class Input$PublicationStateOrderBy {
  factory Input$PublicationStateOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  }) =>
      Input$PublicationStateOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
      });

  Input$PublicationStateOrderBy._(this._$data);

  factory Input$PublicationStateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    return Input$PublicationStateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    return result$data;
  }

  CopyWith$Input$PublicationStateOrderBy<Input$PublicationStateOrderBy>
      get copyWith => CopyWith$Input$PublicationStateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PublicationStateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
    ]);
  }
}

abstract class CopyWith$Input$PublicationStateOrderBy<TRes> {
  factory CopyWith$Input$PublicationStateOrderBy(
    Input$PublicationStateOrderBy instance,
    TRes Function(Input$PublicationStateOrderBy) then,
  ) = _CopyWithImpl$Input$PublicationStateOrderBy;

  factory CopyWith$Input$PublicationStateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$PublicationStateOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  });
}

class _CopyWithImpl$Input$PublicationStateOrderBy<TRes>
    implements CopyWith$Input$PublicationStateOrderBy<TRes> {
  _CopyWithImpl$Input$PublicationStateOrderBy(
    this._instance,
    this._then,
  );

  final Input$PublicationStateOrderBy _instance;

  final TRes Function(Input$PublicationStateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
  }) =>
      _then(Input$PublicationStateOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$PublicationStateOrderBy<TRes>
    implements CopyWith$Input$PublicationStateOrderBy<TRes> {
  _CopyWithStubImpl$Input$PublicationStateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  }) =>
      _res;
}

class Input$PublicationStateUpdateInput {
  factory Input$PublicationStateUpdateInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  }) =>
      Input$PublicationStateUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
      });

  Input$PublicationStateUpdateInput._(this._$data);

  factory Input$PublicationStateUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    return Input$PublicationStateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    return result$data;
  }

  CopyWith$Input$PublicationStateUpdateInput<Input$PublicationStateUpdateInput>
      get copyWith => CopyWith$Input$PublicationStateUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PublicationStateUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
    ]);
  }
}

abstract class CopyWith$Input$PublicationStateUpdateInput<TRes> {
  factory CopyWith$Input$PublicationStateUpdateInput(
    Input$PublicationStateUpdateInput instance,
    TRes Function(Input$PublicationStateUpdateInput) then,
  ) = _CopyWithImpl$Input$PublicationStateUpdateInput;

  factory CopyWith$Input$PublicationStateUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PublicationStateUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  });
}

class _CopyWithImpl$Input$PublicationStateUpdateInput<TRes>
    implements CopyWith$Input$PublicationStateUpdateInput<TRes> {
  _CopyWithImpl$Input$PublicationStateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PublicationStateUpdateInput _instance;

  final TRes Function(Input$PublicationStateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
  }) =>
      _then(Input$PublicationStateUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
      }));
}

class _CopyWithStubImpl$Input$PublicationStateUpdateInput<TRes>
    implements CopyWith$Input$PublicationStateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PublicationStateUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
  }) =>
      _res;
}

class Input$QuestionAnwserChoiceFilter {
  factory Input$QuestionAnwserChoiceFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionAnwserChoiceFilter>? and,
    List<Input$QuestionAnwserChoiceFilter>? or,
    Input$QuestionAnwserChoiceFilter? not,
  }) =>
      Input$QuestionAnwserChoiceFilter._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$QuestionAnwserChoiceFilter._(this._$data);

  factory Input$QuestionAnwserChoiceFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$answerChoiceId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$QuestionAnwserChoiceFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$QuestionAnwserChoiceFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$QuestionAnwserChoiceFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$QuestionAnwserChoiceFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get answerChoiceId =>
      (_$data['answerChoiceId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$QuestionAnwserChoiceFilter>? get and =>
      (_$data['and'] as List<Input$QuestionAnwserChoiceFilter>?);

  List<Input$QuestionAnwserChoiceFilter>? get or =>
      (_$data['or'] as List<Input$QuestionAnwserChoiceFilter>?);

  Input$QuestionAnwserChoiceFilter? get not =>
      (_$data['not'] as Input$QuestionAnwserChoiceFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QuestionAnwserChoiceFilter<Input$QuestionAnwserChoiceFilter>
      get copyWith => CopyWith$Input$QuestionAnwserChoiceFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionAnwserChoiceFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionAnwserChoiceFilter<TRes> {
  factory CopyWith$Input$QuestionAnwserChoiceFilter(
    Input$QuestionAnwserChoiceFilter instance,
    TRes Function(Input$QuestionAnwserChoiceFilter) then,
  ) = _CopyWithImpl$Input$QuestionAnwserChoiceFilter;

  factory CopyWith$Input$QuestionAnwserChoiceFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionAnwserChoiceFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionAnwserChoiceFilter>? and,
    List<Input$QuestionAnwserChoiceFilter>? or,
    Input$QuestionAnwserChoiceFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$QuestionAnwserChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$QuestionAnwserChoiceFilter<
                      Input$QuestionAnwserChoiceFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$QuestionAnwserChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$QuestionAnwserChoiceFilter<
                      Input$QuestionAnwserChoiceFilter>>?)
          _fn);
  CopyWith$Input$QuestionAnwserChoiceFilter<TRes> get not;
}

class _CopyWithImpl$Input$QuestionAnwserChoiceFilter<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceFilter<TRes> {
  _CopyWithImpl$Input$QuestionAnwserChoiceFilter(
    this._instance,
    this._then,
  );

  final Input$QuestionAnwserChoiceFilter _instance;

  final TRes Function(Input$QuestionAnwserChoiceFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$QuestionAnwserChoiceFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$QuestionAnwserChoiceFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$QuestionAnwserChoiceFilter>?),
        if (not != _undefined)
          'not': (not as Input$QuestionAnwserChoiceFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId {
    final local$answerChoiceId = _instance.answerChoiceId;
    return local$answerChoiceId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$answerChoiceId, (e) => call(answerChoiceId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$QuestionAnwserChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionAnwserChoiceFilter<
                          Input$QuestionAnwserChoiceFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$QuestionAnwserChoiceFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$QuestionAnwserChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionAnwserChoiceFilter<
                          Input$QuestionAnwserChoiceFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$QuestionAnwserChoiceFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$QuestionAnwserChoiceFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$QuestionAnwserChoiceFilter.stub(_then(_instance))
        : CopyWith$Input$QuestionAnwserChoiceFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$QuestionAnwserChoiceFilter<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceFilter<TRes> {
  _CopyWithStubImpl$Input$QuestionAnwserChoiceFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionAnwserChoiceFilter>? and,
    List<Input$QuestionAnwserChoiceFilter>? or,
    Input$QuestionAnwserChoiceFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$QuestionAnwserChoiceFilter<TRes> get not =>
      CopyWith$Input$QuestionAnwserChoiceFilter.stub(_res);
}

class Input$QuestionAnwserChoiceInsertInput {
  factory Input$QuestionAnwserChoiceInsertInput({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  }) =>
      Input$QuestionAnwserChoiceInsertInput._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionAnwserChoiceInsertInput._(this._$data);

  factory Input$QuestionAnwserChoiceInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$QuestionAnwserChoiceInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$QuestionAnwserChoiceInsertInput<
          Input$QuestionAnwserChoiceInsertInput>
      get copyWith => CopyWith$Input$QuestionAnwserChoiceInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionAnwserChoiceInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionAnwserChoiceInsertInput<TRes> {
  factory CopyWith$Input$QuestionAnwserChoiceInsertInput(
    Input$QuestionAnwserChoiceInsertInput instance,
    TRes Function(Input$QuestionAnwserChoiceInsertInput) then,
  ) = _CopyWithImpl$Input$QuestionAnwserChoiceInsertInput;

  factory CopyWith$Input$QuestionAnwserChoiceInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionAnwserChoiceInsertInput;

  TRes call({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionAnwserChoiceInsertInput<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceInsertInput<TRes> {
  _CopyWithImpl$Input$QuestionAnwserChoiceInsertInput(
    this._instance,
    this._then,
  );

  final Input$QuestionAnwserChoiceInsertInput _instance;

  final TRes Function(Input$QuestionAnwserChoiceInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionAnwserChoiceInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$QuestionAnwserChoiceInsertInput<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceInsertInput<TRes> {
  _CopyWithStubImpl$Input$QuestionAnwserChoiceInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$QuestionAnwserChoiceOrderBy {
  factory Input$QuestionAnwserChoiceOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$QuestionAnwserChoiceOrderBy._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionAnwserChoiceOrderBy._(this._$data);

  factory Input$QuestionAnwserChoiceOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$answerChoiceId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$QuestionAnwserChoiceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get answerChoiceId =>
      (_$data['answerChoiceId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : toJson$Enum$OrderByDirection(l$answerChoiceId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$QuestionAnwserChoiceOrderBy<Input$QuestionAnwserChoiceOrderBy>
      get copyWith => CopyWith$Input$QuestionAnwserChoiceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionAnwserChoiceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionAnwserChoiceOrderBy<TRes> {
  factory CopyWith$Input$QuestionAnwserChoiceOrderBy(
    Input$QuestionAnwserChoiceOrderBy instance,
    TRes Function(Input$QuestionAnwserChoiceOrderBy) then,
  ) = _CopyWithImpl$Input$QuestionAnwserChoiceOrderBy;

  factory CopyWith$Input$QuestionAnwserChoiceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionAnwserChoiceOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionAnwserChoiceOrderBy<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceOrderBy<TRes> {
  _CopyWithImpl$Input$QuestionAnwserChoiceOrderBy(
    this._instance,
    this._then,
  );

  final Input$QuestionAnwserChoiceOrderBy _instance;

  final TRes Function(Input$QuestionAnwserChoiceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionAnwserChoiceOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$QuestionAnwserChoiceOrderBy<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceOrderBy<TRes> {
  _CopyWithStubImpl$Input$QuestionAnwserChoiceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$QuestionAnwserChoiceUpdateInput {
  factory Input$QuestionAnwserChoiceUpdateInput({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  }) =>
      Input$QuestionAnwserChoiceUpdateInput._({
        if (id != null) r'id': id,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionAnwserChoiceUpdateInput._(this._$data);

  factory Input$QuestionAnwserChoiceUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$QuestionAnwserChoiceUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$QuestionAnwserChoiceUpdateInput<
          Input$QuestionAnwserChoiceUpdateInput>
      get copyWith => CopyWith$Input$QuestionAnwserChoiceUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionAnwserChoiceUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionAnwserChoiceUpdateInput<TRes> {
  factory CopyWith$Input$QuestionAnwserChoiceUpdateInput(
    Input$QuestionAnwserChoiceUpdateInput instance,
    TRes Function(Input$QuestionAnwserChoiceUpdateInput) then,
  ) = _CopyWithImpl$Input$QuestionAnwserChoiceUpdateInput;

  factory CopyWith$Input$QuestionAnwserChoiceUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionAnwserChoiceUpdateInput;

  TRes call({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionAnwserChoiceUpdateInput<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceUpdateInput<TRes> {
  _CopyWithImpl$Input$QuestionAnwserChoiceUpdateInput(
    this._instance,
    this._then,
  );

  final Input$QuestionAnwserChoiceUpdateInput _instance;

  final TRes Function(Input$QuestionAnwserChoiceUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionAnwserChoiceUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$QuestionAnwserChoiceUpdateInput<TRes>
    implements CopyWith$Input$QuestionAnwserChoiceUpdateInput<TRes> {
  _CopyWithStubImpl$Input$QuestionAnwserChoiceUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$QuestionFilter {
  factory Input$QuestionFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionTypeId,
    Input$StringFilter? questionText,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isUserAnswerChoice,
    Input$IDFilter? nodeId,
    List<Input$QuestionFilter>? and,
    List<Input$QuestionFilter>? or,
    Input$QuestionFilter? not,
  }) =>
      Input$QuestionFilter._({
        if (id != null) r'id': id,
        if (questionTypeId != null) r'questionTypeId': questionTypeId,
        if (questionText != null) r'questionText': questionText,
        if (createdAt != null) r'createdAt': createdAt,
        if (isUserAnswerChoice != null)
          r'isUserAnswerChoice': isUserAnswerChoice,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$QuestionFilter._(this._$data);

  factory Input$QuestionFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('questionTypeId')) {
      final l$questionTypeId = data['questionTypeId'];
      result$data['questionTypeId'] = l$questionTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$questionTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('questionText')) {
      final l$questionText = data['questionText'];
      result$data['questionText'] = l$questionText == null
          ? null
          : Input$StringFilter.fromJson(
              (l$questionText as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = data['isUserAnswerChoice'];
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isUserAnswerChoice as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$QuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$QuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$QuestionFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$QuestionFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionTypeId =>
      (_$data['questionTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get questionText =>
      (_$data['questionText'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isUserAnswerChoice =>
      (_$data['isUserAnswerChoice'] as Input$BooleanFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$QuestionFilter>? get and =>
      (_$data['and'] as List<Input$QuestionFilter>?);

  List<Input$QuestionFilter>? get or =>
      (_$data['or'] as List<Input$QuestionFilter>?);

  Input$QuestionFilter? get not => (_$data['not'] as Input$QuestionFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('questionTypeId')) {
      final l$questionTypeId = questionTypeId;
      result$data['questionTypeId'] = l$questionTypeId?.toJson();
    }
    if (_$data.containsKey('questionText')) {
      final l$questionText = questionText;
      result$data['questionText'] = l$questionText?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = isUserAnswerChoice;
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QuestionFilter<Input$QuestionFilter> get copyWith =>
      CopyWith$Input$QuestionFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionTypeId = questionTypeId;
    final lOther$questionTypeId = other.questionTypeId;
    if (_$data.containsKey('questionTypeId') !=
        other._$data.containsKey('questionTypeId')) {
      return false;
    }
    if (l$questionTypeId != lOther$questionTypeId) {
      return false;
    }
    final l$questionText = questionText;
    final lOther$questionText = other.questionText;
    if (_$data.containsKey('questionText') !=
        other._$data.containsKey('questionText')) {
      return false;
    }
    if (l$questionText != lOther$questionText) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isUserAnswerChoice = isUserAnswerChoice;
    final lOther$isUserAnswerChoice = other.isUserAnswerChoice;
    if (_$data.containsKey('isUserAnswerChoice') !=
        other._$data.containsKey('isUserAnswerChoice')) {
      return false;
    }
    if (l$isUserAnswerChoice != lOther$isUserAnswerChoice) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionTypeId = questionTypeId;
    final l$questionText = questionText;
    final l$createdAt = createdAt;
    final l$isUserAnswerChoice = isUserAnswerChoice;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionTypeId') ? l$questionTypeId : const {},
      _$data.containsKey('questionText') ? l$questionText : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isUserAnswerChoice')
          ? l$isUserAnswerChoice
          : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionFilter<TRes> {
  factory CopyWith$Input$QuestionFilter(
    Input$QuestionFilter instance,
    TRes Function(Input$QuestionFilter) then,
  ) = _CopyWithImpl$Input$QuestionFilter;

  factory CopyWith$Input$QuestionFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionTypeId,
    Input$StringFilter? questionText,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isUserAnswerChoice,
    Input$IDFilter? nodeId,
    List<Input$QuestionFilter>? and,
    List<Input$QuestionFilter>? or,
    Input$QuestionFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get questionTypeId;
  CopyWith$Input$StringFilter<TRes> get questionText;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$BooleanFilter<TRes> get isUserAnswerChoice;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$QuestionFilter>? Function(
              Iterable<CopyWith$Input$QuestionFilter<Input$QuestionFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$QuestionFilter>? Function(
              Iterable<CopyWith$Input$QuestionFilter<Input$QuestionFilter>>?)
          _fn);
  CopyWith$Input$QuestionFilter<TRes> get not;
}

class _CopyWithImpl$Input$QuestionFilter<TRes>
    implements CopyWith$Input$QuestionFilter<TRes> {
  _CopyWithImpl$Input$QuestionFilter(
    this._instance,
    this._then,
  );

  final Input$QuestionFilter _instance;

  final TRes Function(Input$QuestionFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionTypeId = _undefined,
    Object? questionText = _undefined,
    Object? createdAt = _undefined,
    Object? isUserAnswerChoice = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$QuestionFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (questionTypeId != _undefined)
          'questionTypeId': (questionTypeId as Input$UUIDFilter?),
        if (questionText != _undefined)
          'questionText': (questionText as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (isUserAnswerChoice != _undefined)
          'isUserAnswerChoice': (isUserAnswerChoice as Input$BooleanFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$QuestionFilter>?),
        if (or != _undefined) 'or': (or as List<Input$QuestionFilter>?),
        if (not != _undefined) 'not': (not as Input$QuestionFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionTypeId {
    final local$questionTypeId = _instance.questionTypeId;
    return local$questionTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionTypeId, (e) => call(questionTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get questionText {
    final local$questionText = _instance.questionText;
    return local$questionText == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$questionText, (e) => call(questionText: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isUserAnswerChoice {
    final local$isUserAnswerChoice = _instance.isUserAnswerChoice;
    return local$isUserAnswerChoice == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isUserAnswerChoice, (e) => call(isUserAnswerChoice: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$QuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionFilter<Input$QuestionFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$QuestionFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$QuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionFilter<Input$QuestionFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$QuestionFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$QuestionFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$QuestionFilter.stub(_then(_instance))
        : CopyWith$Input$QuestionFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$QuestionFilter<TRes>
    implements CopyWith$Input$QuestionFilter<TRes> {
  _CopyWithStubImpl$Input$QuestionFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? questionTypeId,
    Input$StringFilter? questionText,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isUserAnswerChoice,
    Input$IDFilter? nodeId,
    List<Input$QuestionFilter>? and,
    List<Input$QuestionFilter>? or,
    Input$QuestionFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get questionText =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isUserAnswerChoice =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$QuestionFilter<TRes> get not =>
      CopyWith$Input$QuestionFilter.stub(_res);
}

class Input$QuestionInsertInput {
  factory Input$QuestionInsertInput({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  }) =>
      Input$QuestionInsertInput._({
        if (id != null) r'id': id,
        if (questionTypeId != null) r'questionTypeId': questionTypeId,
        if (questionText != null) r'questionText': questionText,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (isUserAnswerChoice != null)
          r'isUserAnswerChoice': isUserAnswerChoice,
      });

  Input$QuestionInsertInput._(this._$data);

  factory Input$QuestionInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionTypeId')) {
      final l$questionTypeId = data['questionTypeId'];
      result$data['questionTypeId'] = (l$questionTypeId as String?);
    }
    if (data.containsKey('questionText')) {
      final l$questionText = data['questionText'];
      result$data['questionText'] = (l$questionText as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = data['isUserAnswerChoice'];
      result$data['isUserAnswerChoice'] = (l$isUserAnswerChoice as bool?);
    }
    return Input$QuestionInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionTypeId => (_$data['questionTypeId'] as String?);

  String? get questionText => (_$data['questionText'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isUserAnswerChoice => (_$data['isUserAnswerChoice'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionTypeId')) {
      final l$questionTypeId = questionTypeId;
      result$data['questionTypeId'] = l$questionTypeId;
    }
    if (_$data.containsKey('questionText')) {
      final l$questionText = questionText;
      result$data['questionText'] = l$questionText;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = isUserAnswerChoice;
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice;
    }
    return result$data;
  }

  CopyWith$Input$QuestionInsertInput<Input$QuestionInsertInput> get copyWith =>
      CopyWith$Input$QuestionInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionTypeId = questionTypeId;
    final lOther$questionTypeId = other.questionTypeId;
    if (_$data.containsKey('questionTypeId') !=
        other._$data.containsKey('questionTypeId')) {
      return false;
    }
    if (l$questionTypeId != lOther$questionTypeId) {
      return false;
    }
    final l$questionText = questionText;
    final lOther$questionText = other.questionText;
    if (_$data.containsKey('questionText') !=
        other._$data.containsKey('questionText')) {
      return false;
    }
    if (l$questionText != lOther$questionText) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isUserAnswerChoice = isUserAnswerChoice;
    final lOther$isUserAnswerChoice = other.isUserAnswerChoice;
    if (_$data.containsKey('isUserAnswerChoice') !=
        other._$data.containsKey('isUserAnswerChoice')) {
      return false;
    }
    if (l$isUserAnswerChoice != lOther$isUserAnswerChoice) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionTypeId = questionTypeId;
    final l$questionText = questionText;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$isUserAnswerChoice = isUserAnswerChoice;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionTypeId') ? l$questionTypeId : const {},
      _$data.containsKey('questionText') ? l$questionText : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isUserAnswerChoice')
          ? l$isUserAnswerChoice
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionInsertInput<TRes> {
  factory CopyWith$Input$QuestionInsertInput(
    Input$QuestionInsertInput instance,
    TRes Function(Input$QuestionInsertInput) then,
  ) = _CopyWithImpl$Input$QuestionInsertInput;

  factory CopyWith$Input$QuestionInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionInsertInput;

  TRes call({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  });
}

class _CopyWithImpl$Input$QuestionInsertInput<TRes>
    implements CopyWith$Input$QuestionInsertInput<TRes> {
  _CopyWithImpl$Input$QuestionInsertInput(
    this._instance,
    this._then,
  );

  final Input$QuestionInsertInput _instance;

  final TRes Function(Input$QuestionInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionTypeId = _undefined,
    Object? questionText = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? isUserAnswerChoice = _undefined,
  }) =>
      _then(Input$QuestionInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionTypeId != _undefined)
          'questionTypeId': (questionTypeId as String?),
        if (questionText != _undefined)
          'questionText': (questionText as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isUserAnswerChoice != _undefined)
          'isUserAnswerChoice': (isUserAnswerChoice as bool?),
      }));
}

class _CopyWithStubImpl$Input$QuestionInsertInput<TRes>
    implements CopyWith$Input$QuestionInsertInput<TRes> {
  _CopyWithStubImpl$Input$QuestionInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  }) =>
      _res;
}

class Input$QuestionOrderBy {
  factory Input$QuestionOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionTypeId,
    Enum$OrderByDirection? questionText,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isUserAnswerChoice,
  }) =>
      Input$QuestionOrderBy._({
        if (id != null) r'id': id,
        if (questionTypeId != null) r'questionTypeId': questionTypeId,
        if (questionText != null) r'questionText': questionText,
        if (createdAt != null) r'createdAt': createdAt,
        if (isUserAnswerChoice != null)
          r'isUserAnswerChoice': isUserAnswerChoice,
      });

  Input$QuestionOrderBy._(this._$data);

  factory Input$QuestionOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('questionTypeId')) {
      final l$questionTypeId = data['questionTypeId'];
      result$data['questionTypeId'] = l$questionTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionTypeId as String));
    }
    if (data.containsKey('questionText')) {
      final l$questionText = data['questionText'];
      result$data['questionText'] = l$questionText == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionText as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = data['isUserAnswerChoice'];
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isUserAnswerChoice as String));
    }
    return Input$QuestionOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionTypeId =>
      (_$data['questionTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionText =>
      (_$data['questionText'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isUserAnswerChoice =>
      (_$data['isUserAnswerChoice'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('questionTypeId')) {
      final l$questionTypeId = questionTypeId;
      result$data['questionTypeId'] = l$questionTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionTypeId);
    }
    if (_$data.containsKey('questionText')) {
      final l$questionText = questionText;
      result$data['questionText'] = l$questionText == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionText);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = isUserAnswerChoice;
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice == null
          ? null
          : toJson$Enum$OrderByDirection(l$isUserAnswerChoice);
    }
    return result$data;
  }

  CopyWith$Input$QuestionOrderBy<Input$QuestionOrderBy> get copyWith =>
      CopyWith$Input$QuestionOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionTypeId = questionTypeId;
    final lOther$questionTypeId = other.questionTypeId;
    if (_$data.containsKey('questionTypeId') !=
        other._$data.containsKey('questionTypeId')) {
      return false;
    }
    if (l$questionTypeId != lOther$questionTypeId) {
      return false;
    }
    final l$questionText = questionText;
    final lOther$questionText = other.questionText;
    if (_$data.containsKey('questionText') !=
        other._$data.containsKey('questionText')) {
      return false;
    }
    if (l$questionText != lOther$questionText) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isUserAnswerChoice = isUserAnswerChoice;
    final lOther$isUserAnswerChoice = other.isUserAnswerChoice;
    if (_$data.containsKey('isUserAnswerChoice') !=
        other._$data.containsKey('isUserAnswerChoice')) {
      return false;
    }
    if (l$isUserAnswerChoice != lOther$isUserAnswerChoice) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionTypeId = questionTypeId;
    final l$questionText = questionText;
    final l$createdAt = createdAt;
    final l$isUserAnswerChoice = isUserAnswerChoice;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionTypeId') ? l$questionTypeId : const {},
      _$data.containsKey('questionText') ? l$questionText : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isUserAnswerChoice')
          ? l$isUserAnswerChoice
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionOrderBy<TRes> {
  factory CopyWith$Input$QuestionOrderBy(
    Input$QuestionOrderBy instance,
    TRes Function(Input$QuestionOrderBy) then,
  ) = _CopyWithImpl$Input$QuestionOrderBy;

  factory CopyWith$Input$QuestionOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionTypeId,
    Enum$OrderByDirection? questionText,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isUserAnswerChoice,
  });
}

class _CopyWithImpl$Input$QuestionOrderBy<TRes>
    implements CopyWith$Input$QuestionOrderBy<TRes> {
  _CopyWithImpl$Input$QuestionOrderBy(
    this._instance,
    this._then,
  );

  final Input$QuestionOrderBy _instance;

  final TRes Function(Input$QuestionOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionTypeId = _undefined,
    Object? questionText = _undefined,
    Object? createdAt = _undefined,
    Object? isUserAnswerChoice = _undefined,
  }) =>
      _then(Input$QuestionOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (questionTypeId != _undefined)
          'questionTypeId': (questionTypeId as Enum$OrderByDirection?),
        if (questionText != _undefined)
          'questionText': (questionText as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (isUserAnswerChoice != _undefined)
          'isUserAnswerChoice': (isUserAnswerChoice as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$QuestionOrderBy<TRes>
    implements CopyWith$Input$QuestionOrderBy<TRes> {
  _CopyWithStubImpl$Input$QuestionOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? questionTypeId,
    Enum$OrderByDirection? questionText,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isUserAnswerChoice,
  }) =>
      _res;
}

class Input$QuestionTypeFilter {
  factory Input$QuestionTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionTypeFilter>? and,
    List<Input$QuestionTypeFilter>? or,
    Input$QuestionTypeFilter? not,
  }) =>
      Input$QuestionTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$QuestionTypeFilter._(this._$data);

  factory Input$QuestionTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$QuestionTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$QuestionTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$QuestionTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$QuestionTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$QuestionTypeFilter>? get and =>
      (_$data['and'] as List<Input$QuestionTypeFilter>?);

  List<Input$QuestionTypeFilter>? get or =>
      (_$data['or'] as List<Input$QuestionTypeFilter>?);

  Input$QuestionTypeFilter? get not =>
      (_$data['not'] as Input$QuestionTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QuestionTypeFilter<Input$QuestionTypeFilter> get copyWith =>
      CopyWith$Input$QuestionTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionTypeFilter<TRes> {
  factory CopyWith$Input$QuestionTypeFilter(
    Input$QuestionTypeFilter instance,
    TRes Function(Input$QuestionTypeFilter) then,
  ) = _CopyWithImpl$Input$QuestionTypeFilter;

  factory CopyWith$Input$QuestionTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionTypeFilter>? and,
    List<Input$QuestionTypeFilter>? or,
    Input$QuestionTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$QuestionTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$QuestionTypeFilter<Input$QuestionTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$QuestionTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$QuestionTypeFilter<Input$QuestionTypeFilter>>?)
          _fn);
  CopyWith$Input$QuestionTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$QuestionTypeFilter<TRes>
    implements CopyWith$Input$QuestionTypeFilter<TRes> {
  _CopyWithImpl$Input$QuestionTypeFilter(
    this._instance,
    this._then,
  );

  final Input$QuestionTypeFilter _instance;

  final TRes Function(Input$QuestionTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$QuestionTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$QuestionTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$QuestionTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$QuestionTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$QuestionTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionTypeFilter<
                          Input$QuestionTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$QuestionTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$QuestionTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$QuestionTypeFilter<
                          Input$QuestionTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$QuestionTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$QuestionTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$QuestionTypeFilter.stub(_then(_instance))
        : CopyWith$Input$QuestionTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$QuestionTypeFilter<TRes>
    implements CopyWith$Input$QuestionTypeFilter<TRes> {
  _CopyWithStubImpl$Input$QuestionTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$QuestionTypeFilter>? and,
    List<Input$QuestionTypeFilter>? or,
    Input$QuestionTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$QuestionTypeFilter<TRes> get not =>
      CopyWith$Input$QuestionTypeFilter.stub(_res);
}

class Input$QuestionTypeInsertInput {
  factory Input$QuestionTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$QuestionTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionTypeInsertInput._(this._$data);

  factory Input$QuestionTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$QuestionTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$QuestionTypeInsertInput<Input$QuestionTypeInsertInput>
      get copyWith => CopyWith$Input$QuestionTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionTypeInsertInput<TRes> {
  factory CopyWith$Input$QuestionTypeInsertInput(
    Input$QuestionTypeInsertInput instance,
    TRes Function(Input$QuestionTypeInsertInput) then,
  ) = _CopyWithImpl$Input$QuestionTypeInsertInput;

  factory CopyWith$Input$QuestionTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionTypeInsertInput<TRes>
    implements CopyWith$Input$QuestionTypeInsertInput<TRes> {
  _CopyWithImpl$Input$QuestionTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$QuestionTypeInsertInput _instance;

  final TRes Function(Input$QuestionTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$QuestionTypeInsertInput<TRes>
    implements CopyWith$Input$QuestionTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$QuestionTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$QuestionTypeOrderBy {
  factory Input$QuestionTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$QuestionTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionTypeOrderBy._(this._$data);

  factory Input$QuestionTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$QuestionTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$QuestionTypeOrderBy<Input$QuestionTypeOrderBy> get copyWith =>
      CopyWith$Input$QuestionTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionTypeOrderBy<TRes> {
  factory CopyWith$Input$QuestionTypeOrderBy(
    Input$QuestionTypeOrderBy instance,
    TRes Function(Input$QuestionTypeOrderBy) then,
  ) = _CopyWithImpl$Input$QuestionTypeOrderBy;

  factory CopyWith$Input$QuestionTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionTypeOrderBy<TRes>
    implements CopyWith$Input$QuestionTypeOrderBy<TRes> {
  _CopyWithImpl$Input$QuestionTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$QuestionTypeOrderBy _instance;

  final TRes Function(Input$QuestionTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$QuestionTypeOrderBy<TRes>
    implements CopyWith$Input$QuestionTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$QuestionTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$QuestionTypeUpdateInput {
  factory Input$QuestionTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$QuestionTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QuestionTypeUpdateInput._(this._$data);

  factory Input$QuestionTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$QuestionTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$QuestionTypeUpdateInput<Input$QuestionTypeUpdateInput>
      get copyWith => CopyWith$Input$QuestionTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionTypeUpdateInput<TRes> {
  factory CopyWith$Input$QuestionTypeUpdateInput(
    Input$QuestionTypeUpdateInput instance,
    TRes Function(Input$QuestionTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$QuestionTypeUpdateInput;

  factory CopyWith$Input$QuestionTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$QuestionTypeUpdateInput<TRes>
    implements CopyWith$Input$QuestionTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$QuestionTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$QuestionTypeUpdateInput _instance;

  final TRes Function(Input$QuestionTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QuestionTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$QuestionTypeUpdateInput<TRes>
    implements CopyWith$Input$QuestionTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$QuestionTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$QuestionUpdateInput {
  factory Input$QuestionUpdateInput({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  }) =>
      Input$QuestionUpdateInput._({
        if (id != null) r'id': id,
        if (questionTypeId != null) r'questionTypeId': questionTypeId,
        if (questionText != null) r'questionText': questionText,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (isUserAnswerChoice != null)
          r'isUserAnswerChoice': isUserAnswerChoice,
      });

  Input$QuestionUpdateInput._(this._$data);

  factory Input$QuestionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('questionTypeId')) {
      final l$questionTypeId = data['questionTypeId'];
      result$data['questionTypeId'] = (l$questionTypeId as String?);
    }
    if (data.containsKey('questionText')) {
      final l$questionText = data['questionText'];
      result$data['questionText'] = (l$questionText as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = data['isUserAnswerChoice'];
      result$data['isUserAnswerChoice'] = (l$isUserAnswerChoice as bool?);
    }
    return Input$QuestionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get questionTypeId => (_$data['questionTypeId'] as String?);

  String? get questionText => (_$data['questionText'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isUserAnswerChoice => (_$data['isUserAnswerChoice'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('questionTypeId')) {
      final l$questionTypeId = questionTypeId;
      result$data['questionTypeId'] = l$questionTypeId;
    }
    if (_$data.containsKey('questionText')) {
      final l$questionText = questionText;
      result$data['questionText'] = l$questionText;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isUserAnswerChoice')) {
      final l$isUserAnswerChoice = isUserAnswerChoice;
      result$data['isUserAnswerChoice'] = l$isUserAnswerChoice;
    }
    return result$data;
  }

  CopyWith$Input$QuestionUpdateInput<Input$QuestionUpdateInput> get copyWith =>
      CopyWith$Input$QuestionUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QuestionUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$questionTypeId = questionTypeId;
    final lOther$questionTypeId = other.questionTypeId;
    if (_$data.containsKey('questionTypeId') !=
        other._$data.containsKey('questionTypeId')) {
      return false;
    }
    if (l$questionTypeId != lOther$questionTypeId) {
      return false;
    }
    final l$questionText = questionText;
    final lOther$questionText = other.questionText;
    if (_$data.containsKey('questionText') !=
        other._$data.containsKey('questionText')) {
      return false;
    }
    if (l$questionText != lOther$questionText) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isUserAnswerChoice = isUserAnswerChoice;
    final lOther$isUserAnswerChoice = other.isUserAnswerChoice;
    if (_$data.containsKey('isUserAnswerChoice') !=
        other._$data.containsKey('isUserAnswerChoice')) {
      return false;
    }
    if (l$isUserAnswerChoice != lOther$isUserAnswerChoice) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$questionTypeId = questionTypeId;
    final l$questionText = questionText;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$isUserAnswerChoice = isUserAnswerChoice;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('questionTypeId') ? l$questionTypeId : const {},
      _$data.containsKey('questionText') ? l$questionText : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isUserAnswerChoice')
          ? l$isUserAnswerChoice
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QuestionUpdateInput<TRes> {
  factory CopyWith$Input$QuestionUpdateInput(
    Input$QuestionUpdateInput instance,
    TRes Function(Input$QuestionUpdateInput) then,
  ) = _CopyWithImpl$Input$QuestionUpdateInput;

  factory CopyWith$Input$QuestionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QuestionUpdateInput;

  TRes call({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  });
}

class _CopyWithImpl$Input$QuestionUpdateInput<TRes>
    implements CopyWith$Input$QuestionUpdateInput<TRes> {
  _CopyWithImpl$Input$QuestionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$QuestionUpdateInput _instance;

  final TRes Function(Input$QuestionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? questionTypeId = _undefined,
    Object? questionText = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? isUserAnswerChoice = _undefined,
  }) =>
      _then(Input$QuestionUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (questionTypeId != _undefined)
          'questionTypeId': (questionTypeId as String?),
        if (questionText != _undefined)
          'questionText': (questionText as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isUserAnswerChoice != _undefined)
          'isUserAnswerChoice': (isUserAnswerChoice as bool?),
      }));
}

class _CopyWithStubImpl$Input$QuestionUpdateInput<TRes>
    implements CopyWith$Input$QuestionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$QuestionUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? questionTypeId,
    String? questionText,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    bool? isUserAnswerChoice,
  }) =>
      _res;
}

class Input$RoleFilter {
  factory Input$RoleFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$RoleFilter>? and,
    List<Input$RoleFilter>? or,
    Input$RoleFilter? not,
  }) =>
      Input$RoleFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$RoleFilter._(this._$data);

  factory Input$RoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$RoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$RoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$RoleFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$RoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$RoleFilter>? get and => (_$data['and'] as List<Input$RoleFilter>?);

  List<Input$RoleFilter>? get or => (_$data['or'] as List<Input$RoleFilter>?);

  Input$RoleFilter? get not => (_$data['not'] as Input$RoleFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RoleFilter<Input$RoleFilter> get copyWith =>
      CopyWith$Input$RoleFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RoleFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoleFilter<TRes> {
  factory CopyWith$Input$RoleFilter(
    Input$RoleFilter instance,
    TRes Function(Input$RoleFilter) then,
  ) = _CopyWithImpl$Input$RoleFilter;

  factory CopyWith$Input$RoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$RoleFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$RoleFilter>? and,
    List<Input$RoleFilter>? or,
    Input$RoleFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$RoleFilter>? Function(
              Iterable<CopyWith$Input$RoleFilter<Input$RoleFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$RoleFilter>? Function(
              Iterable<CopyWith$Input$RoleFilter<Input$RoleFilter>>?)
          _fn);
  CopyWith$Input$RoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$RoleFilter<TRes>
    implements CopyWith$Input$RoleFilter<TRes> {
  _CopyWithImpl$Input$RoleFilter(
    this._instance,
    this._then,
  );

  final Input$RoleFilter _instance;

  final TRes Function(Input$RoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$RoleFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$RoleFilter>?),
        if (or != _undefined) 'or': (or as List<Input$RoleFilter>?),
        if (not != _undefined) 'not': (not as Input$RoleFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$RoleFilter>? Function(
                  Iterable<CopyWith$Input$RoleFilter<Input$RoleFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$RoleFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$RoleFilter>? Function(
                  Iterable<CopyWith$Input$RoleFilter<Input$RoleFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$RoleFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$RoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$RoleFilter.stub(_then(_instance))
        : CopyWith$Input$RoleFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$RoleFilter<TRes>
    implements CopyWith$Input$RoleFilter<TRes> {
  _CopyWithStubImpl$Input$RoleFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$IDFilter? nodeId,
    List<Input$RoleFilter>? and,
    List<Input$RoleFilter>? or,
    Input$RoleFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$RoleFilter<TRes> get not =>
      CopyWith$Input$RoleFilter.stub(_res);
}

class Input$RoleInsertInput {
  factory Input$RoleInsertInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  }) =>
      Input$RoleInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
      });

  Input$RoleInsertInput._(this._$data);

  factory Input$RoleInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    return Input$RoleInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    return result$data;
  }

  CopyWith$Input$RoleInsertInput<Input$RoleInsertInput> get copyWith =>
      CopyWith$Input$RoleInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RoleInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoleInsertInput<TRes> {
  factory CopyWith$Input$RoleInsertInput(
    Input$RoleInsertInput instance,
    TRes Function(Input$RoleInsertInput) then,
  ) = _CopyWithImpl$Input$RoleInsertInput;

  factory CopyWith$Input$RoleInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoleInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  });
}

class _CopyWithImpl$Input$RoleInsertInput<TRes>
    implements CopyWith$Input$RoleInsertInput<TRes> {
  _CopyWithImpl$Input$RoleInsertInput(
    this._instance,
    this._then,
  );

  final Input$RoleInsertInput _instance;

  final TRes Function(Input$RoleInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
  }) =>
      _then(Input$RoleInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$RoleInsertInput<TRes>
    implements CopyWith$Input$RoleInsertInput<TRes> {
  _CopyWithStubImpl$Input$RoleInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  }) =>
      _res;
}

class Input$RoleOrderBy {
  factory Input$RoleOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  }) =>
      Input$RoleOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
      });

  Input$RoleOrderBy._(this._$data);

  factory Input$RoleOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    return Input$RoleOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    return result$data;
  }

  CopyWith$Input$RoleOrderBy<Input$RoleOrderBy> get copyWith =>
      CopyWith$Input$RoleOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RoleOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoleOrderBy<TRes> {
  factory CopyWith$Input$RoleOrderBy(
    Input$RoleOrderBy instance,
    TRes Function(Input$RoleOrderBy) then,
  ) = _CopyWithImpl$Input$RoleOrderBy;

  factory CopyWith$Input$RoleOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$RoleOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  });
}

class _CopyWithImpl$Input$RoleOrderBy<TRes>
    implements CopyWith$Input$RoleOrderBy<TRes> {
  _CopyWithImpl$Input$RoleOrderBy(
    this._instance,
    this._then,
  );

  final Input$RoleOrderBy _instance;

  final TRes Function(Input$RoleOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
  }) =>
      _then(Input$RoleOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$RoleOrderBy<TRes>
    implements CopyWith$Input$RoleOrderBy<TRes> {
  _CopyWithStubImpl$Input$RoleOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
  }) =>
      _res;
}

class Input$RoleUpdateInput {
  factory Input$RoleUpdateInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  }) =>
      Input$RoleUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
      });

  Input$RoleUpdateInput._(this._$data);

  factory Input$RoleUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    return Input$RoleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    return result$data;
  }

  CopyWith$Input$RoleUpdateInput<Input$RoleUpdateInput> get copyWith =>
      CopyWith$Input$RoleUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RoleUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoleUpdateInput<TRes> {
  factory CopyWith$Input$RoleUpdateInput(
    Input$RoleUpdateInput instance,
    TRes Function(Input$RoleUpdateInput) then,
  ) = _CopyWithImpl$Input$RoleUpdateInput;

  factory CopyWith$Input$RoleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoleUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  });
}

class _CopyWithImpl$Input$RoleUpdateInput<TRes>
    implements CopyWith$Input$RoleUpdateInput<TRes> {
  _CopyWithImpl$Input$RoleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$RoleUpdateInput _instance;

  final TRes Function(Input$RoleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
  }) =>
      _then(Input$RoleUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$RoleUpdateInput<TRes>
    implements CopyWith$Input$RoleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$RoleUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
  }) =>
      _res;
}

class Input$StringFilter {
  factory Input$StringFilter({
    String? eq,
    String? gt,
    String? gte,
    String? ilike,
    List<String>? $in,
    String? iregex,
    Enum$FilterIs? $is,
    String? like,
    String? lt,
    String? lte,
    String? neq,
    String? regex,
    String? startsWith,
  }) =>
      Input$StringFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (ilike != null) r'ilike': ilike,
        if ($in != null) r'in': $in,
        if (iregex != null) r'iregex': iregex,
        if ($is != null) r'is': $is,
        if (like != null) r'like': like,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (regex != null) r'regex': regex,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringFilter._(this._$data);

  factory Input$StringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('ilike')) {
      final l$ilike = data['ilike'];
      result$data['ilike'] = (l$ilike as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('iregex')) {
      final l$iregex = data['iregex'];
      result$data['iregex'] = (l$iregex as String?);
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('like')) {
      final l$like = data['like'];
      result$data['like'] = (l$like as String?);
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('regex')) {
      final l$regex = data['regex'];
      result$data['regex'] = (l$regex as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  String? get ilike => (_$data['ilike'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get iregex => (_$data['iregex'] as String?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  String? get like => (_$data['like'] as String?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  String? get neq => (_$data['neq'] as String?);

  String? get regex => (_$data['regex'] as String?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ilike')) {
      final l$ilike = ilike;
      result$data['ilike'] = l$ilike;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('iregex')) {
      final l$iregex = iregex;
      result$data['iregex'] = l$iregex;
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('like')) {
      final l$like = like;
      result$data['like'] = l$like;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('regex')) {
      final l$regex = regex;
      result$data['regex'] = l$regex;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringFilter<Input$StringFilter> get copyWith =>
      CopyWith$Input$StringFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ilike = ilike;
    final lOther$ilike = other.ilike;
    if (_$data.containsKey('ilike') != other._$data.containsKey('ilike')) {
      return false;
    }
    if (l$ilike != lOther$ilike) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$iregex = iregex;
    final lOther$iregex = other.iregex;
    if (_$data.containsKey('iregex') != other._$data.containsKey('iregex')) {
      return false;
    }
    if (l$iregex != lOther$iregex) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$like = like;
    final lOther$like = other.like;
    if (_$data.containsKey('like') != other._$data.containsKey('like')) {
      return false;
    }
    if (l$like != lOther$like) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$regex = regex;
    final lOther$regex = other.regex;
    if (_$data.containsKey('regex') != other._$data.containsKey('regex')) {
      return false;
    }
    if (l$regex != lOther$regex) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$ilike = ilike;
    final l$$in = $in;
    final l$iregex = iregex;
    final l$$is = $is;
    final l$like = like;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$regex = regex;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ilike') ? l$ilike : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('iregex') ? l$iregex : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('like') ? l$like : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('regex') ? l$regex : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilter<TRes> {
  factory CopyWith$Input$StringFilter(
    Input$StringFilter instance,
    TRes Function(Input$StringFilter) then,
  ) = _CopyWithImpl$Input$StringFilter;

  factory CopyWith$Input$StringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilter;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    String? ilike,
    List<String>? $in,
    String? iregex,
    Enum$FilterIs? $is,
    String? like,
    String? lt,
    String? lte,
    String? neq,
    String? regex,
    String? startsWith,
  });
}

class _CopyWithImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithImpl$Input$StringFilter(
    this._instance,
    this._then,
  );

  final Input$StringFilter _instance;

  final TRes Function(Input$StringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? ilike = _undefined,
    Object? $in = _undefined,
    Object? iregex = _undefined,
    Object? $is = _undefined,
    Object? like = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? regex = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (ilike != _undefined) 'ilike': (ilike as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (iregex != _undefined) 'iregex': (iregex as String?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (like != _undefined) 'like': (like as String?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (regex != _undefined) 'regex': (regex as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));
}

class _CopyWithStubImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithStubImpl$Input$StringFilter(this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    String? ilike,
    List<String>? $in,
    String? iregex,
    Enum$FilterIs? $is,
    String? like,
    String? lt,
    String? lte,
    String? neq,
    String? regex,
    String? startsWith,
  }) =>
      _res;
}

class Input$SurveyFilter {
  factory Input$SurveyFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyFilter>? and,
    List<Input$SurveyFilter>? or,
    Input$SurveyFilter? not,
  }) =>
      Input$SurveyFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$SurveyFilter._(this._$data);

  factory Input$SurveyFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$SurveyFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$SurveyFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$SurveyFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$SurveyFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$SurveyFilter>? get and =>
      (_$data['and'] as List<Input$SurveyFilter>?);

  List<Input$SurveyFilter>? get or =>
      (_$data['or'] as List<Input$SurveyFilter>?);

  Input$SurveyFilter? get not => (_$data['not'] as Input$SurveyFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SurveyFilter<Input$SurveyFilter> get copyWith =>
      CopyWith$Input$SurveyFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyFilter<TRes> {
  factory CopyWith$Input$SurveyFilter(
    Input$SurveyFilter instance,
    TRes Function(Input$SurveyFilter) then,
  ) = _CopyWithImpl$Input$SurveyFilter;

  factory CopyWith$Input$SurveyFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyFilter>? and,
    List<Input$SurveyFilter>? or,
    Input$SurveyFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$SurveyFilter>? Function(
              Iterable<CopyWith$Input$SurveyFilter<Input$SurveyFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$SurveyFilter>? Function(
              Iterable<CopyWith$Input$SurveyFilter<Input$SurveyFilter>>?)
          _fn);
  CopyWith$Input$SurveyFilter<TRes> get not;
}

class _CopyWithImpl$Input$SurveyFilter<TRes>
    implements CopyWith$Input$SurveyFilter<TRes> {
  _CopyWithImpl$Input$SurveyFilter(
    this._instance,
    this._then,
  );

  final Input$SurveyFilter _instance;

  final TRes Function(Input$SurveyFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$SurveyFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$SurveyFilter>?),
        if (or != _undefined) 'or': (or as List<Input$SurveyFilter>?),
        if (not != _undefined) 'not': (not as Input$SurveyFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$SurveyFilter>? Function(
                  Iterable<CopyWith$Input$SurveyFilter<Input$SurveyFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$SurveyFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$SurveyFilter>? Function(
                  Iterable<CopyWith$Input$SurveyFilter<Input$SurveyFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$SurveyFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$SurveyFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$SurveyFilter.stub(_then(_instance))
        : CopyWith$Input$SurveyFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$SurveyFilter<TRes>
    implements CopyWith$Input$SurveyFilter<TRes> {
  _CopyWithStubImpl$Input$SurveyFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyFilter>? and,
    List<Input$SurveyFilter>? or,
    Input$SurveyFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$SurveyFilter<TRes> get not =>
      CopyWith$Input$SurveyFilter.stub(_res);
}

class Input$SurveyInsertInput {
  factory Input$SurveyInsertInput({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$SurveyInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyInsertInput._(this._$data);

  factory Input$SurveyInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$SurveyInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$SurveyInsertInput<Input$SurveyInsertInput> get copyWith =>
      CopyWith$Input$SurveyInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyInsertInput<TRes> {
  factory CopyWith$Input$SurveyInsertInput(
    Input$SurveyInsertInput instance,
    TRes Function(Input$SurveyInsertInput) then,
  ) = _CopyWithImpl$Input$SurveyInsertInput;

  factory CopyWith$Input$SurveyInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyInsertInput;

  TRes call({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyInsertInput<TRes>
    implements CopyWith$Input$SurveyInsertInput<TRes> {
  _CopyWithImpl$Input$SurveyInsertInput(
    this._instance,
    this._then,
  );

  final Input$SurveyInsertInput _instance;

  final TRes Function(Input$SurveyInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$SurveyInsertInput<TRes>
    implements CopyWith$Input$SurveyInsertInput<TRes> {
  _CopyWithStubImpl$Input$SurveyInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$SurveyOrderBy {
  factory Input$SurveyOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$SurveyOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyOrderBy._(this._$data);

  factory Input$SurveyOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$SurveyOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$SurveyOrderBy<Input$SurveyOrderBy> get copyWith =>
      CopyWith$Input$SurveyOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$key = key;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyOrderBy<TRes> {
  factory CopyWith$Input$SurveyOrderBy(
    Input$SurveyOrderBy instance,
    TRes Function(Input$SurveyOrderBy) then,
  ) = _CopyWithImpl$Input$SurveyOrderBy;

  factory CopyWith$Input$SurveyOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyOrderBy<TRes>
    implements CopyWith$Input$SurveyOrderBy<TRes> {
  _CopyWithImpl$Input$SurveyOrderBy(
    this._instance,
    this._then,
  );

  final Input$SurveyOrderBy _instance;

  final TRes Function(Input$SurveyOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$SurveyOrderBy<TRes>
    implements CopyWith$Input$SurveyOrderBy<TRes> {
  _CopyWithStubImpl$Input$SurveyOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$SurveyQuestionFilter {
  factory Input$SurveyQuestionFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyQuestionFilter>? and,
    List<Input$SurveyQuestionFilter>? or,
    Input$SurveyQuestionFilter? not,
  }) =>
      Input$SurveyQuestionFilter._({
        if (id != null) r'id': id,
        if (surveyId != null) r'surveyId': surveyId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$SurveyQuestionFilter._(this._$data);

  factory Input$SurveyQuestionFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$surveyId as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntFilter.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isRequired as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$SurveyQuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$SurveyQuestionFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$SurveyQuestionFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$SurveyQuestionFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get surveyId => (_$data['surveyId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$IntFilter? get index => (_$data['index'] as Input$IntFilter?);

  Input$BooleanFilter? get isRequired =>
      (_$data['isRequired'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$SurveyQuestionFilter>? get and =>
      (_$data['and'] as List<Input$SurveyQuestionFilter>?);

  List<Input$SurveyQuestionFilter>? get or =>
      (_$data['or'] as List<Input$SurveyQuestionFilter>?);

  Input$SurveyQuestionFilter? get not =>
      (_$data['not'] as Input$SurveyQuestionFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SurveyQuestionFilter<Input$SurveyQuestionFilter>
      get copyWith => CopyWith$Input$SurveyQuestionFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyQuestionFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$surveyId = surveyId;
    final l$questionId = questionId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyQuestionFilter<TRes> {
  factory CopyWith$Input$SurveyQuestionFilter(
    Input$SurveyQuestionFilter instance,
    TRes Function(Input$SurveyQuestionFilter) then,
  ) = _CopyWithImpl$Input$SurveyQuestionFilter;

  factory CopyWith$Input$SurveyQuestionFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyQuestionFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyQuestionFilter>? and,
    List<Input$SurveyQuestionFilter>? or,
    Input$SurveyQuestionFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get surveyId;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$IntFilter<TRes> get index;
  CopyWith$Input$BooleanFilter<TRes> get isRequired;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$SurveyQuestionFilter>? Function(
              Iterable<
                  CopyWith$Input$SurveyQuestionFilter<
                      Input$SurveyQuestionFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$SurveyQuestionFilter>? Function(
              Iterable<
                  CopyWith$Input$SurveyQuestionFilter<
                      Input$SurveyQuestionFilter>>?)
          _fn);
  CopyWith$Input$SurveyQuestionFilter<TRes> get not;
}

class _CopyWithImpl$Input$SurveyQuestionFilter<TRes>
    implements CopyWith$Input$SurveyQuestionFilter<TRes> {
  _CopyWithImpl$Input$SurveyQuestionFilter(
    this._instance,
    this._then,
  );

  final Input$SurveyQuestionFilter _instance;

  final TRes Function(Input$SurveyQuestionFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? surveyId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$SurveyQuestionFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (surveyId != _undefined) 'surveyId': (surveyId as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (index != _undefined) 'index': (index as Input$IntFilter?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Input$BooleanFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$SurveyQuestionFilter>?),
        if (or != _undefined) 'or': (or as List<Input$SurveyQuestionFilter>?),
        if (not != _undefined) 'not': (not as Input$SurveyQuestionFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get surveyId {
    final local$surveyId = _instance.surveyId;
    return local$surveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$surveyId, (e) => call(surveyId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$IntFilter<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$index, (e) => call(index: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isRequired {
    final local$isRequired = _instance.isRequired;
    return local$isRequired == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isRequired, (e) => call(isRequired: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$SurveyQuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$SurveyQuestionFilter<
                          Input$SurveyQuestionFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$SurveyQuestionFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$SurveyQuestionFilter>? Function(
                  Iterable<
                      CopyWith$Input$SurveyQuestionFilter<
                          Input$SurveyQuestionFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$SurveyQuestionFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$SurveyQuestionFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$SurveyQuestionFilter.stub(_then(_instance))
        : CopyWith$Input$SurveyQuestionFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$SurveyQuestionFilter<TRes>
    implements CopyWith$Input$SurveyQuestionFilter<TRes> {
  _CopyWithStubImpl$Input$SurveyQuestionFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? surveyId,
    Input$UUIDFilter? questionId,
    Input$IntFilter? index,
    Input$BooleanFilter? isRequired,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$SurveyQuestionFilter>? and,
    List<Input$SurveyQuestionFilter>? or,
    Input$SurveyQuestionFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get surveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IntFilter<TRes> get index =>
      CopyWith$Input$IntFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isRequired =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$SurveyQuestionFilter<TRes> get not =>
      CopyWith$Input$SurveyQuestionFilter.stub(_res);
}

class Input$SurveyQuestionInsertInput {
  factory Input$SurveyQuestionInsertInput({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      Input$SurveyQuestionInsertInput._({
        if (id != null) r'id': id,
        if (surveyId != null) r'surveyId': surveyId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyQuestionInsertInput._(this._$data);

  factory Input$SurveyQuestionInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$SurveyQuestionInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$SurveyQuestionInsertInput<Input$SurveyQuestionInsertInput>
      get copyWith => CopyWith$Input$SurveyQuestionInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyQuestionInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$surveyId = surveyId;
    final l$questionId = questionId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyQuestionInsertInput<TRes> {
  factory CopyWith$Input$SurveyQuestionInsertInput(
    Input$SurveyQuestionInsertInput instance,
    TRes Function(Input$SurveyQuestionInsertInput) then,
  ) = _CopyWithImpl$Input$SurveyQuestionInsertInput;

  factory CopyWith$Input$SurveyQuestionInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyQuestionInsertInput;

  TRes call({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyQuestionInsertInput<TRes>
    implements CopyWith$Input$SurveyQuestionInsertInput<TRes> {
  _CopyWithImpl$Input$SurveyQuestionInsertInput(
    this._instance,
    this._then,
  );

  final Input$SurveyQuestionInsertInput _instance;

  final TRes Function(Input$SurveyQuestionInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? surveyId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyQuestionInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$SurveyQuestionInsertInput<TRes>
    implements CopyWith$Input$SurveyQuestionInsertInput<TRes> {
  _CopyWithStubImpl$Input$SurveyQuestionInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$SurveyQuestionOrderBy {
  factory Input$SurveyQuestionOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$SurveyQuestionOrderBy._({
        if (id != null) r'id': id,
        if (surveyId != null) r'surveyId': surveyId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyQuestionOrderBy._(this._$data);

  factory Input$SurveyQuestionOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$surveyId as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : fromJson$Enum$OrderByDirection((l$index as String));
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = l$isRequired == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isRequired as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$SurveyQuestionOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get surveyId =>
      (_$data['surveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get index =>
      (_$data['index'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isRequired =>
      (_$data['isRequired'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] =
          l$surveyId == null ? null : toJson$Enum$OrderByDirection(l$surveyId);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderByDirection(l$index);
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired == null
          ? null
          : toJson$Enum$OrderByDirection(l$isRequired);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$SurveyQuestionOrderBy<Input$SurveyQuestionOrderBy>
      get copyWith => CopyWith$Input$SurveyQuestionOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyQuestionOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$surveyId = surveyId;
    final l$questionId = questionId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyQuestionOrderBy<TRes> {
  factory CopyWith$Input$SurveyQuestionOrderBy(
    Input$SurveyQuestionOrderBy instance,
    TRes Function(Input$SurveyQuestionOrderBy) then,
  ) = _CopyWithImpl$Input$SurveyQuestionOrderBy;

  factory CopyWith$Input$SurveyQuestionOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyQuestionOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyQuestionOrderBy<TRes>
    implements CopyWith$Input$SurveyQuestionOrderBy<TRes> {
  _CopyWithImpl$Input$SurveyQuestionOrderBy(
    this._instance,
    this._then,
  );

  final Input$SurveyQuestionOrderBy _instance;

  final TRes Function(Input$SurveyQuestionOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? surveyId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyQuestionOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (surveyId != _undefined)
          'surveyId': (surveyId as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (index != _undefined) 'index': (index as Enum$OrderByDirection?),
        if (isRequired != _undefined)
          'isRequired': (isRequired as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$SurveyQuestionOrderBy<TRes>
    implements CopyWith$Input$SurveyQuestionOrderBy<TRes> {
  _CopyWithStubImpl$Input$SurveyQuestionOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? index,
    Enum$OrderByDirection? isRequired,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$SurveyQuestionUpdateInput {
  factory Input$SurveyQuestionUpdateInput({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      Input$SurveyQuestionUpdateInput._({
        if (id != null) r'id': id,
        if (surveyId != null) r'surveyId': surveyId,
        if (questionId != null) r'questionId': questionId,
        if (index != null) r'index': index,
        if (isRequired != null) r'isRequired': isRequired,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyQuestionUpdateInput._(this._$data);

  factory Input$SurveyQuestionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = (l$index as int?);
    }
    if (data.containsKey('isRequired')) {
      final l$isRequired = data['isRequired'];
      result$data['isRequired'] = (l$isRequired as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$SurveyQuestionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  int? get index => (_$data['index'] as int?);

  bool? get isRequired => (_$data['isRequired'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index;
    }
    if (_$data.containsKey('isRequired')) {
      final l$isRequired = isRequired;
      result$data['isRequired'] = l$isRequired;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$SurveyQuestionUpdateInput<Input$SurveyQuestionUpdateInput>
      get copyWith => CopyWith$Input$SurveyQuestionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyQuestionUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isRequired = isRequired;
    final lOther$isRequired = other.isRequired;
    if (_$data.containsKey('isRequired') !=
        other._$data.containsKey('isRequired')) {
      return false;
    }
    if (l$isRequired != lOther$isRequired) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$surveyId = surveyId;
    final l$questionId = questionId;
    final l$index = index;
    final l$isRequired = isRequired;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isRequired') ? l$isRequired : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyQuestionUpdateInput<TRes> {
  factory CopyWith$Input$SurveyQuestionUpdateInput(
    Input$SurveyQuestionUpdateInput instance,
    TRes Function(Input$SurveyQuestionUpdateInput) then,
  ) = _CopyWithImpl$Input$SurveyQuestionUpdateInput;

  factory CopyWith$Input$SurveyQuestionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyQuestionUpdateInput;

  TRes call({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyQuestionUpdateInput<TRes>
    implements CopyWith$Input$SurveyQuestionUpdateInput<TRes> {
  _CopyWithImpl$Input$SurveyQuestionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SurveyQuestionUpdateInput _instance;

  final TRes Function(Input$SurveyQuestionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? surveyId = _undefined,
    Object? questionId = _undefined,
    Object? index = _undefined,
    Object? isRequired = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyQuestionUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (index != _undefined) 'index': (index as int?),
        if (isRequired != _undefined) 'isRequired': (isRequired as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$SurveyQuestionUpdateInput<TRes>
    implements CopyWith$Input$SurveyQuestionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SurveyQuestionUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? surveyId,
    String? questionId,
    int? index,
    bool? isRequired,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$SurveyUpdateInput {
  factory Input$SurveyUpdateInput({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      Input$SurveyUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$SurveyUpdateInput._(this._$data);

  factory Input$SurveyUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$SurveyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$SurveyUpdateInput<Input$SurveyUpdateInput> get copyWith =>
      CopyWith$Input$SurveyUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SurveyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SurveyUpdateInput<TRes> {
  factory CopyWith$Input$SurveyUpdateInput(
    Input$SurveyUpdateInput instance,
    TRes Function(Input$SurveyUpdateInput) then,
  ) = _CopyWithImpl$Input$SurveyUpdateInput;

  factory CopyWith$Input$SurveyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SurveyUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$SurveyUpdateInput<TRes>
    implements CopyWith$Input$SurveyUpdateInput<TRes> {
  _CopyWithImpl$Input$SurveyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SurveyUpdateInput _instance;

  final TRes Function(Input$SurveyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$SurveyUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$SurveyUpdateInput<TRes>
    implements CopyWith$Input$SurveyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SurveyUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? description,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$TemplateVariableFilter {
  factory Input$TemplateVariableFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? stringValue,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? templateVariableTypeId,
    Input$StringFilter? usage,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableFilter>? and,
    List<Input$TemplateVariableFilter>? or,
    Input$TemplateVariableFilter? not,
  }) =>
      Input$TemplateVariableFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (stringValue != null) r'stringValue': stringValue,
        if (createdAt != null) r'createdAt': createdAt,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (usage != null) r'usage': usage,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$TemplateVariableFilter._(this._$data);

  factory Input$TemplateVariableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = l$stringValue == null
          ? null
          : Input$StringFilter.fromJson(
              (l$stringValue as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$templateVariableTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('usage')) {
      final l$usage = data['usage'];
      result$data['usage'] = l$usage == null
          ? null
          : Input$StringFilter.fromJson((l$usage as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TemplateVariableFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$TemplateVariableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$TemplateVariableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get stringValue =>
      (_$data['stringValue'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get usage => (_$data['usage'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$TemplateVariableFilter>? get and =>
      (_$data['and'] as List<Input$TemplateVariableFilter>?);

  List<Input$TemplateVariableFilter>? get or =>
      (_$data['or'] as List<Input$TemplateVariableFilter>?);

  Input$TemplateVariableFilter? get not =>
      (_$data['not'] as Input$TemplateVariableFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] =
          l$templateVariableTypeId?.toJson();
    }
    if (_$data.containsKey('usage')) {
      final l$usage = usage;
      result$data['usage'] = l$usage?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableFilter<Input$TemplateVariableFilter>
      get copyWith => CopyWith$Input$TemplateVariableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$usage = usage;
    final lOther$usage = other.usage;
    if (_$data.containsKey('usage') != other._$data.containsKey('usage')) {
      return false;
    }
    if (l$usage != lOther$usage) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$stringValue = stringValue;
    final l$createdAt = createdAt;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$usage = usage;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('usage') ? l$usage : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableFilter<TRes> {
  factory CopyWith$Input$TemplateVariableFilter(
    Input$TemplateVariableFilter instance,
    TRes Function(Input$TemplateVariableFilter) then,
  ) = _CopyWithImpl$Input$TemplateVariableFilter;

  factory CopyWith$Input$TemplateVariableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? stringValue,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? templateVariableTypeId,
    Input$StringFilter? usage,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableFilter>? and,
    List<Input$TemplateVariableFilter>? or,
    Input$TemplateVariableFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get stringValue;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId;
  CopyWith$Input$StringFilter<TRes> get usage;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$TemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$TemplateVariableFilter<
                      Input$TemplateVariableFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$TemplateVariableFilter>? Function(
              Iterable<
                  CopyWith$Input$TemplateVariableFilter<
                      Input$TemplateVariableFilter>>?)
          _fn);
  CopyWith$Input$TemplateVariableFilter<TRes> get not;
}

class _CopyWithImpl$Input$TemplateVariableFilter<TRes>
    implements CopyWith$Input$TemplateVariableFilter<TRes> {
  _CopyWithImpl$Input$TemplateVariableFilter(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableFilter _instance;

  final TRes Function(Input$TemplateVariableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? stringValue = _undefined,
    Object? createdAt = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? usage = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$TemplateVariableFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (stringValue != _undefined)
          'stringValue': (stringValue as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId':
              (templateVariableTypeId as Input$UUIDFilter?),
        if (usage != _undefined) 'usage': (usage as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$TemplateVariableFilter>?),
        if (or != _undefined) 'or': (or as List<Input$TemplateVariableFilter>?),
        if (not != _undefined) 'not': (not as Input$TemplateVariableFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get stringValue {
    final local$stringValue = _instance.stringValue;
    return local$stringValue == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$stringValue, (e) => call(stringValue: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId {
    final local$templateVariableTypeId = _instance.templateVariableTypeId;
    return local$templateVariableTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$templateVariableTypeId,
            (e) => call(templateVariableTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get usage {
    final local$usage = _instance.usage;
    return local$usage == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$usage, (e) => call(usage: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$TemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$TemplateVariableFilter<
                          Input$TemplateVariableFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$TemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$TemplateVariableFilter>? Function(
                  Iterable<
                      CopyWith$Input$TemplateVariableFilter<
                          Input$TemplateVariableFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$TemplateVariableFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$TemplateVariableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$TemplateVariableFilter.stub(_then(_instance))
        : CopyWith$Input$TemplateVariableFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$TemplateVariableFilter<TRes>
    implements CopyWith$Input$TemplateVariableFilter<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? stringValue,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? templateVariableTypeId,
    Input$StringFilter? usage,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableFilter>? and,
    List<Input$TemplateVariableFilter>? or,
    Input$TemplateVariableFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get stringValue =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get templateVariableTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get usage =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$TemplateVariableFilter<TRes> get not =>
      CopyWith$Input$TemplateVariableFilter.stub(_res);
}

class Input$TemplateVariableInsertInput {
  factory Input$TemplateVariableInsertInput({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  }) =>
      Input$TemplateVariableInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (stringValue != null) r'stringValue': stringValue,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (usage != null) r'usage': usage,
      });

  Input$TemplateVariableInsertInput._(this._$data);

  factory Input$TemplateVariableInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = (l$stringValue as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] =
          (l$templateVariableTypeId as String?);
    }
    if (data.containsKey('usage')) {
      final l$usage = data['usage'];
      result$data['usage'] = (l$usage as String?);
    }
    return Input$TemplateVariableInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get stringValue => (_$data['stringValue'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as String?);

  String? get usage => (_$data['usage'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId;
    }
    if (_$data.containsKey('usage')) {
      final l$usage = usage;
      result$data['usage'] = l$usage;
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableInsertInput<Input$TemplateVariableInsertInput>
      get copyWith => CopyWith$Input$TemplateVariableInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$usage = usage;
    final lOther$usage = other.usage;
    if (_$data.containsKey('usage') != other._$data.containsKey('usage')) {
      return false;
    }
    if (l$usage != lOther$usage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$stringValue = stringValue;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$usage = usage;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('usage') ? l$usage : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableInsertInput<TRes> {
  factory CopyWith$Input$TemplateVariableInsertInput(
    Input$TemplateVariableInsertInput instance,
    TRes Function(Input$TemplateVariableInsertInput) then,
  ) = _CopyWithImpl$Input$TemplateVariableInsertInput;

  factory CopyWith$Input$TemplateVariableInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  });
}

class _CopyWithImpl$Input$TemplateVariableInsertInput<TRes>
    implements CopyWith$Input$TemplateVariableInsertInput<TRes> {
  _CopyWithImpl$Input$TemplateVariableInsertInput(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableInsertInput _instance;

  final TRes Function(Input$TemplateVariableInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? stringValue = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? usage = _undefined,
  }) =>
      _then(Input$TemplateVariableInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (stringValue != _undefined) 'stringValue': (stringValue as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId': (templateVariableTypeId as String?),
        if (usage != _undefined) 'usage': (usage as String?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableInsertInput<TRes>
    implements CopyWith$Input$TemplateVariableInsertInput<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  }) =>
      _res;
}

class Input$TemplateVariableOrderBy {
  factory Input$TemplateVariableOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? stringValue,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? usage,
  }) =>
      Input$TemplateVariableOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (stringValue != null) r'stringValue': stringValue,
        if (createdAt != null) r'createdAt': createdAt,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (usage != null) r'usage': usage,
      });

  Input$TemplateVariableOrderBy._(this._$data);

  factory Input$TemplateVariableOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = l$stringValue == null
          ? null
          : fromJson$Enum$OrderByDirection((l$stringValue as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$templateVariableTypeId as String));
    }
    if (data.containsKey('usage')) {
      final l$usage = data['usage'];
      result$data['usage'] = l$usage == null
          ? null
          : fromJson$Enum$OrderByDirection((l$usage as String));
    }
    return Input$TemplateVariableOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get stringValue =>
      (_$data['stringValue'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get usage =>
      (_$data['usage'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue == null
          ? null
          : toJson$Enum$OrderByDirection(l$stringValue);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$templateVariableTypeId);
    }
    if (_$data.containsKey('usage')) {
      final l$usage = usage;
      result$data['usage'] =
          l$usage == null ? null : toJson$Enum$OrderByDirection(l$usage);
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableOrderBy<Input$TemplateVariableOrderBy>
      get copyWith => CopyWith$Input$TemplateVariableOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$usage = usage;
    final lOther$usage = other.usage;
    if (_$data.containsKey('usage') != other._$data.containsKey('usage')) {
      return false;
    }
    if (l$usage != lOther$usage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$stringValue = stringValue;
    final l$createdAt = createdAt;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$usage = usage;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('usage') ? l$usage : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableOrderBy<TRes> {
  factory CopyWith$Input$TemplateVariableOrderBy(
    Input$TemplateVariableOrderBy instance,
    TRes Function(Input$TemplateVariableOrderBy) then,
  ) = _CopyWithImpl$Input$TemplateVariableOrderBy;

  factory CopyWith$Input$TemplateVariableOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? stringValue,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? usage,
  });
}

class _CopyWithImpl$Input$TemplateVariableOrderBy<TRes>
    implements CopyWith$Input$TemplateVariableOrderBy<TRes> {
  _CopyWithImpl$Input$TemplateVariableOrderBy(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableOrderBy _instance;

  final TRes Function(Input$TemplateVariableOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? stringValue = _undefined,
    Object? createdAt = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? usage = _undefined,
  }) =>
      _then(Input$TemplateVariableOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (stringValue != _undefined)
          'stringValue': (stringValue as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId':
              (templateVariableTypeId as Enum$OrderByDirection?),
        if (usage != _undefined) 'usage': (usage as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableOrderBy<TRes>
    implements CopyWith$Input$TemplateVariableOrderBy<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? stringValue,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? templateVariableTypeId,
    Enum$OrderByDirection? usage,
  }) =>
      _res;
}

class Input$TemplateVariableTypeFilter {
  factory Input$TemplateVariableTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$BooleanFilter? isPrimitive,
    Input$BooleanFilter? isString,
    Input$BooleanFilter? isNumeric,
    Input$BooleanFilter? isDate,
    Input$BooleanFilter? isBool,
    Input$BooleanFilter? isObject,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableTypeFilter>? and,
    List<Input$TemplateVariableTypeFilter>? or,
    Input$TemplateVariableTypeFilter? not,
  }) =>
      Input$TemplateVariableTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (isPrimitive != null) r'isPrimitive': isPrimitive,
        if (isString != null) r'isString': isString,
        if (isNumeric != null) r'isNumeric': isNumeric,
        if (isDate != null) r'isDate': isDate,
        if (isBool != null) r'isBool': isBool,
        if (isObject != null) r'isObject': isObject,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$TemplateVariableTypeFilter._(this._$data);

  factory Input$TemplateVariableTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('isPrimitive')) {
      final l$isPrimitive = data['isPrimitive'];
      result$data['isPrimitive'] = l$isPrimitive == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isPrimitive as Map<String, dynamic>));
    }
    if (data.containsKey('isString')) {
      final l$isString = data['isString'];
      result$data['isString'] = l$isString == null
          ? null
          : Input$BooleanFilter.fromJson((l$isString as Map<String, dynamic>));
    }
    if (data.containsKey('isNumeric')) {
      final l$isNumeric = data['isNumeric'];
      result$data['isNumeric'] = l$isNumeric == null
          ? null
          : Input$BooleanFilter.fromJson((l$isNumeric as Map<String, dynamic>));
    }
    if (data.containsKey('isDate')) {
      final l$isDate = data['isDate'];
      result$data['isDate'] = l$isDate == null
          ? null
          : Input$BooleanFilter.fromJson((l$isDate as Map<String, dynamic>));
    }
    if (data.containsKey('isBool')) {
      final l$isBool = data['isBool'];
      result$data['isBool'] = l$isBool == null
          ? null
          : Input$BooleanFilter.fromJson((l$isBool as Map<String, dynamic>));
    }
    if (data.containsKey('isObject')) {
      final l$isObject = data['isObject'];
      result$data['isObject'] = l$isObject == null
          ? null
          : Input$BooleanFilter.fromJson((l$isObject as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TemplateVariableTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TemplateVariableTypeFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$TemplateVariableTypeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$TemplateVariableTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);

  Input$BooleanFilter? get isPrimitive =>
      (_$data['isPrimitive'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isString =>
      (_$data['isString'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isNumeric =>
      (_$data['isNumeric'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isDate => (_$data['isDate'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isBool => (_$data['isBool'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isObject =>
      (_$data['isObject'] as Input$BooleanFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$TemplateVariableTypeFilter>? get and =>
      (_$data['and'] as List<Input$TemplateVariableTypeFilter>?);

  List<Input$TemplateVariableTypeFilter>? get or =>
      (_$data['or'] as List<Input$TemplateVariableTypeFilter>?);

  Input$TemplateVariableTypeFilter? get not =>
      (_$data['not'] as Input$TemplateVariableTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('isPrimitive')) {
      final l$isPrimitive = isPrimitive;
      result$data['isPrimitive'] = l$isPrimitive?.toJson();
    }
    if (_$data.containsKey('isString')) {
      final l$isString = isString;
      result$data['isString'] = l$isString?.toJson();
    }
    if (_$data.containsKey('isNumeric')) {
      final l$isNumeric = isNumeric;
      result$data['isNumeric'] = l$isNumeric?.toJson();
    }
    if (_$data.containsKey('isDate')) {
      final l$isDate = isDate;
      result$data['isDate'] = l$isDate?.toJson();
    }
    if (_$data.containsKey('isBool')) {
      final l$isBool = isBool;
      result$data['isBool'] = l$isBool?.toJson();
    }
    if (_$data.containsKey('isObject')) {
      final l$isObject = isObject;
      result$data['isObject'] = l$isObject?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableTypeFilter<Input$TemplateVariableTypeFilter>
      get copyWith => CopyWith$Input$TemplateVariableTypeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableTypeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrimitive = isPrimitive;
    final lOther$isPrimitive = other.isPrimitive;
    if (_$data.containsKey('isPrimitive') !=
        other._$data.containsKey('isPrimitive')) {
      return false;
    }
    if (l$isPrimitive != lOther$isPrimitive) {
      return false;
    }
    final l$isString = isString;
    final lOther$isString = other.isString;
    if (_$data.containsKey('isString') !=
        other._$data.containsKey('isString')) {
      return false;
    }
    if (l$isString != lOther$isString) {
      return false;
    }
    final l$isNumeric = isNumeric;
    final lOther$isNumeric = other.isNumeric;
    if (_$data.containsKey('isNumeric') !=
        other._$data.containsKey('isNumeric')) {
      return false;
    }
    if (l$isNumeric != lOther$isNumeric) {
      return false;
    }
    final l$isDate = isDate;
    final lOther$isDate = other.isDate;
    if (_$data.containsKey('isDate') != other._$data.containsKey('isDate')) {
      return false;
    }
    if (l$isDate != lOther$isDate) {
      return false;
    }
    final l$isBool = isBool;
    final lOther$isBool = other.isBool;
    if (_$data.containsKey('isBool') != other._$data.containsKey('isBool')) {
      return false;
    }
    if (l$isBool != lOther$isBool) {
      return false;
    }
    final l$isObject = isObject;
    final lOther$isObject = other.isObject;
    if (_$data.containsKey('isObject') !=
        other._$data.containsKey('isObject')) {
      return false;
    }
    if (l$isObject != lOther$isObject) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$isPrimitive = isPrimitive;
    final l$isString = isString;
    final l$isNumeric = isNumeric;
    final l$isDate = isDate;
    final l$isBool = isBool;
    final l$isObject = isObject;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrimitive') ? l$isPrimitive : const {},
      _$data.containsKey('isString') ? l$isString : const {},
      _$data.containsKey('isNumeric') ? l$isNumeric : const {},
      _$data.containsKey('isDate') ? l$isDate : const {},
      _$data.containsKey('isBool') ? l$isBool : const {},
      _$data.containsKey('isObject') ? l$isObject : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableTypeFilter<TRes> {
  factory CopyWith$Input$TemplateVariableTypeFilter(
    Input$TemplateVariableTypeFilter instance,
    TRes Function(Input$TemplateVariableTypeFilter) then,
  ) = _CopyWithImpl$Input$TemplateVariableTypeFilter;

  factory CopyWith$Input$TemplateVariableTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$BooleanFilter? isPrimitive,
    Input$BooleanFilter? isString,
    Input$BooleanFilter? isNumeric,
    Input$BooleanFilter? isDate,
    Input$BooleanFilter? isBool,
    Input$BooleanFilter? isObject,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableTypeFilter>? and,
    List<Input$TemplateVariableTypeFilter>? or,
    Input$TemplateVariableTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$BooleanFilter<TRes> get isPrimitive;
  CopyWith$Input$BooleanFilter<TRes> get isString;
  CopyWith$Input$BooleanFilter<TRes> get isNumeric;
  CopyWith$Input$BooleanFilter<TRes> get isDate;
  CopyWith$Input$BooleanFilter<TRes> get isBool;
  CopyWith$Input$BooleanFilter<TRes> get isObject;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$TemplateVariableTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$TemplateVariableTypeFilter<
                      Input$TemplateVariableTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$TemplateVariableTypeFilter>? Function(
              Iterable<
                  CopyWith$Input$TemplateVariableTypeFilter<
                      Input$TemplateVariableTypeFilter>>?)
          _fn);
  CopyWith$Input$TemplateVariableTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$TemplateVariableTypeFilter<TRes>
    implements CopyWith$Input$TemplateVariableTypeFilter<TRes> {
  _CopyWithImpl$Input$TemplateVariableTypeFilter(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableTypeFilter _instance;

  final TRes Function(Input$TemplateVariableTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? isPrimitive = _undefined,
    Object? isString = _undefined,
    Object? isNumeric = _undefined,
    Object? isDate = _undefined,
    Object? isBool = _undefined,
    Object? isObject = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$TemplateVariableTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (isPrimitive != _undefined)
          'isPrimitive': (isPrimitive as Input$BooleanFilter?),
        if (isString != _undefined)
          'isString': (isString as Input$BooleanFilter?),
        if (isNumeric != _undefined)
          'isNumeric': (isNumeric as Input$BooleanFilter?),
        if (isDate != _undefined) 'isDate': (isDate as Input$BooleanFilter?),
        if (isBool != _undefined) 'isBool': (isBool as Input$BooleanFilter?),
        if (isObject != _undefined)
          'isObject': (isObject as Input$BooleanFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$TemplateVariableTypeFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$TemplateVariableTypeFilter>?),
        if (not != _undefined)
          'not': (not as Input$TemplateVariableTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isPrimitive {
    final local$isPrimitive = _instance.isPrimitive;
    return local$isPrimitive == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isPrimitive, (e) => call(isPrimitive: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isString {
    final local$isString = _instance.isString;
    return local$isString == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isString, (e) => call(isString: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isNumeric {
    final local$isNumeric = _instance.isNumeric;
    return local$isNumeric == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isNumeric, (e) => call(isNumeric: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isDate {
    final local$isDate = _instance.isDate;
    return local$isDate == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(local$isDate, (e) => call(isDate: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isBool {
    final local$isBool = _instance.isBool;
    return local$isBool == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(local$isBool, (e) => call(isBool: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isObject {
    final local$isObject = _instance.isObject;
    return local$isObject == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isObject, (e) => call(isObject: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$TemplateVariableTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$TemplateVariableTypeFilter<
                          Input$TemplateVariableTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$TemplateVariableTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$TemplateVariableTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$TemplateVariableTypeFilter<
                          Input$TemplateVariableTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$TemplateVariableTypeFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$TemplateVariableTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$TemplateVariableTypeFilter.stub(_then(_instance))
        : CopyWith$Input$TemplateVariableTypeFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$TemplateVariableTypeFilter<TRes>
    implements CopyWith$Input$TemplateVariableTypeFilter<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? description,
    Input$BooleanFilter? isPrimitive,
    Input$BooleanFilter? isString,
    Input$BooleanFilter? isNumeric,
    Input$BooleanFilter? isDate,
    Input$BooleanFilter? isBool,
    Input$BooleanFilter? isObject,
    Input$IDFilter? nodeId,
    List<Input$TemplateVariableTypeFilter>? and,
    List<Input$TemplateVariableTypeFilter>? or,
    Input$TemplateVariableTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isPrimitive =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isString =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isNumeric =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isDate =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isBool =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isObject =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$TemplateVariableTypeFilter<TRes> get not =>
      CopyWith$Input$TemplateVariableTypeFilter.stub(_res);
}

class Input$TemplateVariableTypeInsertInput {
  factory Input$TemplateVariableTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  }) =>
      Input$TemplateVariableTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (isPrimitive != null) r'isPrimitive': isPrimitive,
        if (isString != null) r'isString': isString,
        if (isNumeric != null) r'isNumeric': isNumeric,
        if (isDate != null) r'isDate': isDate,
        if (isBool != null) r'isBool': isBool,
        if (isObject != null) r'isObject': isObject,
      });

  Input$TemplateVariableTypeInsertInput._(this._$data);

  factory Input$TemplateVariableTypeInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('isPrimitive')) {
      final l$isPrimitive = data['isPrimitive'];
      result$data['isPrimitive'] = (l$isPrimitive as bool?);
    }
    if (data.containsKey('isString')) {
      final l$isString = data['isString'];
      result$data['isString'] = (l$isString as bool?);
    }
    if (data.containsKey('isNumeric')) {
      final l$isNumeric = data['isNumeric'];
      result$data['isNumeric'] = (l$isNumeric as bool?);
    }
    if (data.containsKey('isDate')) {
      final l$isDate = data['isDate'];
      result$data['isDate'] = (l$isDate as bool?);
    }
    if (data.containsKey('isBool')) {
      final l$isBool = data['isBool'];
      result$data['isBool'] = (l$isBool as bool?);
    }
    if (data.containsKey('isObject')) {
      final l$isObject = data['isObject'];
      result$data['isObject'] = (l$isObject as bool?);
    }
    return Input$TemplateVariableTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get description => (_$data['description'] as String?);

  bool? get isPrimitive => (_$data['isPrimitive'] as bool?);

  bool? get isString => (_$data['isString'] as bool?);

  bool? get isNumeric => (_$data['isNumeric'] as bool?);

  bool? get isDate => (_$data['isDate'] as bool?);

  bool? get isBool => (_$data['isBool'] as bool?);

  bool? get isObject => (_$data['isObject'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('isPrimitive')) {
      final l$isPrimitive = isPrimitive;
      result$data['isPrimitive'] = l$isPrimitive;
    }
    if (_$data.containsKey('isString')) {
      final l$isString = isString;
      result$data['isString'] = l$isString;
    }
    if (_$data.containsKey('isNumeric')) {
      final l$isNumeric = isNumeric;
      result$data['isNumeric'] = l$isNumeric;
    }
    if (_$data.containsKey('isDate')) {
      final l$isDate = isDate;
      result$data['isDate'] = l$isDate;
    }
    if (_$data.containsKey('isBool')) {
      final l$isBool = isBool;
      result$data['isBool'] = l$isBool;
    }
    if (_$data.containsKey('isObject')) {
      final l$isObject = isObject;
      result$data['isObject'] = l$isObject;
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableTypeInsertInput<
          Input$TemplateVariableTypeInsertInput>
      get copyWith => CopyWith$Input$TemplateVariableTypeInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrimitive = isPrimitive;
    final lOther$isPrimitive = other.isPrimitive;
    if (_$data.containsKey('isPrimitive') !=
        other._$data.containsKey('isPrimitive')) {
      return false;
    }
    if (l$isPrimitive != lOther$isPrimitive) {
      return false;
    }
    final l$isString = isString;
    final lOther$isString = other.isString;
    if (_$data.containsKey('isString') !=
        other._$data.containsKey('isString')) {
      return false;
    }
    if (l$isString != lOther$isString) {
      return false;
    }
    final l$isNumeric = isNumeric;
    final lOther$isNumeric = other.isNumeric;
    if (_$data.containsKey('isNumeric') !=
        other._$data.containsKey('isNumeric')) {
      return false;
    }
    if (l$isNumeric != lOther$isNumeric) {
      return false;
    }
    final l$isDate = isDate;
    final lOther$isDate = other.isDate;
    if (_$data.containsKey('isDate') != other._$data.containsKey('isDate')) {
      return false;
    }
    if (l$isDate != lOther$isDate) {
      return false;
    }
    final l$isBool = isBool;
    final lOther$isBool = other.isBool;
    if (_$data.containsKey('isBool') != other._$data.containsKey('isBool')) {
      return false;
    }
    if (l$isBool != lOther$isBool) {
      return false;
    }
    final l$isObject = isObject;
    final lOther$isObject = other.isObject;
    if (_$data.containsKey('isObject') !=
        other._$data.containsKey('isObject')) {
      return false;
    }
    if (l$isObject != lOther$isObject) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$isPrimitive = isPrimitive;
    final l$isString = isString;
    final l$isNumeric = isNumeric;
    final l$isDate = isDate;
    final l$isBool = isBool;
    final l$isObject = isObject;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrimitive') ? l$isPrimitive : const {},
      _$data.containsKey('isString') ? l$isString : const {},
      _$data.containsKey('isNumeric') ? l$isNumeric : const {},
      _$data.containsKey('isDate') ? l$isDate : const {},
      _$data.containsKey('isBool') ? l$isBool : const {},
      _$data.containsKey('isObject') ? l$isObject : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableTypeInsertInput<TRes> {
  factory CopyWith$Input$TemplateVariableTypeInsertInput(
    Input$TemplateVariableTypeInsertInput instance,
    TRes Function(Input$TemplateVariableTypeInsertInput) then,
  ) = _CopyWithImpl$Input$TemplateVariableTypeInsertInput;

  factory CopyWith$Input$TemplateVariableTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  });
}

class _CopyWithImpl$Input$TemplateVariableTypeInsertInput<TRes>
    implements CopyWith$Input$TemplateVariableTypeInsertInput<TRes> {
  _CopyWithImpl$Input$TemplateVariableTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableTypeInsertInput _instance;

  final TRes Function(Input$TemplateVariableTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? isPrimitive = _undefined,
    Object? isString = _undefined,
    Object? isNumeric = _undefined,
    Object? isDate = _undefined,
    Object? isBool = _undefined,
    Object? isObject = _undefined,
  }) =>
      _then(Input$TemplateVariableTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (description != _undefined) 'description': (description as String?),
        if (isPrimitive != _undefined) 'isPrimitive': (isPrimitive as bool?),
        if (isString != _undefined) 'isString': (isString as bool?),
        if (isNumeric != _undefined) 'isNumeric': (isNumeric as bool?),
        if (isDate != _undefined) 'isDate': (isDate as bool?),
        if (isBool != _undefined) 'isBool': (isBool as bool?),
        if (isObject != _undefined) 'isObject': (isObject as bool?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableTypeInsertInput<TRes>
    implements CopyWith$Input$TemplateVariableTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  }) =>
      _res;
}

class Input$TemplateVariableTypeOrderBy {
  factory Input$TemplateVariableTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? isPrimitive,
    Enum$OrderByDirection? isString,
    Enum$OrderByDirection? isNumeric,
    Enum$OrderByDirection? isDate,
    Enum$OrderByDirection? isBool,
    Enum$OrderByDirection? isObject,
  }) =>
      Input$TemplateVariableTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (isPrimitive != null) r'isPrimitive': isPrimitive,
        if (isString != null) r'isString': isString,
        if (isNumeric != null) r'isNumeric': isNumeric,
        if (isDate != null) r'isDate': isDate,
        if (isBool != null) r'isBool': isBool,
        if (isObject != null) r'isObject': isObject,
      });

  Input$TemplateVariableTypeOrderBy._(this._$data);

  factory Input$TemplateVariableTypeOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$OrderByDirection((l$description as String));
    }
    if (data.containsKey('isPrimitive')) {
      final l$isPrimitive = data['isPrimitive'];
      result$data['isPrimitive'] = l$isPrimitive == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isPrimitive as String));
    }
    if (data.containsKey('isString')) {
      final l$isString = data['isString'];
      result$data['isString'] = l$isString == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isString as String));
    }
    if (data.containsKey('isNumeric')) {
      final l$isNumeric = data['isNumeric'];
      result$data['isNumeric'] = l$isNumeric == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isNumeric as String));
    }
    if (data.containsKey('isDate')) {
      final l$isDate = data['isDate'];
      result$data['isDate'] = l$isDate == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isDate as String));
    }
    if (data.containsKey('isBool')) {
      final l$isBool = data['isBool'];
      result$data['isBool'] = l$isBool == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isBool as String));
    }
    if (data.containsKey('isObject')) {
      final l$isObject = data['isObject'];
      result$data['isObject'] = l$isObject == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isObject as String));
    }
    return Input$TemplateVariableTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get description =>
      (_$data['description'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isPrimitive =>
      (_$data['isPrimitive'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isString =>
      (_$data['isString'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isNumeric =>
      (_$data['isNumeric'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isDate =>
      (_$data['isDate'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isBool =>
      (_$data['isBool'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isObject =>
      (_$data['isObject'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$OrderByDirection(l$description);
    }
    if (_$data.containsKey('isPrimitive')) {
      final l$isPrimitive = isPrimitive;
      result$data['isPrimitive'] = l$isPrimitive == null
          ? null
          : toJson$Enum$OrderByDirection(l$isPrimitive);
    }
    if (_$data.containsKey('isString')) {
      final l$isString = isString;
      result$data['isString'] =
          l$isString == null ? null : toJson$Enum$OrderByDirection(l$isString);
    }
    if (_$data.containsKey('isNumeric')) {
      final l$isNumeric = isNumeric;
      result$data['isNumeric'] = l$isNumeric == null
          ? null
          : toJson$Enum$OrderByDirection(l$isNumeric);
    }
    if (_$data.containsKey('isDate')) {
      final l$isDate = isDate;
      result$data['isDate'] =
          l$isDate == null ? null : toJson$Enum$OrderByDirection(l$isDate);
    }
    if (_$data.containsKey('isBool')) {
      final l$isBool = isBool;
      result$data['isBool'] =
          l$isBool == null ? null : toJson$Enum$OrderByDirection(l$isBool);
    }
    if (_$data.containsKey('isObject')) {
      final l$isObject = isObject;
      result$data['isObject'] =
          l$isObject == null ? null : toJson$Enum$OrderByDirection(l$isObject);
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableTypeOrderBy<Input$TemplateVariableTypeOrderBy>
      get copyWith => CopyWith$Input$TemplateVariableTypeOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableTypeOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrimitive = isPrimitive;
    final lOther$isPrimitive = other.isPrimitive;
    if (_$data.containsKey('isPrimitive') !=
        other._$data.containsKey('isPrimitive')) {
      return false;
    }
    if (l$isPrimitive != lOther$isPrimitive) {
      return false;
    }
    final l$isString = isString;
    final lOther$isString = other.isString;
    if (_$data.containsKey('isString') !=
        other._$data.containsKey('isString')) {
      return false;
    }
    if (l$isString != lOther$isString) {
      return false;
    }
    final l$isNumeric = isNumeric;
    final lOther$isNumeric = other.isNumeric;
    if (_$data.containsKey('isNumeric') !=
        other._$data.containsKey('isNumeric')) {
      return false;
    }
    if (l$isNumeric != lOther$isNumeric) {
      return false;
    }
    final l$isDate = isDate;
    final lOther$isDate = other.isDate;
    if (_$data.containsKey('isDate') != other._$data.containsKey('isDate')) {
      return false;
    }
    if (l$isDate != lOther$isDate) {
      return false;
    }
    final l$isBool = isBool;
    final lOther$isBool = other.isBool;
    if (_$data.containsKey('isBool') != other._$data.containsKey('isBool')) {
      return false;
    }
    if (l$isBool != lOther$isBool) {
      return false;
    }
    final l$isObject = isObject;
    final lOther$isObject = other.isObject;
    if (_$data.containsKey('isObject') !=
        other._$data.containsKey('isObject')) {
      return false;
    }
    if (l$isObject != lOther$isObject) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$isPrimitive = isPrimitive;
    final l$isString = isString;
    final l$isNumeric = isNumeric;
    final l$isDate = isDate;
    final l$isBool = isBool;
    final l$isObject = isObject;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrimitive') ? l$isPrimitive : const {},
      _$data.containsKey('isString') ? l$isString : const {},
      _$data.containsKey('isNumeric') ? l$isNumeric : const {},
      _$data.containsKey('isDate') ? l$isDate : const {},
      _$data.containsKey('isBool') ? l$isBool : const {},
      _$data.containsKey('isObject') ? l$isObject : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableTypeOrderBy<TRes> {
  factory CopyWith$Input$TemplateVariableTypeOrderBy(
    Input$TemplateVariableTypeOrderBy instance,
    TRes Function(Input$TemplateVariableTypeOrderBy) then,
  ) = _CopyWithImpl$Input$TemplateVariableTypeOrderBy;

  factory CopyWith$Input$TemplateVariableTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? isPrimitive,
    Enum$OrderByDirection? isString,
    Enum$OrderByDirection? isNumeric,
    Enum$OrderByDirection? isDate,
    Enum$OrderByDirection? isBool,
    Enum$OrderByDirection? isObject,
  });
}

class _CopyWithImpl$Input$TemplateVariableTypeOrderBy<TRes>
    implements CopyWith$Input$TemplateVariableTypeOrderBy<TRes> {
  _CopyWithImpl$Input$TemplateVariableTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableTypeOrderBy _instance;

  final TRes Function(Input$TemplateVariableTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? isPrimitive = _undefined,
    Object? isString = _undefined,
    Object? isNumeric = _undefined,
    Object? isDate = _undefined,
    Object? isBool = _undefined,
    Object? isObject = _undefined,
  }) =>
      _then(Input$TemplateVariableTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (description != _undefined)
          'description': (description as Enum$OrderByDirection?),
        if (isPrimitive != _undefined)
          'isPrimitive': (isPrimitive as Enum$OrderByDirection?),
        if (isString != _undefined)
          'isString': (isString as Enum$OrderByDirection?),
        if (isNumeric != _undefined)
          'isNumeric': (isNumeric as Enum$OrderByDirection?),
        if (isDate != _undefined) 'isDate': (isDate as Enum$OrderByDirection?),
        if (isBool != _undefined) 'isBool': (isBool as Enum$OrderByDirection?),
        if (isObject != _undefined)
          'isObject': (isObject as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableTypeOrderBy<TRes>
    implements CopyWith$Input$TemplateVariableTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? description,
    Enum$OrderByDirection? isPrimitive,
    Enum$OrderByDirection? isString,
    Enum$OrderByDirection? isNumeric,
    Enum$OrderByDirection? isDate,
    Enum$OrderByDirection? isBool,
    Enum$OrderByDirection? isObject,
  }) =>
      _res;
}

class Input$TemplateVariableTypeUpdateInput {
  factory Input$TemplateVariableTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  }) =>
      Input$TemplateVariableTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (createdAt != null) r'createdAt': createdAt,
        if (description != null) r'description': description,
        if (isPrimitive != null) r'isPrimitive': isPrimitive,
        if (isString != null) r'isString': isString,
        if (isNumeric != null) r'isNumeric': isNumeric,
        if (isDate != null) r'isDate': isDate,
        if (isBool != null) r'isBool': isBool,
        if (isObject != null) r'isObject': isObject,
      });

  Input$TemplateVariableTypeUpdateInput._(this._$data);

  factory Input$TemplateVariableTypeUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('isPrimitive')) {
      final l$isPrimitive = data['isPrimitive'];
      result$data['isPrimitive'] = (l$isPrimitive as bool?);
    }
    if (data.containsKey('isString')) {
      final l$isString = data['isString'];
      result$data['isString'] = (l$isString as bool?);
    }
    if (data.containsKey('isNumeric')) {
      final l$isNumeric = data['isNumeric'];
      result$data['isNumeric'] = (l$isNumeric as bool?);
    }
    if (data.containsKey('isDate')) {
      final l$isDate = data['isDate'];
      result$data['isDate'] = (l$isDate as bool?);
    }
    if (data.containsKey('isBool')) {
      final l$isBool = data['isBool'];
      result$data['isBool'] = (l$isBool as bool?);
    }
    if (data.containsKey('isObject')) {
      final l$isObject = data['isObject'];
      result$data['isObject'] = (l$isObject as bool?);
    }
    return Input$TemplateVariableTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get description => (_$data['description'] as String?);

  bool? get isPrimitive => (_$data['isPrimitive'] as bool?);

  bool? get isString => (_$data['isString'] as bool?);

  bool? get isNumeric => (_$data['isNumeric'] as bool?);

  bool? get isDate => (_$data['isDate'] as bool?);

  bool? get isBool => (_$data['isBool'] as bool?);

  bool? get isObject => (_$data['isObject'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('isPrimitive')) {
      final l$isPrimitive = isPrimitive;
      result$data['isPrimitive'] = l$isPrimitive;
    }
    if (_$data.containsKey('isString')) {
      final l$isString = isString;
      result$data['isString'] = l$isString;
    }
    if (_$data.containsKey('isNumeric')) {
      final l$isNumeric = isNumeric;
      result$data['isNumeric'] = l$isNumeric;
    }
    if (_$data.containsKey('isDate')) {
      final l$isDate = isDate;
      result$data['isDate'] = l$isDate;
    }
    if (_$data.containsKey('isBool')) {
      final l$isBool = isBool;
      result$data['isBool'] = l$isBool;
    }
    if (_$data.containsKey('isObject')) {
      final l$isObject = isObject;
      result$data['isObject'] = l$isObject;
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableTypeUpdateInput<
          Input$TemplateVariableTypeUpdateInput>
      get copyWith => CopyWith$Input$TemplateVariableTypeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrimitive = isPrimitive;
    final lOther$isPrimitive = other.isPrimitive;
    if (_$data.containsKey('isPrimitive') !=
        other._$data.containsKey('isPrimitive')) {
      return false;
    }
    if (l$isPrimitive != lOther$isPrimitive) {
      return false;
    }
    final l$isString = isString;
    final lOther$isString = other.isString;
    if (_$data.containsKey('isString') !=
        other._$data.containsKey('isString')) {
      return false;
    }
    if (l$isString != lOther$isString) {
      return false;
    }
    final l$isNumeric = isNumeric;
    final lOther$isNumeric = other.isNumeric;
    if (_$data.containsKey('isNumeric') !=
        other._$data.containsKey('isNumeric')) {
      return false;
    }
    if (l$isNumeric != lOther$isNumeric) {
      return false;
    }
    final l$isDate = isDate;
    final lOther$isDate = other.isDate;
    if (_$data.containsKey('isDate') != other._$data.containsKey('isDate')) {
      return false;
    }
    if (l$isDate != lOther$isDate) {
      return false;
    }
    final l$isBool = isBool;
    final lOther$isBool = other.isBool;
    if (_$data.containsKey('isBool') != other._$data.containsKey('isBool')) {
      return false;
    }
    if (l$isBool != lOther$isBool) {
      return false;
    }
    final l$isObject = isObject;
    final lOther$isObject = other.isObject;
    if (_$data.containsKey('isObject') !=
        other._$data.containsKey('isObject')) {
      return false;
    }
    if (l$isObject != lOther$isObject) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$createdAt = createdAt;
    final l$description = description;
    final l$isPrimitive = isPrimitive;
    final l$isString = isString;
    final l$isNumeric = isNumeric;
    final l$isDate = isDate;
    final l$isBool = isBool;
    final l$isObject = isObject;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrimitive') ? l$isPrimitive : const {},
      _$data.containsKey('isString') ? l$isString : const {},
      _$data.containsKey('isNumeric') ? l$isNumeric : const {},
      _$data.containsKey('isDate') ? l$isDate : const {},
      _$data.containsKey('isBool') ? l$isBool : const {},
      _$data.containsKey('isObject') ? l$isObject : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableTypeUpdateInput<TRes> {
  factory CopyWith$Input$TemplateVariableTypeUpdateInput(
    Input$TemplateVariableTypeUpdateInput instance,
    TRes Function(Input$TemplateVariableTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$TemplateVariableTypeUpdateInput;

  factory CopyWith$Input$TemplateVariableTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  });
}

class _CopyWithImpl$Input$TemplateVariableTypeUpdateInput<TRes>
    implements CopyWith$Input$TemplateVariableTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$TemplateVariableTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableTypeUpdateInput _instance;

  final TRes Function(Input$TemplateVariableTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? createdAt = _undefined,
    Object? description = _undefined,
    Object? isPrimitive = _undefined,
    Object? isString = _undefined,
    Object? isNumeric = _undefined,
    Object? isDate = _undefined,
    Object? isBool = _undefined,
    Object? isObject = _undefined,
  }) =>
      _then(Input$TemplateVariableTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (description != _undefined) 'description': (description as String?),
        if (isPrimitive != _undefined) 'isPrimitive': (isPrimitive as bool?),
        if (isString != _undefined) 'isString': (isString as bool?),
        if (isNumeric != _undefined) 'isNumeric': (isNumeric as bool?),
        if (isDate != _undefined) 'isDate': (isDate as bool?),
        if (isBool != _undefined) 'isBool': (isBool as bool?),
        if (isObject != _undefined) 'isObject': (isObject as bool?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableTypeUpdateInput<TRes>
    implements CopyWith$Input$TemplateVariableTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    DateTime? createdAt,
    String? description,
    bool? isPrimitive,
    bool? isString,
    bool? isNumeric,
    bool? isDate,
    bool? isBool,
    bool? isObject,
  }) =>
      _res;
}

class Input$TemplateVariableUpdateInput {
  factory Input$TemplateVariableUpdateInput({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  }) =>
      Input$TemplateVariableUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (stringValue != null) r'stringValue': stringValue,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
        if (templateVariableTypeId != null)
          r'templateVariableTypeId': templateVariableTypeId,
        if (usage != null) r'usage': usage,
      });

  Input$TemplateVariableUpdateInput._(this._$data);

  factory Input$TemplateVariableUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = (l$stringValue as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = data['templateVariableTypeId'];
      result$data['templateVariableTypeId'] =
          (l$templateVariableTypeId as String?);
    }
    if (data.containsKey('usage')) {
      final l$usage = data['usage'];
      result$data['usage'] = (l$usage as String?);
    }
    return Input$TemplateVariableUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get stringValue => (_$data['stringValue'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get templateVariableTypeId =>
      (_$data['templateVariableTypeId'] as String?);

  String? get usage => (_$data['usage'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('templateVariableTypeId')) {
      final l$templateVariableTypeId = templateVariableTypeId;
      result$data['templateVariableTypeId'] = l$templateVariableTypeId;
    }
    if (_$data.containsKey('usage')) {
      final l$usage = usage;
      result$data['usage'] = l$usage;
    }
    return result$data;
  }

  CopyWith$Input$TemplateVariableUpdateInput<Input$TemplateVariableUpdateInput>
      get copyWith => CopyWith$Input$TemplateVariableUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TemplateVariableUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$templateVariableTypeId = templateVariableTypeId;
    final lOther$templateVariableTypeId = other.templateVariableTypeId;
    if (_$data.containsKey('templateVariableTypeId') !=
        other._$data.containsKey('templateVariableTypeId')) {
      return false;
    }
    if (l$templateVariableTypeId != lOther$templateVariableTypeId) {
      return false;
    }
    final l$usage = usage;
    final lOther$usage = other.usage;
    if (_$data.containsKey('usage') != other._$data.containsKey('usage')) {
      return false;
    }
    if (l$usage != lOther$usage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$stringValue = stringValue;
    final l$createdAt = createdAt;
    final l$data = data;
    final l$templateVariableTypeId = templateVariableTypeId;
    final l$usage = usage;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('templateVariableTypeId')
          ? l$templateVariableTypeId
          : const {},
      _$data.containsKey('usage') ? l$usage : const {},
    ]);
  }
}

abstract class CopyWith$Input$TemplateVariableUpdateInput<TRes> {
  factory CopyWith$Input$TemplateVariableUpdateInput(
    Input$TemplateVariableUpdateInput instance,
    TRes Function(Input$TemplateVariableUpdateInput) then,
  ) = _CopyWithImpl$Input$TemplateVariableUpdateInput;

  factory CopyWith$Input$TemplateVariableUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TemplateVariableUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  });
}

class _CopyWithImpl$Input$TemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$TemplateVariableUpdateInput<TRes> {
  _CopyWithImpl$Input$TemplateVariableUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TemplateVariableUpdateInput _instance;

  final TRes Function(Input$TemplateVariableUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? stringValue = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
    Object? templateVariableTypeId = _undefined,
    Object? usage = _undefined,
  }) =>
      _then(Input$TemplateVariableUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (stringValue != _undefined) 'stringValue': (stringValue as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (templateVariableTypeId != _undefined)
          'templateVariableTypeId': (templateVariableTypeId as String?),
        if (usage != _undefined) 'usage': (usage as String?),
      }));
}

class _CopyWithStubImpl$Input$TemplateVariableUpdateInput<TRes>
    implements CopyWith$Input$TemplateVariableUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TemplateVariableUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? stringValue,
    DateTime? createdAt,
    Map<String, dynamic>? data,
    String? templateVariableTypeId,
    String? usage,
  }) =>
      _res;
}

class Input$TestimonialFilter {
  factory Input$TestimonialFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? role,
    Input$StringFilter? contentMarkdown,
    Input$StringFilter? avatar,
    Input$StringFilter? summary,
    Input$IDFilter? nodeId,
    List<Input$TestimonialFilter>? and,
    List<Input$TestimonialFilter>? or,
    Input$TestimonialFilter? not,
  }) =>
      Input$TestimonialFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (role != null) r'role': role,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
        if (avatar != null) r'avatar': avatar,
        if (summary != null) r'summary': summary,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$TestimonialFilter._(this._$data);

  factory Input$TestimonialFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$StringFilter.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$contentMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = l$avatar == null
          ? null
          : Input$StringFilter.fromJson((l$avatar as Map<String, dynamic>));
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = l$summary == null
          ? null
          : Input$StringFilter.fromJson((l$summary as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$TestimonialFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$TestimonialFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$TestimonialFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$TestimonialFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get role => (_$data['role'] as Input$StringFilter?);

  Input$StringFilter? get contentMarkdown =>
      (_$data['contentMarkdown'] as Input$StringFilter?);

  Input$StringFilter? get avatar => (_$data['avatar'] as Input$StringFilter?);

  Input$StringFilter? get summary => (_$data['summary'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$TestimonialFilter>? get and =>
      (_$data['and'] as List<Input$TestimonialFilter>?);

  List<Input$TestimonialFilter>? get or =>
      (_$data['or'] as List<Input$TestimonialFilter>?);

  Input$TestimonialFilter? get not =>
      (_$data['not'] as Input$TestimonialFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown?.toJson();
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar?.toJson();
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TestimonialFilter<Input$TestimonialFilter> get copyWith =>
      CopyWith$Input$TestimonialFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TestimonialFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$role = role;
    final l$contentMarkdown = contentMarkdown;
    final l$avatar = avatar;
    final l$summary = summary;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('summary') ? l$summary : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$TestimonialFilter<TRes> {
  factory CopyWith$Input$TestimonialFilter(
    Input$TestimonialFilter instance,
    TRes Function(Input$TestimonialFilter) then,
  ) = _CopyWithImpl$Input$TestimonialFilter;

  factory CopyWith$Input$TestimonialFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TestimonialFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? role,
    Input$StringFilter? contentMarkdown,
    Input$StringFilter? avatar,
    Input$StringFilter? summary,
    Input$IDFilter? nodeId,
    List<Input$TestimonialFilter>? and,
    List<Input$TestimonialFilter>? or,
    Input$TestimonialFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get role;
  CopyWith$Input$StringFilter<TRes> get contentMarkdown;
  CopyWith$Input$StringFilter<TRes> get avatar;
  CopyWith$Input$StringFilter<TRes> get summary;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$TestimonialFilter>? Function(
              Iterable<
                  CopyWith$Input$TestimonialFilter<Input$TestimonialFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$TestimonialFilter>? Function(
              Iterable<
                  CopyWith$Input$TestimonialFilter<Input$TestimonialFilter>>?)
          _fn);
  CopyWith$Input$TestimonialFilter<TRes> get not;
}

class _CopyWithImpl$Input$TestimonialFilter<TRes>
    implements CopyWith$Input$TestimonialFilter<TRes> {
  _CopyWithImpl$Input$TestimonialFilter(
    this._instance,
    this._then,
  );

  final Input$TestimonialFilter _instance;

  final TRes Function(Input$TestimonialFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? role = _undefined,
    Object? contentMarkdown = _undefined,
    Object? avatar = _undefined,
    Object? summary = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$TestimonialFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (role != _undefined) 'role': (role as Input$StringFilter?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as Input$StringFilter?),
        if (avatar != _undefined) 'avatar': (avatar as Input$StringFilter?),
        if (summary != _undefined) 'summary': (summary as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$TestimonialFilter>?),
        if (or != _undefined) 'or': (or as List<Input$TestimonialFilter>?),
        if (not != _undefined) 'not': (not as Input$TestimonialFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringFilter<TRes> get contentMarkdown {
    final local$contentMarkdown = _instance.contentMarkdown;
    return local$contentMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$contentMarkdown, (e) => call(contentMarkdown: e));
  }

  CopyWith$Input$StringFilter<TRes> get avatar {
    final local$avatar = _instance.avatar;
    return local$avatar == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$avatar, (e) => call(avatar: e));
  }

  CopyWith$Input$StringFilter<TRes> get summary {
    final local$summary = _instance.summary;
    return local$summary == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$summary, (e) => call(summary: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$TestimonialFilter>? Function(
                  Iterable<
                      CopyWith$Input$TestimonialFilter<
                          Input$TestimonialFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$TestimonialFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$TestimonialFilter>? Function(
                  Iterable<
                      CopyWith$Input$TestimonialFilter<
                          Input$TestimonialFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$TestimonialFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$TestimonialFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$TestimonialFilter.stub(_then(_instance))
        : CopyWith$Input$TestimonialFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$TestimonialFilter<TRes>
    implements CopyWith$Input$TestimonialFilter<TRes> {
  _CopyWithStubImpl$Input$TestimonialFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? name,
    Input$StringFilter? role,
    Input$StringFilter? contentMarkdown,
    Input$StringFilter? avatar,
    Input$StringFilter? summary,
    Input$IDFilter? nodeId,
    List<Input$TestimonialFilter>? and,
    List<Input$TestimonialFilter>? or,
    Input$TestimonialFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get role =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get contentMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get avatar =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get summary =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$TestimonialFilter<TRes> get not =>
      CopyWith$Input$TestimonialFilter.stub(_res);
}

class Input$TestimonialInsertInput {
  factory Input$TestimonialInsertInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  }) =>
      Input$TestimonialInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (role != null) r'role': role,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
        if (avatar != null) r'avatar': avatar,
        if (summary != null) r'summary': summary,
      });

  Input$TestimonialInsertInput._(this._$data);

  factory Input$TestimonialInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = (l$contentMarkdown as String?);
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = (l$summary as String?);
    }
    return Input$TestimonialInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get role => (_$data['role'] as String?);

  String? get contentMarkdown => (_$data['contentMarkdown'] as String?);

  String? get avatar => (_$data['avatar'] as String?);

  String? get summary => (_$data['summary'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown;
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary;
    }
    return result$data;
  }

  CopyWith$Input$TestimonialInsertInput<Input$TestimonialInsertInput>
      get copyWith => CopyWith$Input$TestimonialInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TestimonialInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$role = role;
    final l$contentMarkdown = contentMarkdown;
    final l$avatar = avatar;
    final l$summary = summary;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('summary') ? l$summary : const {},
    ]);
  }
}

abstract class CopyWith$Input$TestimonialInsertInput<TRes> {
  factory CopyWith$Input$TestimonialInsertInput(
    Input$TestimonialInsertInput instance,
    TRes Function(Input$TestimonialInsertInput) then,
  ) = _CopyWithImpl$Input$TestimonialInsertInput;

  factory CopyWith$Input$TestimonialInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TestimonialInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  });
}

class _CopyWithImpl$Input$TestimonialInsertInput<TRes>
    implements CopyWith$Input$TestimonialInsertInput<TRes> {
  _CopyWithImpl$Input$TestimonialInsertInput(
    this._instance,
    this._then,
  );

  final Input$TestimonialInsertInput _instance;

  final TRes Function(Input$TestimonialInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? role = _undefined,
    Object? contentMarkdown = _undefined,
    Object? avatar = _undefined,
    Object? summary = _undefined,
  }) =>
      _then(Input$TestimonialInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (role != _undefined) 'role': (role as String?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as String?),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (summary != _undefined) 'summary': (summary as String?),
      }));
}

class _CopyWithStubImpl$Input$TestimonialInsertInput<TRes>
    implements CopyWith$Input$TestimonialInsertInput<TRes> {
  _CopyWithStubImpl$Input$TestimonialInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  }) =>
      _res;
}

class Input$TestimonialOrderBy {
  factory Input$TestimonialOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? role,
    Enum$OrderByDirection? contentMarkdown,
    Enum$OrderByDirection? avatar,
    Enum$OrderByDirection? summary,
  }) =>
      Input$TestimonialOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (role != null) r'role': role,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
        if (avatar != null) r'avatar': avatar,
        if (summary != null) r'summary': summary,
      });

  Input$TestimonialOrderBy._(this._$data);

  factory Input$TestimonialOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$OrderByDirection((l$role as String));
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection((l$contentMarkdown as String));
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = l$avatar == null
          ? null
          : fromJson$Enum$OrderByDirection((l$avatar as String));
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = l$summary == null
          ? null
          : fromJson$Enum$OrderByDirection((l$summary as String));
    }
    return Input$TestimonialOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get role => (_$data['role'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get contentMarkdown =>
      (_$data['contentMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get avatar =>
      (_$data['avatar'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get summary =>
      (_$data['summary'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] =
          l$role == null ? null : toJson$Enum$OrderByDirection(l$role);
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$contentMarkdown);
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] =
          l$avatar == null ? null : toJson$Enum$OrderByDirection(l$avatar);
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] =
          l$summary == null ? null : toJson$Enum$OrderByDirection(l$summary);
    }
    return result$data;
  }

  CopyWith$Input$TestimonialOrderBy<Input$TestimonialOrderBy> get copyWith =>
      CopyWith$Input$TestimonialOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TestimonialOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$role = role;
    final l$contentMarkdown = contentMarkdown;
    final l$avatar = avatar;
    final l$summary = summary;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('summary') ? l$summary : const {},
    ]);
  }
}

abstract class CopyWith$Input$TestimonialOrderBy<TRes> {
  factory CopyWith$Input$TestimonialOrderBy(
    Input$TestimonialOrderBy instance,
    TRes Function(Input$TestimonialOrderBy) then,
  ) = _CopyWithImpl$Input$TestimonialOrderBy;

  factory CopyWith$Input$TestimonialOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TestimonialOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? role,
    Enum$OrderByDirection? contentMarkdown,
    Enum$OrderByDirection? avatar,
    Enum$OrderByDirection? summary,
  });
}

class _CopyWithImpl$Input$TestimonialOrderBy<TRes>
    implements CopyWith$Input$TestimonialOrderBy<TRes> {
  _CopyWithImpl$Input$TestimonialOrderBy(
    this._instance,
    this._then,
  );

  final Input$TestimonialOrderBy _instance;

  final TRes Function(Input$TestimonialOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? role = _undefined,
    Object? contentMarkdown = _undefined,
    Object? avatar = _undefined,
    Object? summary = _undefined,
  }) =>
      _then(Input$TestimonialOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (role != _undefined) 'role': (role as Enum$OrderByDirection?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as Enum$OrderByDirection?),
        if (avatar != _undefined) 'avatar': (avatar as Enum$OrderByDirection?),
        if (summary != _undefined)
          'summary': (summary as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$TestimonialOrderBy<TRes>
    implements CopyWith$Input$TestimonialOrderBy<TRes> {
  _CopyWithStubImpl$Input$TestimonialOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? role,
    Enum$OrderByDirection? contentMarkdown,
    Enum$OrderByDirection? avatar,
    Enum$OrderByDirection? summary,
  }) =>
      _res;
}

class Input$TestimonialUpdateInput {
  factory Input$TestimonialUpdateInput({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  }) =>
      Input$TestimonialUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (name != null) r'name': name,
        if (role != null) r'role': role,
        if (contentMarkdown != null) r'contentMarkdown': contentMarkdown,
        if (avatar != null) r'avatar': avatar,
        if (summary != null) r'summary': summary,
      });

  Input$TestimonialUpdateInput._(this._$data);

  factory Input$TestimonialUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = data['contentMarkdown'];
      result$data['contentMarkdown'] = (l$contentMarkdown as String?);
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = (l$summary as String?);
    }
    return Input$TestimonialUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get name => (_$data['name'] as String?);

  String? get role => (_$data['role'] as String?);

  String? get contentMarkdown => (_$data['contentMarkdown'] as String?);

  String? get avatar => (_$data['avatar'] as String?);

  String? get summary => (_$data['summary'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('contentMarkdown')) {
      final l$contentMarkdown = contentMarkdown;
      result$data['contentMarkdown'] = l$contentMarkdown;
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary;
    }
    return result$data;
  }

  CopyWith$Input$TestimonialUpdateInput<Input$TestimonialUpdateInput>
      get copyWith => CopyWith$Input$TestimonialUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TestimonialUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$contentMarkdown = contentMarkdown;
    final lOther$contentMarkdown = other.contentMarkdown;
    if (_$data.containsKey('contentMarkdown') !=
        other._$data.containsKey('contentMarkdown')) {
      return false;
    }
    if (l$contentMarkdown != lOther$contentMarkdown) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$name = name;
    final l$role = role;
    final l$contentMarkdown = contentMarkdown;
    final l$avatar = avatar;
    final l$summary = summary;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('contentMarkdown') ? l$contentMarkdown : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('summary') ? l$summary : const {},
    ]);
  }
}

abstract class CopyWith$Input$TestimonialUpdateInput<TRes> {
  factory CopyWith$Input$TestimonialUpdateInput(
    Input$TestimonialUpdateInput instance,
    TRes Function(Input$TestimonialUpdateInput) then,
  ) = _CopyWithImpl$Input$TestimonialUpdateInput;

  factory CopyWith$Input$TestimonialUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TestimonialUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  });
}

class _CopyWithImpl$Input$TestimonialUpdateInput<TRes>
    implements CopyWith$Input$TestimonialUpdateInput<TRes> {
  _CopyWithImpl$Input$TestimonialUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TestimonialUpdateInput _instance;

  final TRes Function(Input$TestimonialUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? name = _undefined,
    Object? role = _undefined,
    Object? contentMarkdown = _undefined,
    Object? avatar = _undefined,
    Object? summary = _undefined,
  }) =>
      _then(Input$TestimonialUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (name != _undefined) 'name': (name as String?),
        if (role != _undefined) 'role': (role as String?),
        if (contentMarkdown != _undefined)
          'contentMarkdown': (contentMarkdown as String?),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (summary != _undefined) 'summary': (summary as String?),
      }));
}

class _CopyWithStubImpl$Input$TestimonialUpdateInput<TRes>
    implements CopyWith$Input$TestimonialUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TestimonialUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? name,
    String? role,
    String? contentMarkdown,
    String? avatar,
    String? summary,
  }) =>
      _res;
}

class Input$TimeFilter {
  factory Input$TimeFilter({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      Input$TimeFilter._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
      });

  Input$TimeFilter._(this._$data);

  factory Input$TimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : DateTime.parse((l$eq as String));
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] =
          l$gt == null ? null : DateTime.parse((l$gt as String));
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] =
          l$gte == null ? null : DateTime.parse((l$gte as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] =
          l$lt == null ? null : DateTime.parse((l$lt as String));
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] =
          l$lte == null ? null : DateTime.parse((l$lte as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : DateTime.parse((l$neq as String));
    }
    return Input$TimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get eq => (_$data['eq'] as DateTime?);

  DateTime? get gt => (_$data['gt'] as DateTime?);

  DateTime? get gte => (_$data['gte'] as DateTime?);

  List<DateTime>? get $in => (_$data['in'] as List<DateTime>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  DateTime? get lt => (_$data['lt'] as DateTime?);

  DateTime? get lte => (_$data['lte'] as DateTime?);

  DateTime? get neq => (_$data['neq'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq?.toIso8601String();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt?.toIso8601String();
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte?.toIso8601String();
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e.toIso8601String()).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt?.toIso8601String();
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte?.toIso8601String();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$TimeFilter<Input$TimeFilter> get copyWith =>
      CopyWith$Input$TimeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$$is = $is;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$TimeFilter<TRes> {
  factory CopyWith$Input$TimeFilter(
    Input$TimeFilter instance,
    TRes Function(Input$TimeFilter) then,
  ) = _CopyWithImpl$Input$TimeFilter;

  factory CopyWith$Input$TimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TimeFilter;

  TRes call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  });
}

class _CopyWithImpl$Input$TimeFilter<TRes>
    implements CopyWith$Input$TimeFilter<TRes> {
  _CopyWithImpl$Input$TimeFilter(
    this._instance,
    this._then,
  );

  final Input$TimeFilter _instance;

  final TRes Function(Input$TimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$TimeFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as DateTime?),
        if (gt != _undefined) 'gt': (gt as DateTime?),
        if (gte != _undefined) 'gte': (gte as DateTime?),
        if ($in != _undefined) 'in': ($in as List<DateTime>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (lt != _undefined) 'lt': (lt as DateTime?),
        if (lte != _undefined) 'lte': (lte as DateTime?),
        if (neq != _undefined) 'neq': (neq as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$TimeFilter<TRes>
    implements CopyWith$Input$TimeFilter<TRes> {
  _CopyWithStubImpl$Input$TimeFilter(this._res);

  TRes _res;

  call({
    DateTime? eq,
    DateTime? gt,
    DateTime? gte,
    List<DateTime>? $in,
    Enum$FilterIs? $is,
    DateTime? lt,
    DateTime? lte,
    DateTime? neq,
  }) =>
      _res;
}

class Input$ToolFilter {
  factory Input$ToolFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? toolTypeId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ToolFilter>? and,
    List<Input$ToolFilter>? or,
    Input$ToolFilter? not,
  }) =>
      Input$ToolFilter._({
        if (id != null) r'id': id,
        if (toolTypeId != null) r'toolTypeId': toolTypeId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ToolFilter._(this._$data);

  factory Input$ToolFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('toolTypeId')) {
      final l$toolTypeId = data['toolTypeId'];
      result$data['toolTypeId'] = l$toolTypeId == null
          ? null
          : Input$UUIDFilter.fromJson((l$toolTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : Input$UUIDFilter.fromJson((l$ownerId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ToolFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ToolFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ToolFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get toolTypeId =>
      (_$data['toolTypeId'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$UUIDFilter? get ownerId => (_$data['ownerId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ToolFilter>? get and => (_$data['and'] as List<Input$ToolFilter>?);

  List<Input$ToolFilter>? get or => (_$data['or'] as List<Input$ToolFilter>?);

  Input$ToolFilter? get not => (_$data['not'] as Input$ToolFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('toolTypeId')) {
      final l$toolTypeId = toolTypeId;
      result$data['toolTypeId'] = l$toolTypeId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ToolFilter<Input$ToolFilter> get copyWith =>
      CopyWith$Input$ToolFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$toolTypeId = toolTypeId;
    final lOther$toolTypeId = other.toolTypeId;
    if (_$data.containsKey('toolTypeId') !=
        other._$data.containsKey('toolTypeId')) {
      return false;
    }
    if (l$toolTypeId != lOther$toolTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$toolTypeId = toolTypeId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('toolTypeId') ? l$toolTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolFilter<TRes> {
  factory CopyWith$Input$ToolFilter(
    Input$ToolFilter instance,
    TRes Function(Input$ToolFilter) then,
  ) = _CopyWithImpl$Input$ToolFilter;

  factory CopyWith$Input$ToolFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? toolTypeId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ToolFilter>? and,
    List<Input$ToolFilter>? or,
    Input$ToolFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get toolTypeId;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$UUIDFilter<TRes> get ownerId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ToolFilter>? Function(
              Iterable<CopyWith$Input$ToolFilter<Input$ToolFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ToolFilter>? Function(
              Iterable<CopyWith$Input$ToolFilter<Input$ToolFilter>>?)
          _fn);
  CopyWith$Input$ToolFilter<TRes> get not;
}

class _CopyWithImpl$Input$ToolFilter<TRes>
    implements CopyWith$Input$ToolFilter<TRes> {
  _CopyWithImpl$Input$ToolFilter(
    this._instance,
    this._then,
  );

  final Input$ToolFilter _instance;

  final TRes Function(Input$ToolFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? toolTypeId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ToolFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (toolTypeId != _undefined)
          'toolTypeId': (toolTypeId as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (ownerId != _undefined) 'ownerId': (ownerId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ToolFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ToolFilter>?),
        if (not != _undefined) 'not': (not as Input$ToolFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get toolTypeId {
    final local$toolTypeId = _instance.toolTypeId;
    return local$toolTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$toolTypeId, (e) => call(toolTypeId: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get ownerId {
    final local$ownerId = _instance.ownerId;
    return local$ownerId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$ownerId, (e) => call(ownerId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ToolFilter>? Function(
                  Iterable<CopyWith$Input$ToolFilter<Input$ToolFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ToolFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ToolFilter>? Function(
                  Iterable<CopyWith$Input$ToolFilter<Input$ToolFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ToolFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ToolFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ToolFilter.stub(_then(_instance))
        : CopyWith$Input$ToolFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ToolFilter<TRes>
    implements CopyWith$Input$ToolFilter<TRes> {
  _CopyWithStubImpl$Input$ToolFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? toolTypeId,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$UUIDFilter? ownerId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$ToolFilter>? and,
    List<Input$ToolFilter>? or,
    Input$ToolFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get toolTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get ownerId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ToolFilter<TRes> get not =>
      CopyWith$Input$ToolFilter.stub(_res);
}

class Input$ToolInsertInput {
  factory Input$ToolInsertInput({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$ToolInsertInput._({
        if (id != null) r'id': id,
        if (toolTypeId != null) r'toolTypeId': toolTypeId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (data != null) r'data': data,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ToolInsertInput._(this._$data);

  factory Input$ToolInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('toolTypeId')) {
      final l$toolTypeId = data['toolTypeId'];
      result$data['toolTypeId'] = (l$toolTypeId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$ToolInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get toolTypeId => (_$data['toolTypeId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('toolTypeId')) {
      final l$toolTypeId = toolTypeId;
      result$data['toolTypeId'] = l$toolTypeId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ToolInsertInput<Input$ToolInsertInput> get copyWith =>
      CopyWith$Input$ToolInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$toolTypeId = toolTypeId;
    final lOther$toolTypeId = other.toolTypeId;
    if (_$data.containsKey('toolTypeId') !=
        other._$data.containsKey('toolTypeId')) {
      return false;
    }
    if (l$toolTypeId != lOther$toolTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$toolTypeId = toolTypeId;
    final l$name = name;
    final l$key = key;
    final l$data = data;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('toolTypeId') ? l$toolTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolInsertInput<TRes> {
  factory CopyWith$Input$ToolInsertInput(
    Input$ToolInsertInput instance,
    TRes Function(Input$ToolInsertInput) then,
  ) = _CopyWithImpl$Input$ToolInsertInput;

  factory CopyWith$Input$ToolInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolInsertInput;

  TRes call({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$ToolInsertInput<TRes>
    implements CopyWith$Input$ToolInsertInput<TRes> {
  _CopyWithImpl$Input$ToolInsertInput(
    this._instance,
    this._then,
  );

  final Input$ToolInsertInput _instance;

  final TRes Function(Input$ToolInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? toolTypeId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? data = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ToolInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (toolTypeId != _undefined) 'toolTypeId': (toolTypeId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ToolInsertInput<TRes>
    implements CopyWith$Input$ToolInsertInput<TRes> {
  _CopyWithStubImpl$Input$ToolInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$ToolOrderBy {
  factory Input$ToolOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? toolTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$ToolOrderBy._({
        if (id != null) r'id': id,
        if (toolTypeId != null) r'toolTypeId': toolTypeId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ToolOrderBy._(this._$data);

  factory Input$ToolOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('toolTypeId')) {
      final l$toolTypeId = data['toolTypeId'];
      result$data['toolTypeId'] = l$toolTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$toolTypeId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = l$ownerId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$ownerId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$ToolOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get toolTypeId =>
      (_$data['toolTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get ownerId =>
      (_$data['ownerId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('toolTypeId')) {
      final l$toolTypeId = toolTypeId;
      result$data['toolTypeId'] = l$toolTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$toolTypeId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] =
          l$ownerId == null ? null : toJson$Enum$OrderByDirection(l$ownerId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ToolOrderBy<Input$ToolOrderBy> get copyWith =>
      CopyWith$Input$ToolOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$toolTypeId = toolTypeId;
    final lOther$toolTypeId = other.toolTypeId;
    if (_$data.containsKey('toolTypeId') !=
        other._$data.containsKey('toolTypeId')) {
      return false;
    }
    if (l$toolTypeId != lOther$toolTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$toolTypeId = toolTypeId;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('toolTypeId') ? l$toolTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolOrderBy<TRes> {
  factory CopyWith$Input$ToolOrderBy(
    Input$ToolOrderBy instance,
    TRes Function(Input$ToolOrderBy) then,
  ) = _CopyWithImpl$Input$ToolOrderBy;

  factory CopyWith$Input$ToolOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? toolTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$ToolOrderBy<TRes>
    implements CopyWith$Input$ToolOrderBy<TRes> {
  _CopyWithImpl$Input$ToolOrderBy(
    this._instance,
    this._then,
  );

  final Input$ToolOrderBy _instance;

  final TRes Function(Input$ToolOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? toolTypeId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ToolOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (toolTypeId != _undefined)
          'toolTypeId': (toolTypeId as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (ownerId != _undefined)
          'ownerId': (ownerId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ToolOrderBy<TRes>
    implements CopyWith$Input$ToolOrderBy<TRes> {
  _CopyWithStubImpl$Input$ToolOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? toolTypeId,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? ownerId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$ToolTypeFilter {
  factory Input$ToolTypeFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ToolTypeFilter>? and,
    List<Input$ToolTypeFilter>? or,
    Input$ToolTypeFilter? not,
  }) =>
      Input$ToolTypeFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$ToolTypeFilter._(this._$data);

  factory Input$ToolTypeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : Input$StringFilter.fromJson(
              (l$shortDescription as Map<String, dynamic>));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : Input$StringFilter.fromJson(
              (l$longDescriptionMarkdown as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$ToolTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$ToolTypeFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$ToolTypeFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$ToolTypeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get shortDescription =>
      (_$data['shortDescription'] as Input$StringFilter?);

  Input$StringFilter? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$ToolTypeFilter>? get and =>
      (_$data['and'] as List<Input$ToolTypeFilter>?);

  List<Input$ToolTypeFilter>? get or =>
      (_$data['or'] as List<Input$ToolTypeFilter>?);

  Input$ToolTypeFilter? get not => (_$data['not'] as Input$ToolTypeFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription?.toJson();
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] =
          l$longDescriptionMarkdown?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ToolTypeFilter<Input$ToolTypeFilter> get copyWith =>
      CopyWith$Input$ToolTypeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolTypeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolTypeFilter<TRes> {
  factory CopyWith$Input$ToolTypeFilter(
    Input$ToolTypeFilter instance,
    TRes Function(Input$ToolTypeFilter) then,
  ) = _CopyWithImpl$Input$ToolTypeFilter;

  factory CopyWith$Input$ToolTypeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolTypeFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ToolTypeFilter>? and,
    List<Input$ToolTypeFilter>? or,
    Input$ToolTypeFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get shortDescription;
  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$ToolTypeFilter>? Function(
              Iterable<CopyWith$Input$ToolTypeFilter<Input$ToolTypeFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$ToolTypeFilter>? Function(
              Iterable<CopyWith$Input$ToolTypeFilter<Input$ToolTypeFilter>>?)
          _fn);
  CopyWith$Input$ToolTypeFilter<TRes> get not;
}

class _CopyWithImpl$Input$ToolTypeFilter<TRes>
    implements CopyWith$Input$ToolTypeFilter<TRes> {
  _CopyWithImpl$Input$ToolTypeFilter(
    this._instance,
    this._then,
  );

  final Input$ToolTypeFilter _instance;

  final TRes Function(Input$ToolTypeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$ToolTypeFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Input$StringFilter?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$ToolTypeFilter>?),
        if (or != _undefined) 'or': (or as List<Input$ToolTypeFilter>?),
        if (not != _undefined) 'not': (not as Input$ToolTypeFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get shortDescription {
    final local$shortDescription = _instance.shortDescription;
    return local$shortDescription == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$shortDescription, (e) => call(shortDescription: e));
  }

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown {
    final local$longDescriptionMarkdown = _instance.longDescriptionMarkdown;
    return local$longDescriptionMarkdown == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$longDescriptionMarkdown,
            (e) => call(longDescriptionMarkdown: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$ToolTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ToolTypeFilter<Input$ToolTypeFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ToolTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$ToolTypeFilter>? Function(
                  Iterable<
                      CopyWith$Input$ToolTypeFilter<Input$ToolTypeFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ToolTypeFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$ToolTypeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$ToolTypeFilter.stub(_then(_instance))
        : CopyWith$Input$ToolTypeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$ToolTypeFilter<TRes>
    implements CopyWith$Input$ToolTypeFilter<TRes> {
  _CopyWithStubImpl$Input$ToolTypeFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? shortDescription,
    Input$StringFilter? longDescriptionMarkdown,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$ToolTypeFilter>? and,
    List<Input$ToolTypeFilter>? or,
    Input$ToolTypeFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get shortDescription =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get longDescriptionMarkdown =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ToolTypeFilter<TRes> get not =>
      CopyWith$Input$ToolTypeFilter.stub(_res);
}

class Input$ToolTypeInsertInput {
  factory Input$ToolTypeInsertInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      Input$ToolTypeInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ToolTypeInsertInput._(this._$data);

  factory Input$ToolTypeInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ToolTypeInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ToolTypeInsertInput<Input$ToolTypeInsertInput> get copyWith =>
      CopyWith$Input$ToolTypeInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolTypeInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolTypeInsertInput<TRes> {
  factory CopyWith$Input$ToolTypeInsertInput(
    Input$ToolTypeInsertInput instance,
    TRes Function(Input$ToolTypeInsertInput) then,
  ) = _CopyWithImpl$Input$ToolTypeInsertInput;

  factory CopyWith$Input$ToolTypeInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolTypeInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ToolTypeInsertInput<TRes>
    implements CopyWith$Input$ToolTypeInsertInput<TRes> {
  _CopyWithImpl$Input$ToolTypeInsertInput(
    this._instance,
    this._then,
  );

  final Input$ToolTypeInsertInput _instance;

  final TRes Function(Input$ToolTypeInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ToolTypeInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ToolTypeInsertInput<TRes>
    implements CopyWith$Input$ToolTypeInsertInput<TRes> {
  _CopyWithStubImpl$Input$ToolTypeInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ToolTypeOrderBy {
  factory Input$ToolTypeOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$ToolTypeOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ToolTypeOrderBy._(this._$data);

  factory Input$ToolTypeOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : fromJson$Enum$OrderByDirection((l$shortDescription as String));
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : fromJson$Enum$OrderByDirection(
              (l$longDescriptionMarkdown as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$ToolTypeOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get shortDescription =>
      (_$data['shortDescription'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription == null
          ? null
          : toJson$Enum$OrderByDirection(l$shortDescription);
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown == null
          ? null
          : toJson$Enum$OrderByDirection(l$longDescriptionMarkdown);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$ToolTypeOrderBy<Input$ToolTypeOrderBy> get copyWith =>
      CopyWith$Input$ToolTypeOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolTypeOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolTypeOrderBy<TRes> {
  factory CopyWith$Input$ToolTypeOrderBy(
    Input$ToolTypeOrderBy instance,
    TRes Function(Input$ToolTypeOrderBy) then,
  ) = _CopyWithImpl$Input$ToolTypeOrderBy;

  factory CopyWith$Input$ToolTypeOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolTypeOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$ToolTypeOrderBy<TRes>
    implements CopyWith$Input$ToolTypeOrderBy<TRes> {
  _CopyWithImpl$Input$ToolTypeOrderBy(
    this._instance,
    this._then,
  );

  final Input$ToolTypeOrderBy _instance;

  final TRes Function(Input$ToolTypeOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ToolTypeOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as Enum$OrderByDirection?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown':
              (longDescriptionMarkdown as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$ToolTypeOrderBy<TRes>
    implements CopyWith$Input$ToolTypeOrderBy<TRes> {
  _CopyWithStubImpl$Input$ToolTypeOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? shortDescription,
    Enum$OrderByDirection? longDescriptionMarkdown,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$ToolTypeUpdateInput {
  factory Input$ToolTypeUpdateInput({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      Input$ToolTypeUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (schema != null) r'schema': schema,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$ToolTypeUpdateInput._(this._$data);

  factory Input$ToolTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('schema')) {
      final l$schema = data['schema'];
      result$data['schema'] =
          l$schema == null ? null : jsonFieldFromJson(l$schema);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$ToolTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get schema =>
      (_$data['schema'] as Map<String, dynamic>?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('schema')) {
      final l$schema = schema;
      result$data['schema'] =
          l$schema == null ? null : jsonFieldToJson(l$schema);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ToolTypeUpdateInput<Input$ToolTypeUpdateInput> get copyWith =>
      CopyWith$Input$ToolTypeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$schema = schema;
    final lOther$schema = other.schema;
    if (_$data.containsKey('schema') != other._$data.containsKey('schema')) {
      return false;
    }
    if (l$schema != lOther$schema) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$schema = schema;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('schema') ? l$schema : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolTypeUpdateInput<TRes> {
  factory CopyWith$Input$ToolTypeUpdateInput(
    Input$ToolTypeUpdateInput instance,
    TRes Function(Input$ToolTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$ToolTypeUpdateInput;

  factory CopyWith$Input$ToolTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolTypeUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$ToolTypeUpdateInput<TRes>
    implements CopyWith$Input$ToolTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$ToolTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ToolTypeUpdateInput _instance;

  final TRes Function(Input$ToolTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? schema = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$ToolTypeUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (schema != _undefined) 'schema': (schema as Map<String, dynamic>?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ToolTypeUpdateInput<TRes>
    implements CopyWith$Input$ToolTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ToolTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    Map<String, dynamic>? schema,
    String? shortDescription,
    String? longDescriptionMarkdown,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$ToolUpdateInput {
  factory Input$ToolUpdateInput({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$ToolUpdateInput._({
        if (id != null) r'id': id,
        if (toolTypeId != null) r'toolTypeId': toolTypeId,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (data != null) r'data': data,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (longDescriptionMarkdown != null)
          r'longDescriptionMarkdown': longDescriptionMarkdown,
        if (ownerId != null) r'ownerId': ownerId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ToolUpdateInput._(this._$data);

  factory Input$ToolUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('toolTypeId')) {
      final l$toolTypeId = data['toolTypeId'];
      result$data['toolTypeId'] = (l$toolTypeId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = data['longDescriptionMarkdown'];
      result$data['longDescriptionMarkdown'] =
          (l$longDescriptionMarkdown as String?);
    }
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$ToolUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get toolTypeId => (_$data['toolTypeId'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get longDescriptionMarkdown =>
      (_$data['longDescriptionMarkdown'] as String?);

  String? get ownerId => (_$data['ownerId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('toolTypeId')) {
      final l$toolTypeId = toolTypeId;
      result$data['toolTypeId'] = l$toolTypeId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('longDescriptionMarkdown')) {
      final l$longDescriptionMarkdown = longDescriptionMarkdown;
      result$data['longDescriptionMarkdown'] = l$longDescriptionMarkdown;
    }
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$ToolUpdateInput<Input$ToolUpdateInput> get copyWith =>
      CopyWith$Input$ToolUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ToolUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$toolTypeId = toolTypeId;
    final lOther$toolTypeId = other.toolTypeId;
    if (_$data.containsKey('toolTypeId') !=
        other._$data.containsKey('toolTypeId')) {
      return false;
    }
    if (l$toolTypeId != lOther$toolTypeId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final lOther$longDescriptionMarkdown = other.longDescriptionMarkdown;
    if (_$data.containsKey('longDescriptionMarkdown') !=
        other._$data.containsKey('longDescriptionMarkdown')) {
      return false;
    }
    if (l$longDescriptionMarkdown != lOther$longDescriptionMarkdown) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$toolTypeId = toolTypeId;
    final l$name = name;
    final l$key = key;
    final l$data = data;
    final l$shortDescription = shortDescription;
    final l$longDescriptionMarkdown = longDescriptionMarkdown;
    final l$ownerId = ownerId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('toolTypeId') ? l$toolTypeId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('longDescriptionMarkdown')
          ? l$longDescriptionMarkdown
          : const {},
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ToolUpdateInput<TRes> {
  factory CopyWith$Input$ToolUpdateInput(
    Input$ToolUpdateInput instance,
    TRes Function(Input$ToolUpdateInput) then,
  ) = _CopyWithImpl$Input$ToolUpdateInput;

  factory CopyWith$Input$ToolUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ToolUpdateInput;

  TRes call({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$ToolUpdateInput<TRes>
    implements CopyWith$Input$ToolUpdateInput<TRes> {
  _CopyWithImpl$Input$ToolUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ToolUpdateInput _instance;

  final TRes Function(Input$ToolUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? toolTypeId = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? data = _undefined,
    Object? shortDescription = _undefined,
    Object? longDescriptionMarkdown = _undefined,
    Object? ownerId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ToolUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (toolTypeId != _undefined) 'toolTypeId': (toolTypeId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (longDescriptionMarkdown != _undefined)
          'longDescriptionMarkdown': (longDescriptionMarkdown as String?),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$ToolUpdateInput<TRes>
    implements CopyWith$Input$ToolUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ToolUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? toolTypeId,
    String? name,
    String? key,
    Map<String, dynamic>? data,
    String? shortDescription,
    String? longDescriptionMarkdown,
    String? ownerId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$UserAnswerChoiceFilter {
  factory Input$UserAnswerChoiceFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? questionId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? choiceText,
    Input$IDFilter? nodeId,
    List<Input$UserAnswerChoiceFilter>? and,
    List<Input$UserAnswerChoiceFilter>? or,
    Input$UserAnswerChoiceFilter? not,
  }) =>
      Input$UserAnswerChoiceFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (questionId != null) r'questionId': questionId,
        if (createdAt != null) r'createdAt': createdAt,
        if (choiceText != null) r'choiceText': choiceText,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserAnswerChoiceFilter._(this._$data);

  factory Input$UserAnswerChoiceFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = l$choiceText == null
          ? null
          : Input$StringFilter.fromJson((l$choiceText as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserAnswerChoiceFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserAnswerChoiceFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserAnswerChoiceFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$UserAnswerChoiceFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get choiceText =>
      (_$data['choiceText'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserAnswerChoiceFilter>? get and =>
      (_$data['and'] as List<Input$UserAnswerChoiceFilter>?);

  List<Input$UserAnswerChoiceFilter>? get or =>
      (_$data['or'] as List<Input$UserAnswerChoiceFilter>?);

  Input$UserAnswerChoiceFilter? get not =>
      (_$data['not'] as Input$UserAnswerChoiceFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserAnswerChoiceFilter<Input$UserAnswerChoiceFilter>
      get copyWith => CopyWith$Input$UserAnswerChoiceFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserAnswerChoiceFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$choiceText = choiceText;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserAnswerChoiceFilter<TRes> {
  factory CopyWith$Input$UserAnswerChoiceFilter(
    Input$UserAnswerChoiceFilter instance,
    TRes Function(Input$UserAnswerChoiceFilter) then,
  ) = _CopyWithImpl$Input$UserAnswerChoiceFilter;

  factory CopyWith$Input$UserAnswerChoiceFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserAnswerChoiceFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? questionId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? choiceText,
    Input$IDFilter? nodeId,
    List<Input$UserAnswerChoiceFilter>? and,
    List<Input$UserAnswerChoiceFilter>? or,
    Input$UserAnswerChoiceFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get choiceText;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserAnswerChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$UserAnswerChoiceFilter<
                      Input$UserAnswerChoiceFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserAnswerChoiceFilter>? Function(
              Iterable<
                  CopyWith$Input$UserAnswerChoiceFilter<
                      Input$UserAnswerChoiceFilter>>?)
          _fn);
  CopyWith$Input$UserAnswerChoiceFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserAnswerChoiceFilter<TRes>
    implements CopyWith$Input$UserAnswerChoiceFilter<TRes> {
  _CopyWithImpl$Input$UserAnswerChoiceFilter(
    this._instance,
    this._then,
  );

  final Input$UserAnswerChoiceFilter _instance;

  final TRes Function(Input$UserAnswerChoiceFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? questionId = _undefined,
    Object? createdAt = _undefined,
    Object? choiceText = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserAnswerChoiceFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (choiceText != _undefined)
          'choiceText': (choiceText as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$UserAnswerChoiceFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserAnswerChoiceFilter>?),
        if (not != _undefined) 'not': (not as Input$UserAnswerChoiceFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get choiceText {
    final local$choiceText = _instance.choiceText;
    return local$choiceText == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$choiceText, (e) => call(choiceText: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserAnswerChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserAnswerChoiceFilter<
                          Input$UserAnswerChoiceFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$UserAnswerChoiceFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$UserAnswerChoiceFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserAnswerChoiceFilter<
                          Input$UserAnswerChoiceFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$UserAnswerChoiceFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UserAnswerChoiceFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserAnswerChoiceFilter.stub(_then(_instance))
        : CopyWith$Input$UserAnswerChoiceFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserAnswerChoiceFilter<TRes>
    implements CopyWith$Input$UserAnswerChoiceFilter<TRes> {
  _CopyWithStubImpl$Input$UserAnswerChoiceFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? questionId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? choiceText,
    Input$IDFilter? nodeId,
    List<Input$UserAnswerChoiceFilter>? and,
    List<Input$UserAnswerChoiceFilter>? or,
    Input$UserAnswerChoiceFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get choiceText =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserAnswerChoiceFilter<TRes> get not =>
      CopyWith$Input$UserAnswerChoiceFilter.stub(_res);
}

class Input$UserAnswerChoiceInsertInput {
  factory Input$UserAnswerChoiceInsertInput({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  }) =>
      Input$UserAnswerChoiceInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (questionId != null) r'questionId': questionId,
        if (createdAt != null) r'createdAt': createdAt,
        if (choiceText != null) r'choiceText': choiceText,
        if (metadata != null) r'metadata': metadata,
      });

  Input$UserAnswerChoiceInsertInput._(this._$data);

  factory Input$UserAnswerChoiceInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = (l$choiceText as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    return Input$UserAnswerChoiceInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get choiceText => (_$data['choiceText'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    return result$data;
  }

  CopyWith$Input$UserAnswerChoiceInsertInput<Input$UserAnswerChoiceInsertInput>
      get copyWith => CopyWith$Input$UserAnswerChoiceInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserAnswerChoiceInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$choiceText = choiceText;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserAnswerChoiceInsertInput<TRes> {
  factory CopyWith$Input$UserAnswerChoiceInsertInput(
    Input$UserAnswerChoiceInsertInput instance,
    TRes Function(Input$UserAnswerChoiceInsertInput) then,
  ) = _CopyWithImpl$Input$UserAnswerChoiceInsertInput;

  factory CopyWith$Input$UserAnswerChoiceInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserAnswerChoiceInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  });
}

class _CopyWithImpl$Input$UserAnswerChoiceInsertInput<TRes>
    implements CopyWith$Input$UserAnswerChoiceInsertInput<TRes> {
  _CopyWithImpl$Input$UserAnswerChoiceInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserAnswerChoiceInsertInput _instance;

  final TRes Function(Input$UserAnswerChoiceInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? questionId = _undefined,
    Object? createdAt = _undefined,
    Object? choiceText = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$UserAnswerChoiceInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (choiceText != _undefined) 'choiceText': (choiceText as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserAnswerChoiceInsertInput<TRes>
    implements CopyWith$Input$UserAnswerChoiceInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserAnswerChoiceInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  }) =>
      _res;
}

class Input$UserAnswerChoiceOrderBy {
  factory Input$UserAnswerChoiceOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? choiceText,
  }) =>
      Input$UserAnswerChoiceOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (questionId != null) r'questionId': questionId,
        if (createdAt != null) r'createdAt': createdAt,
        if (choiceText != null) r'choiceText': choiceText,
      });

  Input$UserAnswerChoiceOrderBy._(this._$data);

  factory Input$UserAnswerChoiceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = l$choiceText == null
          ? null
          : fromJson$Enum$OrderByDirection((l$choiceText as String));
    }
    return Input$UserAnswerChoiceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get choiceText =>
      (_$data['choiceText'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText == null
          ? null
          : toJson$Enum$OrderByDirection(l$choiceText);
    }
    return result$data;
  }

  CopyWith$Input$UserAnswerChoiceOrderBy<Input$UserAnswerChoiceOrderBy>
      get copyWith => CopyWith$Input$UserAnswerChoiceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserAnswerChoiceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$choiceText = choiceText;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserAnswerChoiceOrderBy<TRes> {
  factory CopyWith$Input$UserAnswerChoiceOrderBy(
    Input$UserAnswerChoiceOrderBy instance,
    TRes Function(Input$UserAnswerChoiceOrderBy) then,
  ) = _CopyWithImpl$Input$UserAnswerChoiceOrderBy;

  factory CopyWith$Input$UserAnswerChoiceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserAnswerChoiceOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? choiceText,
  });
}

class _CopyWithImpl$Input$UserAnswerChoiceOrderBy<TRes>
    implements CopyWith$Input$UserAnswerChoiceOrderBy<TRes> {
  _CopyWithImpl$Input$UserAnswerChoiceOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserAnswerChoiceOrderBy _instance;

  final TRes Function(Input$UserAnswerChoiceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? questionId = _undefined,
    Object? createdAt = _undefined,
    Object? choiceText = _undefined,
  }) =>
      _then(Input$UserAnswerChoiceOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (choiceText != _undefined)
          'choiceText': (choiceText as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserAnswerChoiceOrderBy<TRes>
    implements CopyWith$Input$UserAnswerChoiceOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserAnswerChoiceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? choiceText,
  }) =>
      _res;
}

class Input$UserAnswerChoiceUpdateInput {
  factory Input$UserAnswerChoiceUpdateInput({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  }) =>
      Input$UserAnswerChoiceUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (questionId != null) r'questionId': questionId,
        if (createdAt != null) r'createdAt': createdAt,
        if (choiceText != null) r'choiceText': choiceText,
        if (metadata != null) r'metadata': metadata,
      });

  Input$UserAnswerChoiceUpdateInput._(this._$data);

  factory Input$UserAnswerChoiceUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('choiceText')) {
      final l$choiceText = data['choiceText'];
      result$data['choiceText'] = (l$choiceText as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldFromJson(l$metadata);
    }
    return Input$UserAnswerChoiceUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get choiceText => (_$data['choiceText'] as String?);

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('choiceText')) {
      final l$choiceText = choiceText;
      result$data['choiceText'] = l$choiceText;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : jsonFieldToJson(l$metadata);
    }
    return result$data;
  }

  CopyWith$Input$UserAnswerChoiceUpdateInput<Input$UserAnswerChoiceUpdateInput>
      get copyWith => CopyWith$Input$UserAnswerChoiceUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserAnswerChoiceUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$choiceText = choiceText;
    final lOther$choiceText = other.choiceText;
    if (_$data.containsKey('choiceText') !=
        other._$data.containsKey('choiceText')) {
      return false;
    }
    if (l$choiceText != lOther$choiceText) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$choiceText = choiceText;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('choiceText') ? l$choiceText : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserAnswerChoiceUpdateInput<TRes> {
  factory CopyWith$Input$UserAnswerChoiceUpdateInput(
    Input$UserAnswerChoiceUpdateInput instance,
    TRes Function(Input$UserAnswerChoiceUpdateInput) then,
  ) = _CopyWithImpl$Input$UserAnswerChoiceUpdateInput;

  factory CopyWith$Input$UserAnswerChoiceUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserAnswerChoiceUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  });
}

class _CopyWithImpl$Input$UserAnswerChoiceUpdateInput<TRes>
    implements CopyWith$Input$UserAnswerChoiceUpdateInput<TRes> {
  _CopyWithImpl$Input$UserAnswerChoiceUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserAnswerChoiceUpdateInput _instance;

  final TRes Function(Input$UserAnswerChoiceUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? questionId = _undefined,
    Object? createdAt = _undefined,
    Object? choiceText = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$UserAnswerChoiceUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (choiceText != _undefined) 'choiceText': (choiceText as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserAnswerChoiceUpdateInput<TRes>
    implements CopyWith$Input$UserAnswerChoiceUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserAnswerChoiceUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? questionId,
    DateTime? createdAt,
    String? choiceText,
    Map<String, dynamic>? metadata,
  }) =>
      _res;
}

class Input$UserFilter {
  factory Input$UserFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? email,
    Input$StringFilter? lastName,
    Input$StringFilter? firstName,
    Input$StringFilter? avatarUrl,
    Input$StringFilter? displayName,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? kratosId,
    Input$UUIDFilter? supabaseUserId,
    Input$IDFilter? nodeId,
    List<Input$UserFilter>? and,
    List<Input$UserFilter>? or,
    Input$UserFilter? not,
  }) =>
      Input$UserFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (email != null) r'email': email,
        if (lastName != null) r'lastName': lastName,
        if (firstName != null) r'firstName': firstName,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (displayName != null) r'displayName': displayName,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (kratosId != null) r'kratosId': kratosId,
        if (supabaseUserId != null) r'supabaseUserId': supabaseUserId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserFilter._(this._$data);

  factory Input$UserFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringFilter.fromJson((l$email as Map<String, dynamic>));
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = l$lastName == null
          ? null
          : Input$StringFilter.fromJson((l$lastName as Map<String, dynamic>));
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = l$firstName == null
          ? null
          : Input$StringFilter.fromJson((l$firstName as Map<String, dynamic>));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : Input$StringFilter.fromJson((l$avatarUrl as Map<String, dynamic>));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : Input$StringFilter.fromJson(
              (l$displayName as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('kratosId')) {
      final l$kratosId = data['kratosId'];
      result$data['kratosId'] = l$kratosId == null
          ? null
          : Input$UUIDFilter.fromJson((l$kratosId as Map<String, dynamic>));
    }
    if (data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = data['supabaseUserId'];
      result$data['supabaseUserId'] = l$supabaseUserId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$supabaseUserId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get email => (_$data['email'] as Input$StringFilter?);

  Input$StringFilter? get lastName =>
      (_$data['lastName'] as Input$StringFilter?);

  Input$StringFilter? get firstName =>
      (_$data['firstName'] as Input$StringFilter?);

  Input$StringFilter? get avatarUrl =>
      (_$data['avatarUrl'] as Input$StringFilter?);

  Input$StringFilter? get displayName =>
      (_$data['displayName'] as Input$StringFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get kratosId => (_$data['kratosId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get supabaseUserId =>
      (_$data['supabaseUserId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserFilter>? get and => (_$data['and'] as List<Input$UserFilter>?);

  List<Input$UserFilter>? get or => (_$data['or'] as List<Input$UserFilter>?);

  Input$UserFilter? get not => (_$data['not'] as Input$UserFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName?.toJson();
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName?.toJson();
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl?.toJson();
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('kratosId')) {
      final l$kratosId = kratosId;
      result$data['kratosId'] = l$kratosId?.toJson();
    }
    if (_$data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = supabaseUserId;
      result$data['supabaseUserId'] = l$supabaseUserId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserFilter<Input$UserFilter> get copyWith =>
      CopyWith$Input$UserFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$kratosId = kratosId;
    final lOther$kratosId = other.kratosId;
    if (_$data.containsKey('kratosId') !=
        other._$data.containsKey('kratosId')) {
      return false;
    }
    if (l$kratosId != lOther$kratosId) {
      return false;
    }
    final l$supabaseUserId = supabaseUserId;
    final lOther$supabaseUserId = other.supabaseUserId;
    if (_$data.containsKey('supabaseUserId') !=
        other._$data.containsKey('supabaseUserId')) {
      return false;
    }
    if (l$supabaseUserId != lOther$supabaseUserId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$email = email;
    final l$lastName = lastName;
    final l$firstName = firstName;
    final l$avatarUrl = avatarUrl;
    final l$displayName = displayName;
    final l$updatedAt = updatedAt;
    final l$kratosId = kratosId;
    final l$supabaseUserId = supabaseUserId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('kratosId') ? l$kratosId : const {},
      _$data.containsKey('supabaseUserId') ? l$supabaseUserId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFilter<TRes> {
  factory CopyWith$Input$UserFilter(
    Input$UserFilter instance,
    TRes Function(Input$UserFilter) then,
  ) = _CopyWithImpl$Input$UserFilter;

  factory CopyWith$Input$UserFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? email,
    Input$StringFilter? lastName,
    Input$StringFilter? firstName,
    Input$StringFilter? avatarUrl,
    Input$StringFilter? displayName,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? kratosId,
    Input$UUIDFilter? supabaseUserId,
    Input$IDFilter? nodeId,
    List<Input$UserFilter>? and,
    List<Input$UserFilter>? or,
    Input$UserFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get email;
  CopyWith$Input$StringFilter<TRes> get lastName;
  CopyWith$Input$StringFilter<TRes> get firstName;
  CopyWith$Input$StringFilter<TRes> get avatarUrl;
  CopyWith$Input$StringFilter<TRes> get displayName;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$UUIDFilter<TRes> get kratosId;
  CopyWith$Input$UUIDFilter<TRes> get supabaseUserId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserFilter>? Function(
              Iterable<CopyWith$Input$UserFilter<Input$UserFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserFilter>? Function(
              Iterable<CopyWith$Input$UserFilter<Input$UserFilter>>?)
          _fn);
  CopyWith$Input$UserFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserFilter<TRes>
    implements CopyWith$Input$UserFilter<TRes> {
  _CopyWithImpl$Input$UserFilter(
    this._instance,
    this._then,
  );

  final Input$UserFilter _instance;

  final TRes Function(Input$UserFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? email = _undefined,
    Object? lastName = _undefined,
    Object? firstName = _undefined,
    Object? avatarUrl = _undefined,
    Object? displayName = _undefined,
    Object? updatedAt = _undefined,
    Object? kratosId = _undefined,
    Object? supabaseUserId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (email != _undefined) 'email': (email as Input$StringFilter?),
        if (lastName != _undefined)
          'lastName': (lastName as Input$StringFilter?),
        if (firstName != _undefined)
          'firstName': (firstName as Input$StringFilter?),
        if (avatarUrl != _undefined)
          'avatarUrl': (avatarUrl as Input$StringFilter?),
        if (displayName != _undefined)
          'displayName': (displayName as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (kratosId != _undefined) 'kratosId': (kratosId as Input$UUIDFilter?),
        if (supabaseUserId != _undefined)
          'supabaseUserId': (supabaseUserId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserFilter>?),
        if (not != _undefined) 'not': (not as Input$UserFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFilter<TRes> get lastName {
    final local$lastName = _instance.lastName;
    return local$lastName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$lastName, (e) => call(lastName: e));
  }

  CopyWith$Input$StringFilter<TRes> get firstName {
    final local$firstName = _instance.firstName;
    return local$firstName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$firstName, (e) => call(firstName: e));
  }

  CopyWith$Input$StringFilter<TRes> get avatarUrl {
    final local$avatarUrl = _instance.avatarUrl;
    return local$avatarUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$avatarUrl, (e) => call(avatarUrl: e));
  }

  CopyWith$Input$StringFilter<TRes> get displayName {
    final local$displayName = _instance.displayName;
    return local$displayName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$displayName, (e) => call(displayName: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get kratosId {
    final local$kratosId = _instance.kratosId;
    return local$kratosId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$kratosId, (e) => call(kratosId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get supabaseUserId {
    final local$supabaseUserId = _instance.supabaseUserId;
    return local$supabaseUserId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$supabaseUserId, (e) => call(supabaseUserId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserFilter>? Function(
                  Iterable<CopyWith$Input$UserFilter<Input$UserFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserFilter>? Function(
                  Iterable<CopyWith$Input$UserFilter<Input$UserFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserFilter.stub(_then(_instance))
        : CopyWith$Input$UserFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserFilter<TRes>
    implements CopyWith$Input$UserFilter<TRes> {
  _CopyWithStubImpl$Input$UserFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? email,
    Input$StringFilter? lastName,
    Input$StringFilter? firstName,
    Input$StringFilter? avatarUrl,
    Input$StringFilter? displayName,
    Input$DatetimeFilter? updatedAt,
    Input$UUIDFilter? kratosId,
    Input$UUIDFilter? supabaseUserId,
    Input$IDFilter? nodeId,
    List<Input$UserFilter>? and,
    List<Input$UserFilter>? or,
    Input$UserFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get email =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get lastName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get firstName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get avatarUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get displayName =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get kratosId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get supabaseUserId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserFilter<TRes> get not =>
      CopyWith$Input$UserFilter.stub(_res);
}

class Input$UserFormFilter {
  factory Input$UserFormFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserFormFilter>? and,
    List<Input$UserFormFilter>? or,
    Input$UserFormFilter? not,
  }) =>
      Input$UserFormFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserFormFilter._(this._$data);

  factory Input$UserFormFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : Input$UUIDFilter.fromJson((l$formId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$UserFormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$UserFormFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserFormFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserFormFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get formId => (_$data['formId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserFormFilter>? get and =>
      (_$data['and'] as List<Input$UserFormFilter>?);

  List<Input$UserFormFilter>? get or =>
      (_$data['or'] as List<Input$UserFormFilter>?);

  Input$UserFormFilter? get not => (_$data['not'] as Input$UserFormFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserFormFilter<Input$UserFormFilter> get copyWith =>
      CopyWith$Input$UserFormFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormFilter<TRes> {
  factory CopyWith$Input$UserFormFilter(
    Input$UserFormFilter instance,
    TRes Function(Input$UserFormFilter) then,
  ) = _CopyWithImpl$Input$UserFormFilter;

  factory CopyWith$Input$UserFormFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserFormFilter>? and,
    List<Input$UserFormFilter>? or,
    Input$UserFormFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get formId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserFormFilter>? Function(
              Iterable<CopyWith$Input$UserFormFilter<Input$UserFormFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserFormFilter>? Function(
              Iterable<CopyWith$Input$UserFormFilter<Input$UserFormFilter>>?)
          _fn);
  CopyWith$Input$UserFormFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserFormFilter<TRes>
    implements CopyWith$Input$UserFormFilter<TRes> {
  _CopyWithImpl$Input$UserFormFilter(
    this._instance,
    this._then,
  );

  final Input$UserFormFilter _instance;

  final TRes Function(Input$UserFormFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserFormFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (formId != _undefined) 'formId': (formId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserFormFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserFormFilter>?),
        if (not != _undefined) 'not': (not as Input$UserFormFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get formId {
    final local$formId = _instance.formId;
    return local$formId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$formId, (e) => call(formId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserFormFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserFormFilter<Input$UserFormFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserFormFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserFormFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserFormFilter<Input$UserFormFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserFormFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserFormFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserFormFilter.stub(_then(_instance))
        : CopyWith$Input$UserFormFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserFormFilter<TRes>
    implements CopyWith$Input$UserFormFilter<TRes> {
  _CopyWithStubImpl$Input$UserFormFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? formId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserFormFilter>? and,
    List<Input$UserFormFilter>? or,
    Input$UserFormFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get formId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserFormFilter<TRes> get not =>
      CopyWith$Input$UserFormFilter.stub(_res);
}

class Input$UserFormInsertInput {
  factory Input$UserFormInsertInput({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  }) =>
      Input$UserFormInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$UserFormInsertInput._(this._$data);

  factory Input$UserFormInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$UserFormInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get formId => (_$data['formId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserFormInsertInput<Input$UserFormInsertInput> get copyWith =>
      CopyWith$Input$UserFormInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormInsertInput<TRes> {
  factory CopyWith$Input$UserFormInsertInput(
    Input$UserFormInsertInput instance,
    TRes Function(Input$UserFormInsertInput) then,
  ) = _CopyWithImpl$Input$UserFormInsertInput;

  factory CopyWith$Input$UserFormInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$UserFormInsertInput<TRes>
    implements CopyWith$Input$UserFormInsertInput<TRes> {
  _CopyWithImpl$Input$UserFormInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserFormInsertInput _instance;

  final TRes Function(Input$UserFormInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$UserFormInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserFormInsertInput<TRes>
    implements CopyWith$Input$UserFormInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserFormInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$UserFormOrderBy {
  factory Input$UserFormOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$UserFormOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$UserFormOrderBy._(this._$data);

  factory Input$UserFormOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = l$formId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$formId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$UserFormOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get formId =>
      (_$data['formId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] =
          l$formId == null ? null : toJson$Enum$OrderByDirection(l$formId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$UserFormOrderBy<Input$UserFormOrderBy> get copyWith =>
      CopyWith$Input$UserFormOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormOrderBy<TRes> {
  factory CopyWith$Input$UserFormOrderBy(
    Input$UserFormOrderBy instance,
    TRes Function(Input$UserFormOrderBy) then,
  ) = _CopyWithImpl$Input$UserFormOrderBy;

  factory CopyWith$Input$UserFormOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$UserFormOrderBy<TRes>
    implements CopyWith$Input$UserFormOrderBy<TRes> {
  _CopyWithImpl$Input$UserFormOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserFormOrderBy _instance;

  final TRes Function(Input$UserFormOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$UserFormOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (formId != _undefined) 'formId': (formId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserFormOrderBy<TRes>
    implements CopyWith$Input$UserFormOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserFormOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? formId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$UserFormQuestionAnswerFilter {
  factory Input$UserFormQuestionAnswerFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userFormId,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? answerText,
    Input$IDFilter? nodeId,
    List<Input$UserFormQuestionAnswerFilter>? and,
    List<Input$UserFormQuestionAnswerFilter>? or,
    Input$UserFormQuestionAnswerFilter? not,
  }) =>
      Input$UserFormQuestionAnswerFilter._({
        if (id != null) r'id': id,
        if (userFormId != null) r'userFormId': userFormId,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
        if (answerText != null) r'answerText': answerText,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserFormQuestionAnswerFilter._(this._$data);

  factory Input$UserFormQuestionAnswerFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = l$userFormId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userFormId as Map<String, dynamic>));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : Input$UUIDFilter.fromJson((l$questionId as Map<String, dynamic>));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$answerChoiceId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = l$answerText == null
          ? null
          : Input$StringFilter.fromJson((l$answerText as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserFormQuestionAnswerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserFormQuestionAnswerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserFormQuestionAnswerFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$UserFormQuestionAnswerFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userFormId =>
      (_$data['userFormId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get questionId =>
      (_$data['questionId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get answerChoiceId =>
      (_$data['answerChoiceId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get answerText =>
      (_$data['answerText'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserFormQuestionAnswerFilter>? get and =>
      (_$data['and'] as List<Input$UserFormQuestionAnswerFilter>?);

  List<Input$UserFormQuestionAnswerFilter>? get or =>
      (_$data['or'] as List<Input$UserFormQuestionAnswerFilter>?);

  Input$UserFormQuestionAnswerFilter? get not =>
      (_$data['not'] as Input$UserFormQuestionAnswerFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId?.toJson();
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId?.toJson();
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserFormQuestionAnswerFilter<
          Input$UserFormQuestionAnswerFilter>
      get copyWith => CopyWith$Input$UserFormQuestionAnswerFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormQuestionAnswerFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userFormId = userFormId;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    final l$answerText = answerText;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormQuestionAnswerFilter<TRes> {
  factory CopyWith$Input$UserFormQuestionAnswerFilter(
    Input$UserFormQuestionAnswerFilter instance,
    TRes Function(Input$UserFormQuestionAnswerFilter) then,
  ) = _CopyWithImpl$Input$UserFormQuestionAnswerFilter;

  factory CopyWith$Input$UserFormQuestionAnswerFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormQuestionAnswerFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userFormId,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? answerText,
    Input$IDFilter? nodeId,
    List<Input$UserFormQuestionAnswerFilter>? and,
    List<Input$UserFormQuestionAnswerFilter>? or,
    Input$UserFormQuestionAnswerFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userFormId;
  CopyWith$Input$UUIDFilter<TRes> get questionId;
  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get answerText;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserFormQuestionAnswerFilter>? Function(
              Iterable<
                  CopyWith$Input$UserFormQuestionAnswerFilter<
                      Input$UserFormQuestionAnswerFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserFormQuestionAnswerFilter>? Function(
              Iterable<
                  CopyWith$Input$UserFormQuestionAnswerFilter<
                      Input$UserFormQuestionAnswerFilter>>?)
          _fn);
  CopyWith$Input$UserFormQuestionAnswerFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserFormQuestionAnswerFilter<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerFilter<TRes> {
  _CopyWithImpl$Input$UserFormQuestionAnswerFilter(
    this._instance,
    this._then,
  );

  final Input$UserFormQuestionAnswerFilter _instance;

  final TRes Function(Input$UserFormQuestionAnswerFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userFormId = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
    Object? answerText = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserFormQuestionAnswerFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userFormId != _undefined)
          'userFormId': (userFormId as Input$UUIDFilter?),
        if (questionId != _undefined)
          'questionId': (questionId as Input$UUIDFilter?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (answerText != _undefined)
          'answerText': (answerText as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$UserFormQuestionAnswerFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$UserFormQuestionAnswerFilter>?),
        if (not != _undefined)
          'not': (not as Input$UserFormQuestionAnswerFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userFormId {
    final local$userFormId = _instance.userFormId;
    return local$userFormId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$userFormId, (e) => call(userFormId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get questionId {
    final local$questionId = _instance.questionId;
    return local$questionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$questionId, (e) => call(questionId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId {
    final local$answerChoiceId = _instance.answerChoiceId;
    return local$answerChoiceId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$answerChoiceId, (e) => call(answerChoiceId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get answerText {
    final local$answerText = _instance.answerText;
    return local$answerText == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$answerText, (e) => call(answerText: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserFormQuestionAnswerFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserFormQuestionAnswerFilter<
                          Input$UserFormQuestionAnswerFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$UserFormQuestionAnswerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$UserFormQuestionAnswerFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserFormQuestionAnswerFilter<
                          Input$UserFormQuestionAnswerFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$UserFormQuestionAnswerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UserFormQuestionAnswerFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserFormQuestionAnswerFilter.stub(_then(_instance))
        : CopyWith$Input$UserFormQuestionAnswerFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserFormQuestionAnswerFilter<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerFilter<TRes> {
  _CopyWithStubImpl$Input$UserFormQuestionAnswerFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userFormId,
    Input$UUIDFilter? questionId,
    Input$UUIDFilter? answerChoiceId,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? answerText,
    Input$IDFilter? nodeId,
    List<Input$UserFormQuestionAnswerFilter>? and,
    List<Input$UserFormQuestionAnswerFilter>? or,
    Input$UserFormQuestionAnswerFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userFormId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get questionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get answerText =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserFormQuestionAnswerFilter<TRes> get not =>
      CopyWith$Input$UserFormQuestionAnswerFilter.stub(_res);
}

class Input$UserFormQuestionAnswerInsertInput {
  factory Input$UserFormQuestionAnswerInsertInput({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  }) =>
      Input$UserFormQuestionAnswerInsertInput._({
        if (id != null) r'id': id,
        if (userFormId != null) r'userFormId': userFormId,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
        if (answerText != null) r'answerText': answerText,
        if (data != null) r'data': data,
      });

  Input$UserFormQuestionAnswerInsertInput._(this._$data);

  factory Input$UserFormQuestionAnswerInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = (l$userFormId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = (l$answerText as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserFormQuestionAnswerInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userFormId => (_$data['userFormId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get answerText => (_$data['answerText'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserFormQuestionAnswerInsertInput<
          Input$UserFormQuestionAnswerInsertInput>
      get copyWith => CopyWith$Input$UserFormQuestionAnswerInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormQuestionAnswerInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userFormId = userFormId;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    final l$answerText = answerText;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormQuestionAnswerInsertInput<TRes> {
  factory CopyWith$Input$UserFormQuestionAnswerInsertInput(
    Input$UserFormQuestionAnswerInsertInput instance,
    TRes Function(Input$UserFormQuestionAnswerInsertInput) then,
  ) = _CopyWithImpl$Input$UserFormQuestionAnswerInsertInput;

  factory CopyWith$Input$UserFormQuestionAnswerInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormQuestionAnswerInsertInput;

  TRes call({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserFormQuestionAnswerInsertInput<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerInsertInput<TRes> {
  _CopyWithImpl$Input$UserFormQuestionAnswerInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserFormQuestionAnswerInsertInput _instance;

  final TRes Function(Input$UserFormQuestionAnswerInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userFormId = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
    Object? answerText = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserFormQuestionAnswerInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userFormId != _undefined) 'userFormId': (userFormId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (answerText != _undefined) 'answerText': (answerText as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserFormQuestionAnswerInsertInput<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserFormQuestionAnswerInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserFormQuestionAnswerOrderBy {
  factory Input$UserFormQuestionAnswerOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? answerText,
  }) =>
      Input$UserFormQuestionAnswerOrderBy._({
        if (id != null) r'id': id,
        if (userFormId != null) r'userFormId': userFormId,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
        if (answerText != null) r'answerText': answerText,
      });

  Input$UserFormQuestionAnswerOrderBy._(this._$data);

  factory Input$UserFormQuestionAnswerOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = l$userFormId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userFormId as String));
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = l$questionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$questionId as String));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$answerChoiceId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = l$answerText == null
          ? null
          : fromJson$Enum$OrderByDirection((l$answerText as String));
    }
    return Input$UserFormQuestionAnswerOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userFormId =>
      (_$data['userFormId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get questionId =>
      (_$data['questionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get answerChoiceId =>
      (_$data['answerChoiceId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get answerText =>
      (_$data['answerText'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId == null
          ? null
          : toJson$Enum$OrderByDirection(l$userFormId);
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$questionId);
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : toJson$Enum$OrderByDirection(l$answerChoiceId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText == null
          ? null
          : toJson$Enum$OrderByDirection(l$answerText);
    }
    return result$data;
  }

  CopyWith$Input$UserFormQuestionAnswerOrderBy<
          Input$UserFormQuestionAnswerOrderBy>
      get copyWith => CopyWith$Input$UserFormQuestionAnswerOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormQuestionAnswerOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userFormId = userFormId;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    final l$answerText = answerText;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormQuestionAnswerOrderBy<TRes> {
  factory CopyWith$Input$UserFormQuestionAnswerOrderBy(
    Input$UserFormQuestionAnswerOrderBy instance,
    TRes Function(Input$UserFormQuestionAnswerOrderBy) then,
  ) = _CopyWithImpl$Input$UserFormQuestionAnswerOrderBy;

  factory CopyWith$Input$UserFormQuestionAnswerOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormQuestionAnswerOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? answerText,
  });
}

class _CopyWithImpl$Input$UserFormQuestionAnswerOrderBy<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerOrderBy<TRes> {
  _CopyWithImpl$Input$UserFormQuestionAnswerOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserFormQuestionAnswerOrderBy _instance;

  final TRes Function(Input$UserFormQuestionAnswerOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userFormId = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
    Object? answerText = _undefined,
  }) =>
      _then(Input$UserFormQuestionAnswerOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userFormId != _undefined)
          'userFormId': (userFormId as Enum$OrderByDirection?),
        if (questionId != _undefined)
          'questionId': (questionId as Enum$OrderByDirection?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (answerText != _undefined)
          'answerText': (answerText as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserFormQuestionAnswerOrderBy<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserFormQuestionAnswerOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? questionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? answerText,
  }) =>
      _res;
}

class Input$UserFormQuestionAnswerUpdateInput {
  factory Input$UserFormQuestionAnswerUpdateInput({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  }) =>
      Input$UserFormQuestionAnswerUpdateInput._({
        if (id != null) r'id': id,
        if (userFormId != null) r'userFormId': userFormId,
        if (questionId != null) r'questionId': questionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (createdAt != null) r'createdAt': createdAt,
        if (answerText != null) r'answerText': answerText,
        if (data != null) r'data': data,
      });

  Input$UserFormQuestionAnswerUpdateInput._(this._$data);

  factory Input$UserFormQuestionAnswerUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = (l$userFormId as String?);
    }
    if (data.containsKey('questionId')) {
      final l$questionId = data['questionId'];
      result$data['questionId'] = (l$questionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = (l$answerText as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserFormQuestionAnswerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userFormId => (_$data['userFormId'] as String?);

  String? get questionId => (_$data['questionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get answerText => (_$data['answerText'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId;
    }
    if (_$data.containsKey('questionId')) {
      final l$questionId = questionId;
      result$data['questionId'] = l$questionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserFormQuestionAnswerUpdateInput<
          Input$UserFormQuestionAnswerUpdateInput>
      get copyWith => CopyWith$Input$UserFormQuestionAnswerUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormQuestionAnswerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (_$data.containsKey('questionId') !=
        other._$data.containsKey('questionId')) {
      return false;
    }
    if (l$questionId != lOther$questionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userFormId = userFormId;
    final l$questionId = questionId;
    final l$answerChoiceId = answerChoiceId;
    final l$createdAt = createdAt;
    final l$answerText = answerText;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('questionId') ? l$questionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormQuestionAnswerUpdateInput<TRes> {
  factory CopyWith$Input$UserFormQuestionAnswerUpdateInput(
    Input$UserFormQuestionAnswerUpdateInput instance,
    TRes Function(Input$UserFormQuestionAnswerUpdateInput) then,
  ) = _CopyWithImpl$Input$UserFormQuestionAnswerUpdateInput;

  factory CopyWith$Input$UserFormQuestionAnswerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormQuestionAnswerUpdateInput;

  TRes call({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserFormQuestionAnswerUpdateInput<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerUpdateInput<TRes> {
  _CopyWithImpl$Input$UserFormQuestionAnswerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserFormQuestionAnswerUpdateInput _instance;

  final TRes Function(Input$UserFormQuestionAnswerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userFormId = _undefined,
    Object? questionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? createdAt = _undefined,
    Object? answerText = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserFormQuestionAnswerUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userFormId != _undefined) 'userFormId': (userFormId as String?),
        if (questionId != _undefined) 'questionId': (questionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (answerText != _undefined) 'answerText': (answerText as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserFormQuestionAnswerUpdateInput<TRes>
    implements CopyWith$Input$UserFormQuestionAnswerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserFormQuestionAnswerUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userFormId,
    String? questionId,
    String? answerChoiceId,
    DateTime? createdAt,
    String? answerText,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserFormUpdateInput {
  factory Input$UserFormUpdateInput({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  }) =>
      Input$UserFormUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (formId != null) r'formId': formId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$UserFormUpdateInput._(this._$data);

  factory Input$UserFormUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('formId')) {
      final l$formId = data['formId'];
      result$data['formId'] = (l$formId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    return Input$UserFormUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get formId => (_$data['formId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('formId')) {
      final l$formId = formId;
      result$data['formId'] = l$formId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserFormUpdateInput<Input$UserFormUpdateInput> get copyWith =>
      CopyWith$Input$UserFormUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserFormUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$formId = formId;
    final lOther$formId = other.formId;
    if (_$data.containsKey('formId') != other._$data.containsKey('formId')) {
      return false;
    }
    if (l$formId != lOther$formId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$formId = formId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('formId') ? l$formId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFormUpdateInput<TRes> {
  factory CopyWith$Input$UserFormUpdateInput(
    Input$UserFormUpdateInput instance,
    TRes Function(Input$UserFormUpdateInput) then,
  ) = _CopyWithImpl$Input$UserFormUpdateInput;

  factory CopyWith$Input$UserFormUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFormUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  });
}

class _CopyWithImpl$Input$UserFormUpdateInput<TRes>
    implements CopyWith$Input$UserFormUpdateInput<TRes> {
  _CopyWithImpl$Input$UserFormUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserFormUpdateInput _instance;

  final TRes Function(Input$UserFormUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? formId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$UserFormUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (formId != _undefined) 'formId': (formId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserFormUpdateInput<TRes>
    implements CopyWith$Input$UserFormUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserFormUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? formId,
    DateTime? createdAt,
  }) =>
      _res;
}

class Input$UserInsertInput {
  factory Input$UserInsertInput({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  }) =>
      Input$UserInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (email != null) r'email': email,
        if (data != null) r'data': data,
        if (lastName != null) r'lastName': lastName,
        if (firstName != null) r'firstName': firstName,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (displayName != null) r'displayName': displayName,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (kratosId != null) r'kratosId': kratosId,
        if (supabaseUserId != null) r'supabaseUserId': supabaseUserId,
      });

  Input$UserInsertInput._(this._$data);

  factory Input$UserInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = (l$avatarUrl as String?);
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('kratosId')) {
      final l$kratosId = data['kratosId'];
      result$data['kratosId'] = (l$kratosId as String?);
    }
    if (data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = data['supabaseUserId'];
      result$data['supabaseUserId'] = (l$supabaseUserId as String?);
    }
    return Input$UserInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get email => (_$data['email'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get firstName => (_$data['firstName'] as String?);

  String? get avatarUrl => (_$data['avatarUrl'] as String?);

  String? get displayName => (_$data['displayName'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get kratosId => (_$data['kratosId'] as String?);

  String? get supabaseUserId => (_$data['supabaseUserId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl;
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('kratosId')) {
      final l$kratosId = kratosId;
      result$data['kratosId'] = l$kratosId;
    }
    if (_$data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = supabaseUserId;
      result$data['supabaseUserId'] = l$supabaseUserId;
    }
    return result$data;
  }

  CopyWith$Input$UserInsertInput<Input$UserInsertInput> get copyWith =>
      CopyWith$Input$UserInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$kratosId = kratosId;
    final lOther$kratosId = other.kratosId;
    if (_$data.containsKey('kratosId') !=
        other._$data.containsKey('kratosId')) {
      return false;
    }
    if (l$kratosId != lOther$kratosId) {
      return false;
    }
    final l$supabaseUserId = supabaseUserId;
    final lOther$supabaseUserId = other.supabaseUserId;
    if (_$data.containsKey('supabaseUserId') !=
        other._$data.containsKey('supabaseUserId')) {
      return false;
    }
    if (l$supabaseUserId != lOther$supabaseUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$email = email;
    final l$data = data;
    final l$lastName = lastName;
    final l$firstName = firstName;
    final l$avatarUrl = avatarUrl;
    final l$displayName = displayName;
    final l$updatedAt = updatedAt;
    final l$kratosId = kratosId;
    final l$supabaseUserId = supabaseUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('kratosId') ? l$kratosId : const {},
      _$data.containsKey('supabaseUserId') ? l$supabaseUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserInsertInput<TRes> {
  factory CopyWith$Input$UserInsertInput(
    Input$UserInsertInput instance,
    TRes Function(Input$UserInsertInput) then,
  ) = _CopyWithImpl$Input$UserInsertInput;

  factory CopyWith$Input$UserInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  });
}

class _CopyWithImpl$Input$UserInsertInput<TRes>
    implements CopyWith$Input$UserInsertInput<TRes> {
  _CopyWithImpl$Input$UserInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserInsertInput _instance;

  final TRes Function(Input$UserInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? email = _undefined,
    Object? data = _undefined,
    Object? lastName = _undefined,
    Object? firstName = _undefined,
    Object? avatarUrl = _undefined,
    Object? displayName = _undefined,
    Object? updatedAt = _undefined,
    Object? kratosId = _undefined,
    Object? supabaseUserId = _undefined,
  }) =>
      _then(Input$UserInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (email != _undefined) 'email': (email as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as String?),
        if (displayName != _undefined) 'displayName': (displayName as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (kratosId != _undefined) 'kratosId': (kratosId as String?),
        if (supabaseUserId != _undefined)
          'supabaseUserId': (supabaseUserId as String?),
      }));
}

class _CopyWithStubImpl$Input$UserInsertInput<TRes>
    implements CopyWith$Input$UserInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  }) =>
      _res;
}

class Input$UserOnboardingFilter {
  factory Input$UserOnboardingFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? onboardingId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isCompleted,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingFilter>? and,
    List<Input$UserOnboardingFilter>? or,
    Input$UserOnboardingFilter? not,
  }) =>
      Input$UserOnboardingFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (completedAt != null) r'completedAt': completedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserOnboardingFilter._(this._$data);

  factory Input$UserOnboardingFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : Input$UUIDFilter.fromJson((l$onboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : Input$BooleanFilter.fromJson((l$isStarted as Map<String, dynamic>));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$startedAt as Map<String, dynamic>));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isCompleted as Map<String, dynamic>));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$completedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$UserOnboardingFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$UserOnboardingFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserOnboardingFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$UserOnboardingFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingId =>
      (_$data['onboardingId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isStarted =>
      (_$data['isStarted'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get startedAt =>
      (_$data['startedAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isCompleted =>
      (_$data['isCompleted'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get completedAt =>
      (_$data['completedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserOnboardingFilter>? get and =>
      (_$data['and'] as List<Input$UserOnboardingFilter>?);

  List<Input$UserOnboardingFilter>? get or =>
      (_$data['or'] as List<Input$UserOnboardingFilter>?);

  Input$UserOnboardingFilter? get not =>
      (_$data['not'] as Input$UserOnboardingFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted?.toJson();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toJson();
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted?.toJson();
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingFilter<Input$UserOnboardingFilter>
      get copyWith => CopyWith$Input$UserOnboardingFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$onboardingId = onboardingId;
    final l$createdAt = createdAt;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$isCompleted = isCompleted;
    final l$completedAt = completedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingFilter<TRes> {
  factory CopyWith$Input$UserOnboardingFilter(
    Input$UserOnboardingFilter instance,
    TRes Function(Input$UserOnboardingFilter) then,
  ) = _CopyWithImpl$Input$UserOnboardingFilter;

  factory CopyWith$Input$UserOnboardingFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? onboardingId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isCompleted,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingFilter>? and,
    List<Input$UserOnboardingFilter>? or,
    Input$UserOnboardingFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get onboardingId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$BooleanFilter<TRes> get isStarted;
  CopyWith$Input$DatetimeFilter<TRes> get startedAt;
  CopyWith$Input$BooleanFilter<TRes> get isCompleted;
  CopyWith$Input$DatetimeFilter<TRes> get completedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserOnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$UserOnboardingFilter<
                      Input$UserOnboardingFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserOnboardingFilter>? Function(
              Iterable<
                  CopyWith$Input$UserOnboardingFilter<
                      Input$UserOnboardingFilter>>?)
          _fn);
  CopyWith$Input$UserOnboardingFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserOnboardingFilter<TRes>
    implements CopyWith$Input$UserOnboardingFilter<TRes> {
  _CopyWithImpl$Input$UserOnboardingFilter(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingFilter _instance;

  final TRes Function(Input$UserOnboardingFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? onboardingId = _undefined,
    Object? createdAt = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? isCompleted = _undefined,
    Object? completedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserOnboardingFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Input$BooleanFilter?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Input$DatetimeFilter?),
        if (isCompleted != _undefined)
          'isCompleted': (isCompleted as Input$BooleanFilter?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$UserOnboardingFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserOnboardingFilter>?),
        if (not != _undefined) 'not': (not as Input$UserOnboardingFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingId {
    final local$onboardingId = _instance.onboardingId;
    return local$onboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingId, (e) => call(onboardingId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isStarted {
    final local$isStarted = _instance.isStarted;
    return local$isStarted == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isStarted, (e) => call(isStarted: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get startedAt {
    final local$startedAt = _instance.startedAt;
    return local$startedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$startedAt, (e) => call(startedAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isCompleted {
    final local$isCompleted = _instance.isCompleted;
    return local$isCompleted == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isCompleted, (e) => call(isCompleted: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get completedAt {
    final local$completedAt = _instance.completedAt;
    return local$completedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$completedAt, (e) => call(completedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserOnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserOnboardingFilter<
                          Input$UserOnboardingFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$UserOnboardingFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$UserOnboardingFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserOnboardingFilter<
                          Input$UserOnboardingFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserOnboardingFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserOnboardingFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserOnboardingFilter.stub(_then(_instance))
        : CopyWith$Input$UserOnboardingFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserOnboardingFilter<TRes>
    implements CopyWith$Input$UserOnboardingFilter<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? onboardingId,
    Input$DatetimeFilter? createdAt,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isCompleted,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingFilter>? and,
    List<Input$UserOnboardingFilter>? or,
    Input$UserOnboardingFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isStarted =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get startedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isCompleted =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get completedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserOnboardingFilter<TRes> get not =>
      CopyWith$Input$UserOnboardingFilter.stub(_res);
}

class Input$UserOnboardingInsertInput {
  factory Input$UserOnboardingInsertInput({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserOnboardingInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (completedAt != null) r'completedAt': completedAt,
        if (data != null) r'data': data,
      });

  Input$UserOnboardingInsertInput._(this._$data);

  factory Input$UserOnboardingInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = (l$isCompleted as bool?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserOnboardingInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  bool? get isCompleted => (_$data['isCompleted'] as bool?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingInsertInput<Input$UserOnboardingInsertInput>
      get copyWith => CopyWith$Input$UserOnboardingInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$onboardingId = onboardingId;
    final l$createdAt = createdAt;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$isCompleted = isCompleted;
    final l$completedAt = completedAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingInsertInput<TRes> {
  factory CopyWith$Input$UserOnboardingInsertInput(
    Input$UserOnboardingInsertInput instance,
    TRes Function(Input$UserOnboardingInsertInput) then,
  ) = _CopyWithImpl$Input$UserOnboardingInsertInput;

  factory CopyWith$Input$UserOnboardingInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserOnboardingInsertInput<TRes>
    implements CopyWith$Input$UserOnboardingInsertInput<TRes> {
  _CopyWithImpl$Input$UserOnboardingInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingInsertInput _instance;

  final TRes Function(Input$UserOnboardingInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? onboardingId = _undefined,
    Object? createdAt = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? isCompleted = _undefined,
    Object? completedAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserOnboardingInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (isCompleted != _undefined) 'isCompleted': (isCompleted as bool?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingInsertInput<TRes>
    implements CopyWith$Input$UserOnboardingInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserOnboardingOrderBy {
  factory Input$UserOnboardingOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? completedAt,
  }) =>
      Input$UserOnboardingOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (completedAt != null) r'completedAt': completedAt,
      });

  Input$UserOnboardingOrderBy._(this._$data);

  factory Input$UserOnboardingOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isStarted as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$startedAt as String));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isCompleted as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$completedAt as String));
    }
    return Input$UserOnboardingOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingId =>
      (_$data['onboardingId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isStarted =>
      (_$data['isStarted'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get startedAt =>
      (_$data['startedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isCompleted =>
      (_$data['isCompleted'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get completedAt =>
      (_$data['completedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted == null
          ? null
          : toJson$Enum$OrderByDirection(l$isStarted);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$startedAt);
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : toJson$Enum$OrderByDirection(l$isCompleted);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$completedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingOrderBy<Input$UserOnboardingOrderBy>
      get copyWith => CopyWith$Input$UserOnboardingOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$onboardingId = onboardingId;
    final l$createdAt = createdAt;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$isCompleted = isCompleted;
    final l$completedAt = completedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingOrderBy<TRes> {
  factory CopyWith$Input$UserOnboardingOrderBy(
    Input$UserOnboardingOrderBy instance,
    TRes Function(Input$UserOnboardingOrderBy) then,
  ) = _CopyWithImpl$Input$UserOnboardingOrderBy;

  factory CopyWith$Input$UserOnboardingOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? completedAt,
  });
}

class _CopyWithImpl$Input$UserOnboardingOrderBy<TRes>
    implements CopyWith$Input$UserOnboardingOrderBy<TRes> {
  _CopyWithImpl$Input$UserOnboardingOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingOrderBy _instance;

  final TRes Function(Input$UserOnboardingOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? onboardingId = _undefined,
    Object? createdAt = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? isCompleted = _undefined,
    Object? completedAt = _undefined,
  }) =>
      _then(Input$UserOnboardingOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Enum$OrderByDirection?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Enum$OrderByDirection?),
        if (isCompleted != _undefined)
          'isCompleted': (isCompleted as Enum$OrderByDirection?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingOrderBy<TRes>
    implements CopyWith$Input$UserOnboardingOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? onboardingId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? completedAt,
  }) =>
      _res;
}

class Input$UserOnboardingStepFilter {
  factory Input$UserOnboardingStepFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userOnboardingId,
    Input$UUIDFilter? onboardingStepId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userSurveyId,
    Input$BooleanFilter? isCompleted,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$UUIDFilter? userFormId,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingStepFilter>? and,
    List<Input$UserOnboardingStepFilter>? or,
    Input$UserOnboardingStepFilter? not,
  }) =>
      Input$UserOnboardingStepFilter._({
        if (id != null) r'id': id,
        if (userOnboardingId != null) r'userOnboardingId': userOnboardingId,
        if (onboardingStepId != null) r'onboardingStepId': onboardingStepId,
        if (createdAt != null) r'createdAt': createdAt,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (userFormId != null) r'userFormId': userFormId,
        if (completedAt != null) r'completedAt': completedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserOnboardingStepFilter._(this._$data);

  factory Input$UserOnboardingStepFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = data['userOnboardingId'];
      result$data['userOnboardingId'] = l$userOnboardingId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$userOnboardingId as Map<String, dynamic>));
    }
    if (data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = data['onboardingStepId'];
      result$data['onboardingStepId'] = l$onboardingStepId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$onboardingStepId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userSurveyId as Map<String, dynamic>));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isCompleted as Map<String, dynamic>));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : Input$BooleanFilter.fromJson((l$isStarted as Map<String, dynamic>));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$startedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = l$userFormId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userFormId as Map<String, dynamic>));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$completedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserOnboardingStepFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserOnboardingStepFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserOnboardingStepFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$UserOnboardingStepFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userOnboardingId =>
      (_$data['userOnboardingId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get onboardingStepId =>
      (_$data['onboardingStepId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get userSurveyId =>
      (_$data['userSurveyId'] as Input$UUIDFilter?);

  Input$BooleanFilter? get isCompleted =>
      (_$data['isCompleted'] as Input$BooleanFilter?);

  Input$BooleanFilter? get isStarted =>
      (_$data['isStarted'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get startedAt =>
      (_$data['startedAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get userFormId =>
      (_$data['userFormId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get completedAt =>
      (_$data['completedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserOnboardingStepFilter>? get and =>
      (_$data['and'] as List<Input$UserOnboardingStepFilter>?);

  List<Input$UserOnboardingStepFilter>? get or =>
      (_$data['or'] as List<Input$UserOnboardingStepFilter>?);

  Input$UserOnboardingStepFilter? get not =>
      (_$data['not'] as Input$UserOnboardingStepFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = userOnboardingId;
      result$data['userOnboardingId'] = l$userOnboardingId?.toJson();
    }
    if (_$data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = onboardingStepId;
      result$data['onboardingStepId'] = l$onboardingStepId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId?.toJson();
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted?.toJson();
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted?.toJson();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toJson();
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId?.toJson();
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingStepFilter<Input$UserOnboardingStepFilter>
      get copyWith => CopyWith$Input$UserOnboardingStepFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingStepFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userOnboardingId = userOnboardingId;
    final lOther$userOnboardingId = other.userOnboardingId;
    if (_$data.containsKey('userOnboardingId') !=
        other._$data.containsKey('userOnboardingId')) {
      return false;
    }
    if (l$userOnboardingId != lOther$userOnboardingId) {
      return false;
    }
    final l$onboardingStepId = onboardingStepId;
    final lOther$onboardingStepId = other.onboardingStepId;
    if (_$data.containsKey('onboardingStepId') !=
        other._$data.containsKey('onboardingStepId')) {
      return false;
    }
    if (l$onboardingStepId != lOther$onboardingStepId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userOnboardingId = userOnboardingId;
    final l$onboardingStepId = onboardingStepId;
    final l$createdAt = createdAt;
    final l$userSurveyId = userSurveyId;
    final l$isCompleted = isCompleted;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$userFormId = userFormId;
    final l$completedAt = completedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userOnboardingId') ? l$userOnboardingId : const {},
      _$data.containsKey('onboardingStepId') ? l$onboardingStepId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingStepFilter<TRes> {
  factory CopyWith$Input$UserOnboardingStepFilter(
    Input$UserOnboardingStepFilter instance,
    TRes Function(Input$UserOnboardingStepFilter) then,
  ) = _CopyWithImpl$Input$UserOnboardingStepFilter;

  factory CopyWith$Input$UserOnboardingStepFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingStepFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userOnboardingId,
    Input$UUIDFilter? onboardingStepId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userSurveyId,
    Input$BooleanFilter? isCompleted,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$UUIDFilter? userFormId,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingStepFilter>? and,
    List<Input$UserOnboardingStepFilter>? or,
    Input$UserOnboardingStepFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userOnboardingId;
  CopyWith$Input$UUIDFilter<TRes> get onboardingStepId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get userSurveyId;
  CopyWith$Input$BooleanFilter<TRes> get isCompleted;
  CopyWith$Input$BooleanFilter<TRes> get isStarted;
  CopyWith$Input$DatetimeFilter<TRes> get startedAt;
  CopyWith$Input$UUIDFilter<TRes> get userFormId;
  CopyWith$Input$DatetimeFilter<TRes> get completedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserOnboardingStepFilter>? Function(
              Iterable<
                  CopyWith$Input$UserOnboardingStepFilter<
                      Input$UserOnboardingStepFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserOnboardingStepFilter>? Function(
              Iterable<
                  CopyWith$Input$UserOnboardingStepFilter<
                      Input$UserOnboardingStepFilter>>?)
          _fn);
  CopyWith$Input$UserOnboardingStepFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserOnboardingStepFilter<TRes>
    implements CopyWith$Input$UserOnboardingStepFilter<TRes> {
  _CopyWithImpl$Input$UserOnboardingStepFilter(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingStepFilter _instance;

  final TRes Function(Input$UserOnboardingStepFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userOnboardingId = _undefined,
    Object? onboardingStepId = _undefined,
    Object? createdAt = _undefined,
    Object? userSurveyId = _undefined,
    Object? isCompleted = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? userFormId = _undefined,
    Object? completedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserOnboardingStepFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userOnboardingId != _undefined)
          'userOnboardingId': (userOnboardingId as Input$UUIDFilter?),
        if (onboardingStepId != _undefined)
          'onboardingStepId': (onboardingStepId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as Input$UUIDFilter?),
        if (isCompleted != _undefined)
          'isCompleted': (isCompleted as Input$BooleanFilter?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Input$BooleanFilter?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Input$DatetimeFilter?),
        if (userFormId != _undefined)
          'userFormId': (userFormId as Input$UUIDFilter?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$UserOnboardingStepFilter>?),
        if (or != _undefined)
          'or': (or as List<Input$UserOnboardingStepFilter>?),
        if (not != _undefined) 'not': (not as Input$UserOnboardingStepFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userOnboardingId {
    final local$userOnboardingId = _instance.userOnboardingId;
    return local$userOnboardingId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$userOnboardingId, (e) => call(userOnboardingId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get onboardingStepId {
    final local$onboardingStepId = _instance.onboardingStepId;
    return local$onboardingStepId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$onboardingStepId, (e) => call(onboardingStepId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userSurveyId {
    final local$userSurveyId = _instance.userSurveyId;
    return local$userSurveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$userSurveyId, (e) => call(userSurveyId: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isCompleted {
    final local$isCompleted = _instance.isCompleted;
    return local$isCompleted == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isCompleted, (e) => call(isCompleted: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isStarted {
    final local$isStarted = _instance.isStarted;
    return local$isStarted == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isStarted, (e) => call(isStarted: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get startedAt {
    final local$startedAt = _instance.startedAt;
    return local$startedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$startedAt, (e) => call(startedAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userFormId {
    final local$userFormId = _instance.userFormId;
    return local$userFormId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$userFormId, (e) => call(userFormId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get completedAt {
    final local$completedAt = _instance.completedAt;
    return local$completedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$completedAt, (e) => call(completedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserOnboardingStepFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserOnboardingStepFilter<
                          Input$UserOnboardingStepFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$UserOnboardingStepFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$UserOnboardingStepFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserOnboardingStepFilter<
                          Input$UserOnboardingStepFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$UserOnboardingStepFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UserOnboardingStepFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserOnboardingStepFilter.stub(_then(_instance))
        : CopyWith$Input$UserOnboardingStepFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserOnboardingStepFilter<TRes>
    implements CopyWith$Input$UserOnboardingStepFilter<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingStepFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userOnboardingId,
    Input$UUIDFilter? onboardingStepId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userSurveyId,
    Input$BooleanFilter? isCompleted,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? startedAt,
    Input$UUIDFilter? userFormId,
    Input$DatetimeFilter? completedAt,
    Input$IDFilter? nodeId,
    List<Input$UserOnboardingStepFilter>? and,
    List<Input$UserOnboardingStepFilter>? or,
    Input$UserOnboardingStepFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userOnboardingId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get onboardingStepId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userSurveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isCompleted =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isStarted =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get startedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userFormId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get completedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserOnboardingStepFilter<TRes> get not =>
      CopyWith$Input$UserOnboardingStepFilter.stub(_res);
}

class Input$UserOnboardingStepInsertInput {
  factory Input$UserOnboardingStepInsertInput({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  }) =>
      Input$UserOnboardingStepInsertInput._({
        if (id != null) r'id': id,
        if (userOnboardingId != null) r'userOnboardingId': userOnboardingId,
        if (onboardingStepId != null) r'onboardingStepId': onboardingStepId,
        if (createdAt != null) r'createdAt': createdAt,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (userFormId != null) r'userFormId': userFormId,
        if (completedAt != null) r'completedAt': completedAt,
      });

  Input$UserOnboardingStepInsertInput._(this._$data);

  factory Input$UserOnboardingStepInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = data['userOnboardingId'];
      result$data['userOnboardingId'] = (l$userOnboardingId as String?);
    }
    if (data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = data['onboardingStepId'];
      result$data['onboardingStepId'] = (l$onboardingStepId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = (l$userSurveyId as String?);
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = (l$isCompleted as bool?);
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = (l$userFormId as String?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    return Input$UserOnboardingStepInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userOnboardingId => (_$data['userOnboardingId'] as String?);

  String? get onboardingStepId => (_$data['onboardingStepId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get userSurveyId => (_$data['userSurveyId'] as String?);

  bool? get isCompleted => (_$data['isCompleted'] as bool?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  String? get userFormId => (_$data['userFormId'] as String?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = userOnboardingId;
      result$data['userOnboardingId'] = l$userOnboardingId;
    }
    if (_$data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = onboardingStepId;
      result$data['onboardingStepId'] = l$onboardingStepId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId;
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted;
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingStepInsertInput<
          Input$UserOnboardingStepInsertInput>
      get copyWith => CopyWith$Input$UserOnboardingStepInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingStepInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userOnboardingId = userOnboardingId;
    final lOther$userOnboardingId = other.userOnboardingId;
    if (_$data.containsKey('userOnboardingId') !=
        other._$data.containsKey('userOnboardingId')) {
      return false;
    }
    if (l$userOnboardingId != lOther$userOnboardingId) {
      return false;
    }
    final l$onboardingStepId = onboardingStepId;
    final lOther$onboardingStepId = other.onboardingStepId;
    if (_$data.containsKey('onboardingStepId') !=
        other._$data.containsKey('onboardingStepId')) {
      return false;
    }
    if (l$onboardingStepId != lOther$onboardingStepId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userOnboardingId = userOnboardingId;
    final l$onboardingStepId = onboardingStepId;
    final l$createdAt = createdAt;
    final l$userSurveyId = userSurveyId;
    final l$isCompleted = isCompleted;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$userFormId = userFormId;
    final l$completedAt = completedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userOnboardingId') ? l$userOnboardingId : const {},
      _$data.containsKey('onboardingStepId') ? l$onboardingStepId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingStepInsertInput<TRes> {
  factory CopyWith$Input$UserOnboardingStepInsertInput(
    Input$UserOnboardingStepInsertInput instance,
    TRes Function(Input$UserOnboardingStepInsertInput) then,
  ) = _CopyWithImpl$Input$UserOnboardingStepInsertInput;

  factory CopyWith$Input$UserOnboardingStepInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingStepInsertInput;

  TRes call({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  });
}

class _CopyWithImpl$Input$UserOnboardingStepInsertInput<TRes>
    implements CopyWith$Input$UserOnboardingStepInsertInput<TRes> {
  _CopyWithImpl$Input$UserOnboardingStepInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingStepInsertInput _instance;

  final TRes Function(Input$UserOnboardingStepInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userOnboardingId = _undefined,
    Object? onboardingStepId = _undefined,
    Object? createdAt = _undefined,
    Object? userSurveyId = _undefined,
    Object? isCompleted = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? userFormId = _undefined,
    Object? completedAt = _undefined,
  }) =>
      _then(Input$UserOnboardingStepInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userOnboardingId != _undefined)
          'userOnboardingId': (userOnboardingId as String?),
        if (onboardingStepId != _undefined)
          'onboardingStepId': (onboardingStepId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as String?),
        if (isCompleted != _undefined) 'isCompleted': (isCompleted as bool?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (userFormId != _undefined) 'userFormId': (userFormId as String?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingStepInsertInput<TRes>
    implements CopyWith$Input$UserOnboardingStepInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingStepInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  }) =>
      _res;
}

class Input$UserOnboardingStepOrderBy {
  factory Input$UserOnboardingStepOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userOnboardingId,
    Enum$OrderByDirection? onboardingStepId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? completedAt,
  }) =>
      Input$UserOnboardingStepOrderBy._({
        if (id != null) r'id': id,
        if (userOnboardingId != null) r'userOnboardingId': userOnboardingId,
        if (onboardingStepId != null) r'onboardingStepId': onboardingStepId,
        if (createdAt != null) r'createdAt': createdAt,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (userFormId != null) r'userFormId': userFormId,
        if (completedAt != null) r'completedAt': completedAt,
      });

  Input$UserOnboardingStepOrderBy._(this._$data);

  factory Input$UserOnboardingStepOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = data['userOnboardingId'];
      result$data['userOnboardingId'] = l$userOnboardingId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userOnboardingId as String));
    }
    if (data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = data['onboardingStepId'];
      result$data['onboardingStepId'] = l$onboardingStepId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$onboardingStepId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userSurveyId as String));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isCompleted as String));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isStarted as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$startedAt as String));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = l$userFormId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userFormId as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$completedAt as String));
    }
    return Input$UserOnboardingStepOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userOnboardingId =>
      (_$data['userOnboardingId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get onboardingStepId =>
      (_$data['onboardingStepId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userSurveyId =>
      (_$data['userSurveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isCompleted =>
      (_$data['isCompleted'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isStarted =>
      (_$data['isStarted'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get startedAt =>
      (_$data['startedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userFormId =>
      (_$data['userFormId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get completedAt =>
      (_$data['completedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = userOnboardingId;
      result$data['userOnboardingId'] = l$userOnboardingId == null
          ? null
          : toJson$Enum$OrderByDirection(l$userOnboardingId);
    }
    if (_$data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = onboardingStepId;
      result$data['onboardingStepId'] = l$onboardingStepId == null
          ? null
          : toJson$Enum$OrderByDirection(l$onboardingStepId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : toJson$Enum$OrderByDirection(l$userSurveyId);
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted == null
          ? null
          : toJson$Enum$OrderByDirection(l$isCompleted);
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted == null
          ? null
          : toJson$Enum$OrderByDirection(l$isStarted);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$startedAt);
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId == null
          ? null
          : toJson$Enum$OrderByDirection(l$userFormId);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$completedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingStepOrderBy<Input$UserOnboardingStepOrderBy>
      get copyWith => CopyWith$Input$UserOnboardingStepOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingStepOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userOnboardingId = userOnboardingId;
    final lOther$userOnboardingId = other.userOnboardingId;
    if (_$data.containsKey('userOnboardingId') !=
        other._$data.containsKey('userOnboardingId')) {
      return false;
    }
    if (l$userOnboardingId != lOther$userOnboardingId) {
      return false;
    }
    final l$onboardingStepId = onboardingStepId;
    final lOther$onboardingStepId = other.onboardingStepId;
    if (_$data.containsKey('onboardingStepId') !=
        other._$data.containsKey('onboardingStepId')) {
      return false;
    }
    if (l$onboardingStepId != lOther$onboardingStepId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userOnboardingId = userOnboardingId;
    final l$onboardingStepId = onboardingStepId;
    final l$createdAt = createdAt;
    final l$userSurveyId = userSurveyId;
    final l$isCompleted = isCompleted;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$userFormId = userFormId;
    final l$completedAt = completedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userOnboardingId') ? l$userOnboardingId : const {},
      _$data.containsKey('onboardingStepId') ? l$onboardingStepId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingStepOrderBy<TRes> {
  factory CopyWith$Input$UserOnboardingStepOrderBy(
    Input$UserOnboardingStepOrderBy instance,
    TRes Function(Input$UserOnboardingStepOrderBy) then,
  ) = _CopyWithImpl$Input$UserOnboardingStepOrderBy;

  factory CopyWith$Input$UserOnboardingStepOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingStepOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userOnboardingId,
    Enum$OrderByDirection? onboardingStepId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? completedAt,
  });
}

class _CopyWithImpl$Input$UserOnboardingStepOrderBy<TRes>
    implements CopyWith$Input$UserOnboardingStepOrderBy<TRes> {
  _CopyWithImpl$Input$UserOnboardingStepOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingStepOrderBy _instance;

  final TRes Function(Input$UserOnboardingStepOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userOnboardingId = _undefined,
    Object? onboardingStepId = _undefined,
    Object? createdAt = _undefined,
    Object? userSurveyId = _undefined,
    Object? isCompleted = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? userFormId = _undefined,
    Object? completedAt = _undefined,
  }) =>
      _then(Input$UserOnboardingStepOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userOnboardingId != _undefined)
          'userOnboardingId': (userOnboardingId as Enum$OrderByDirection?),
        if (onboardingStepId != _undefined)
          'onboardingStepId': (onboardingStepId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as Enum$OrderByDirection?),
        if (isCompleted != _undefined)
          'isCompleted': (isCompleted as Enum$OrderByDirection?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Enum$OrderByDirection?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Enum$OrderByDirection?),
        if (userFormId != _undefined)
          'userFormId': (userFormId as Enum$OrderByDirection?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingStepOrderBy<TRes>
    implements CopyWith$Input$UserOnboardingStepOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingStepOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userOnboardingId,
    Enum$OrderByDirection? onboardingStepId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? isCompleted,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? userFormId,
    Enum$OrderByDirection? completedAt,
  }) =>
      _res;
}

class Input$UserOnboardingStepUpdateInput {
  factory Input$UserOnboardingStepUpdateInput({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  }) =>
      Input$UserOnboardingStepUpdateInput._({
        if (id != null) r'id': id,
        if (userOnboardingId != null) r'userOnboardingId': userOnboardingId,
        if (onboardingStepId != null) r'onboardingStepId': onboardingStepId,
        if (createdAt != null) r'createdAt': createdAt,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (userFormId != null) r'userFormId': userFormId,
        if (completedAt != null) r'completedAt': completedAt,
      });

  Input$UserOnboardingStepUpdateInput._(this._$data);

  factory Input$UserOnboardingStepUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = data['userOnboardingId'];
      result$data['userOnboardingId'] = (l$userOnboardingId as String?);
    }
    if (data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = data['onboardingStepId'];
      result$data['onboardingStepId'] = (l$onboardingStepId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = (l$userSurveyId as String?);
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = (l$isCompleted as bool?);
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('userFormId')) {
      final l$userFormId = data['userFormId'];
      result$data['userFormId'] = (l$userFormId as String?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    return Input$UserOnboardingStepUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userOnboardingId => (_$data['userOnboardingId'] as String?);

  String? get onboardingStepId => (_$data['onboardingStepId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get userSurveyId => (_$data['userSurveyId'] as String?);

  bool? get isCompleted => (_$data['isCompleted'] as bool?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  String? get userFormId => (_$data['userFormId'] as String?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userOnboardingId')) {
      final l$userOnboardingId = userOnboardingId;
      result$data['userOnboardingId'] = l$userOnboardingId;
    }
    if (_$data.containsKey('onboardingStepId')) {
      final l$onboardingStepId = onboardingStepId;
      result$data['onboardingStepId'] = l$onboardingStepId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId;
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted;
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('userFormId')) {
      final l$userFormId = userFormId;
      result$data['userFormId'] = l$userFormId;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingStepUpdateInput<
          Input$UserOnboardingStepUpdateInput>
      get copyWith => CopyWith$Input$UserOnboardingStepUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingStepUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userOnboardingId = userOnboardingId;
    final lOther$userOnboardingId = other.userOnboardingId;
    if (_$data.containsKey('userOnboardingId') !=
        other._$data.containsKey('userOnboardingId')) {
      return false;
    }
    if (l$userOnboardingId != lOther$userOnboardingId) {
      return false;
    }
    final l$onboardingStepId = onboardingStepId;
    final lOther$onboardingStepId = other.onboardingStepId;
    if (_$data.containsKey('onboardingStepId') !=
        other._$data.containsKey('onboardingStepId')) {
      return false;
    }
    if (l$onboardingStepId != lOther$onboardingStepId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$userFormId = userFormId;
    final lOther$userFormId = other.userFormId;
    if (_$data.containsKey('userFormId') !=
        other._$data.containsKey('userFormId')) {
      return false;
    }
    if (l$userFormId != lOther$userFormId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userOnboardingId = userOnboardingId;
    final l$onboardingStepId = onboardingStepId;
    final l$createdAt = createdAt;
    final l$userSurveyId = userSurveyId;
    final l$isCompleted = isCompleted;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$userFormId = userFormId;
    final l$completedAt = completedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userOnboardingId') ? l$userOnboardingId : const {},
      _$data.containsKey('onboardingStepId') ? l$onboardingStepId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('userFormId') ? l$userFormId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingStepUpdateInput<TRes> {
  factory CopyWith$Input$UserOnboardingStepUpdateInput(
    Input$UserOnboardingStepUpdateInput instance,
    TRes Function(Input$UserOnboardingStepUpdateInput) then,
  ) = _CopyWithImpl$Input$UserOnboardingStepUpdateInput;

  factory CopyWith$Input$UserOnboardingStepUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingStepUpdateInput;

  TRes call({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  });
}

class _CopyWithImpl$Input$UserOnboardingStepUpdateInput<TRes>
    implements CopyWith$Input$UserOnboardingStepUpdateInput<TRes> {
  _CopyWithImpl$Input$UserOnboardingStepUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingStepUpdateInput _instance;

  final TRes Function(Input$UserOnboardingStepUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userOnboardingId = _undefined,
    Object? onboardingStepId = _undefined,
    Object? createdAt = _undefined,
    Object? userSurveyId = _undefined,
    Object? isCompleted = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? userFormId = _undefined,
    Object? completedAt = _undefined,
  }) =>
      _then(Input$UserOnboardingStepUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userOnboardingId != _undefined)
          'userOnboardingId': (userOnboardingId as String?),
        if (onboardingStepId != _undefined)
          'onboardingStepId': (onboardingStepId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as String?),
        if (isCompleted != _undefined) 'isCompleted': (isCompleted as bool?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (userFormId != _undefined) 'userFormId': (userFormId as String?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingStepUpdateInput<TRes>
    implements CopyWith$Input$UserOnboardingStepUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingStepUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userOnboardingId,
    String? onboardingStepId,
    DateTime? createdAt,
    String? userSurveyId,
    bool? isCompleted,
    bool? isStarted,
    DateTime? startedAt,
    String? userFormId,
    DateTime? completedAt,
  }) =>
      _res;
}

class Input$UserOnboardingUpdateInput {
  factory Input$UserOnboardingUpdateInput({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserOnboardingUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (onboardingId != null) r'onboardingId': onboardingId,
        if (createdAt != null) r'createdAt': createdAt,
        if (isStarted != null) r'isStarted': isStarted,
        if (startedAt != null) r'startedAt': startedAt,
        if (isCompleted != null) r'isCompleted': isCompleted,
        if (completedAt != null) r'completedAt': completedAt,
        if (data != null) r'data': data,
      });

  Input$UserOnboardingUpdateInput._(this._$data);

  factory Input$UserOnboardingUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('onboardingId')) {
      final l$onboardingId = data['onboardingId'];
      result$data['onboardingId'] = (l$onboardingId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('isCompleted')) {
      final l$isCompleted = data['isCompleted'];
      result$data['isCompleted'] = (l$isCompleted as bool?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserOnboardingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get onboardingId => (_$data['onboardingId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  bool? get isCompleted => (_$data['isCompleted'] as bool?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('onboardingId')) {
      final l$onboardingId = onboardingId;
      result$data['onboardingId'] = l$onboardingId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('isCompleted')) {
      final l$isCompleted = isCompleted;
      result$data['isCompleted'] = l$isCompleted;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserOnboardingUpdateInput<Input$UserOnboardingUpdateInput>
      get copyWith => CopyWith$Input$UserOnboardingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOnboardingUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$onboardingId = onboardingId;
    final lOther$onboardingId = other.onboardingId;
    if (_$data.containsKey('onboardingId') !=
        other._$data.containsKey('onboardingId')) {
      return false;
    }
    if (l$onboardingId != lOther$onboardingId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isCompleted = isCompleted;
    final lOther$isCompleted = other.isCompleted;
    if (_$data.containsKey('isCompleted') !=
        other._$data.containsKey('isCompleted')) {
      return false;
    }
    if (l$isCompleted != lOther$isCompleted) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$onboardingId = onboardingId;
    final l$createdAt = createdAt;
    final l$isStarted = isStarted;
    final l$startedAt = startedAt;
    final l$isCompleted = isCompleted;
    final l$completedAt = completedAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('onboardingId') ? l$onboardingId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isCompleted') ? l$isCompleted : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOnboardingUpdateInput<TRes> {
  factory CopyWith$Input$UserOnboardingUpdateInput(
    Input$UserOnboardingUpdateInput instance,
    TRes Function(Input$UserOnboardingUpdateInput) then,
  ) = _CopyWithImpl$Input$UserOnboardingUpdateInput;

  factory CopyWith$Input$UserOnboardingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOnboardingUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserOnboardingUpdateInput<TRes>
    implements CopyWith$Input$UserOnboardingUpdateInput<TRes> {
  _CopyWithImpl$Input$UserOnboardingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserOnboardingUpdateInput _instance;

  final TRes Function(Input$UserOnboardingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? onboardingId = _undefined,
    Object? createdAt = _undefined,
    Object? isStarted = _undefined,
    Object? startedAt = _undefined,
    Object? isCompleted = _undefined,
    Object? completedAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserOnboardingUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (onboardingId != _undefined)
          'onboardingId': (onboardingId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (isCompleted != _undefined) 'isCompleted': (isCompleted as bool?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserOnboardingUpdateInput<TRes>
    implements CopyWith$Input$UserOnboardingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserOnboardingUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? onboardingId,
    DateTime? createdAt,
    bool? isStarted,
    DateTime? startedAt,
    bool? isCompleted,
    DateTime? completedAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserOrderBy {
  factory Input$UserOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? email,
    Enum$OrderByDirection? lastName,
    Enum$OrderByDirection? firstName,
    Enum$OrderByDirection? avatarUrl,
    Enum$OrderByDirection? displayName,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? kratosId,
    Enum$OrderByDirection? supabaseUserId,
  }) =>
      Input$UserOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (email != null) r'email': email,
        if (lastName != null) r'lastName': lastName,
        if (firstName != null) r'firstName': firstName,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (displayName != null) r'displayName': displayName,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (kratosId != null) r'kratosId': kratosId,
        if (supabaseUserId != null) r'supabaseUserId': supabaseUserId,
      });

  Input$UserOrderBy._(this._$data);

  factory Input$UserOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$OrderByDirection((l$email as String));
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = l$lastName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$lastName as String));
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = l$firstName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$firstName as String));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$avatarUrl as String));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : fromJson$Enum$OrderByDirection((l$displayName as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    if (data.containsKey('kratosId')) {
      final l$kratosId = data['kratosId'];
      result$data['kratosId'] = l$kratosId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$kratosId as String));
    }
    if (data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = data['supabaseUserId'];
      result$data['supabaseUserId'] = l$supabaseUserId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$supabaseUserId as String));
    }
    return Input$UserOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get email =>
      (_$data['email'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get lastName =>
      (_$data['lastName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get firstName =>
      (_$data['firstName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get avatarUrl =>
      (_$data['avatarUrl'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get displayName =>
      (_$data['displayName'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get kratosId =>
      (_$data['kratosId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get supabaseUserId =>
      (_$data['supabaseUserId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] =
          l$email == null ? null : toJson$Enum$OrderByDirection(l$email);
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] =
          l$lastName == null ? null : toJson$Enum$OrderByDirection(l$lastName);
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName == null
          ? null
          : toJson$Enum$OrderByDirection(l$firstName);
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : toJson$Enum$OrderByDirection(l$avatarUrl);
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName == null
          ? null
          : toJson$Enum$OrderByDirection(l$displayName);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    if (_$data.containsKey('kratosId')) {
      final l$kratosId = kratosId;
      result$data['kratosId'] =
          l$kratosId == null ? null : toJson$Enum$OrderByDirection(l$kratosId);
    }
    if (_$data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = supabaseUserId;
      result$data['supabaseUserId'] = l$supabaseUserId == null
          ? null
          : toJson$Enum$OrderByDirection(l$supabaseUserId);
    }
    return result$data;
  }

  CopyWith$Input$UserOrderBy<Input$UserOrderBy> get copyWith =>
      CopyWith$Input$UserOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$kratosId = kratosId;
    final lOther$kratosId = other.kratosId;
    if (_$data.containsKey('kratosId') !=
        other._$data.containsKey('kratosId')) {
      return false;
    }
    if (l$kratosId != lOther$kratosId) {
      return false;
    }
    final l$supabaseUserId = supabaseUserId;
    final lOther$supabaseUserId = other.supabaseUserId;
    if (_$data.containsKey('supabaseUserId') !=
        other._$data.containsKey('supabaseUserId')) {
      return false;
    }
    if (l$supabaseUserId != lOther$supabaseUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$email = email;
    final l$lastName = lastName;
    final l$firstName = firstName;
    final l$avatarUrl = avatarUrl;
    final l$displayName = displayName;
    final l$updatedAt = updatedAt;
    final l$kratosId = kratosId;
    final l$supabaseUserId = supabaseUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('kratosId') ? l$kratosId : const {},
      _$data.containsKey('supabaseUserId') ? l$supabaseUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOrderBy<TRes> {
  factory CopyWith$Input$UserOrderBy(
    Input$UserOrderBy instance,
    TRes Function(Input$UserOrderBy) then,
  ) = _CopyWithImpl$Input$UserOrderBy;

  factory CopyWith$Input$UserOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? email,
    Enum$OrderByDirection? lastName,
    Enum$OrderByDirection? firstName,
    Enum$OrderByDirection? avatarUrl,
    Enum$OrderByDirection? displayName,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? kratosId,
    Enum$OrderByDirection? supabaseUserId,
  });
}

class _CopyWithImpl$Input$UserOrderBy<TRes>
    implements CopyWith$Input$UserOrderBy<TRes> {
  _CopyWithImpl$Input$UserOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserOrderBy _instance;

  final TRes Function(Input$UserOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? email = _undefined,
    Object? lastName = _undefined,
    Object? firstName = _undefined,
    Object? avatarUrl = _undefined,
    Object? displayName = _undefined,
    Object? updatedAt = _undefined,
    Object? kratosId = _undefined,
    Object? supabaseUserId = _undefined,
  }) =>
      _then(Input$UserOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (email != _undefined) 'email': (email as Enum$OrderByDirection?),
        if (lastName != _undefined)
          'lastName': (lastName as Enum$OrderByDirection?),
        if (firstName != _undefined)
          'firstName': (firstName as Enum$OrderByDirection?),
        if (avatarUrl != _undefined)
          'avatarUrl': (avatarUrl as Enum$OrderByDirection?),
        if (displayName != _undefined)
          'displayName': (displayName as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
        if (kratosId != _undefined)
          'kratosId': (kratosId as Enum$OrderByDirection?),
        if (supabaseUserId != _undefined)
          'supabaseUserId': (supabaseUserId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserOrderBy<TRes>
    implements CopyWith$Input$UserOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? email,
    Enum$OrderByDirection? lastName,
    Enum$OrderByDirection? firstName,
    Enum$OrderByDirection? avatarUrl,
    Enum$OrderByDirection? displayName,
    Enum$OrderByDirection? updatedAt,
    Enum$OrderByDirection? kratosId,
    Enum$OrderByDirection? supabaseUserId,
  }) =>
      _res;
}

class Input$UserPersonaFilter {
  factory Input$UserPersonaFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? personaId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserPersonaFilter>? and,
    List<Input$UserPersonaFilter>? or,
    Input$UserPersonaFilter? not,
  }) =>
      Input$UserPersonaFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (personaId != null) r'personaId': personaId,
        if (createdAt != null) r'createdAt': createdAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserPersonaFilter._(this._$data);

  factory Input$UserPersonaFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : Input$UUIDFilter.fromJson((l$personaId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$UserPersonaFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$UserPersonaFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserPersonaFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserPersonaFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get personaId => (_$data['personaId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserPersonaFilter>? get and =>
      (_$data['and'] as List<Input$UserPersonaFilter>?);

  List<Input$UserPersonaFilter>? get or =>
      (_$data['or'] as List<Input$UserPersonaFilter>?);

  Input$UserPersonaFilter? get not =>
      (_$data['not'] as Input$UserPersonaFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserPersonaFilter<Input$UserPersonaFilter> get copyWith =>
      CopyWith$Input$UserPersonaFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonaFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$personaId = personaId;
    final l$createdAt = createdAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonaFilter<TRes> {
  factory CopyWith$Input$UserPersonaFilter(
    Input$UserPersonaFilter instance,
    TRes Function(Input$UserPersonaFilter) then,
  ) = _CopyWithImpl$Input$UserPersonaFilter;

  factory CopyWith$Input$UserPersonaFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonaFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? personaId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserPersonaFilter>? and,
    List<Input$UserPersonaFilter>? or,
    Input$UserPersonaFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get personaId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserPersonaFilter>? Function(
              Iterable<
                  CopyWith$Input$UserPersonaFilter<Input$UserPersonaFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserPersonaFilter>? Function(
              Iterable<
                  CopyWith$Input$UserPersonaFilter<Input$UserPersonaFilter>>?)
          _fn);
  CopyWith$Input$UserPersonaFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserPersonaFilter<TRes>
    implements CopyWith$Input$UserPersonaFilter<TRes> {
  _CopyWithImpl$Input$UserPersonaFilter(
    this._instance,
    this._then,
  );

  final Input$UserPersonaFilter _instance;

  final TRes Function(Input$UserPersonaFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? personaId = _undefined,
    Object? createdAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserPersonaFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (personaId != _undefined)
          'personaId': (personaId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserPersonaFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserPersonaFilter>?),
        if (not != _undefined) 'not': (not as Input$UserPersonaFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get personaId {
    final local$personaId = _instance.personaId;
    return local$personaId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$personaId, (e) => call(personaId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserPersonaFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonaFilter<
                          Input$UserPersonaFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserPersonaFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserPersonaFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonaFilter<
                          Input$UserPersonaFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserPersonaFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserPersonaFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserPersonaFilter.stub(_then(_instance))
        : CopyWith$Input$UserPersonaFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserPersonaFilter<TRes>
    implements CopyWith$Input$UserPersonaFilter<TRes> {
  _CopyWithStubImpl$Input$UserPersonaFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? personaId,
    Input$DatetimeFilter? createdAt,
    Input$IDFilter? nodeId,
    List<Input$UserPersonaFilter>? and,
    List<Input$UserPersonaFilter>? or,
    Input$UserPersonaFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get personaId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserPersonaFilter<TRes> get not =>
      CopyWith$Input$UserPersonaFilter.stub(_res);
}

class Input$UserPersonaInsertInput {
  factory Input$UserPersonaInsertInput({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserPersonaInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (personaId != null) r'personaId': personaId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$UserPersonaInsertInput._(this._$data);

  factory Input$UserPersonaInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserPersonaInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserPersonaInsertInput<Input$UserPersonaInsertInput>
      get copyWith => CopyWith$Input$UserPersonaInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonaInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$personaId = personaId;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonaInsertInput<TRes> {
  factory CopyWith$Input$UserPersonaInsertInput(
    Input$UserPersonaInsertInput instance,
    TRes Function(Input$UserPersonaInsertInput) then,
  ) = _CopyWithImpl$Input$UserPersonaInsertInput;

  factory CopyWith$Input$UserPersonaInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonaInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserPersonaInsertInput<TRes>
    implements CopyWith$Input$UserPersonaInsertInput<TRes> {
  _CopyWithImpl$Input$UserPersonaInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserPersonaInsertInput _instance;

  final TRes Function(Input$UserPersonaInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? personaId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserPersonaInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserPersonaInsertInput<TRes>
    implements CopyWith$Input$UserPersonaInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserPersonaInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserPersonaOrderBy {
  factory Input$UserPersonaOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? createdAt,
  }) =>
      Input$UserPersonaOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (personaId != null) r'personaId': personaId,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$UserPersonaOrderBy._(this._$data);

  factory Input$UserPersonaOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = l$personaId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$personaId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    return Input$UserPersonaOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get personaId =>
      (_$data['personaId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId == null
          ? null
          : toJson$Enum$OrderByDirection(l$personaId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$UserPersonaOrderBy<Input$UserPersonaOrderBy> get copyWith =>
      CopyWith$Input$UserPersonaOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonaOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$personaId = personaId;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonaOrderBy<TRes> {
  factory CopyWith$Input$UserPersonaOrderBy(
    Input$UserPersonaOrderBy instance,
    TRes Function(Input$UserPersonaOrderBy) then,
  ) = _CopyWithImpl$Input$UserPersonaOrderBy;

  factory CopyWith$Input$UserPersonaOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonaOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? createdAt,
  });
}

class _CopyWithImpl$Input$UserPersonaOrderBy<TRes>
    implements CopyWith$Input$UserPersonaOrderBy<TRes> {
  _CopyWithImpl$Input$UserPersonaOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserPersonaOrderBy _instance;

  final TRes Function(Input$UserPersonaOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? personaId = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$UserPersonaOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (personaId != _undefined)
          'personaId': (personaId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserPersonaOrderBy<TRes>
    implements CopyWith$Input$UserPersonaOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserPersonaOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? personaId,
    Enum$OrderByDirection? createdAt,
  }) =>
      _res;
}

class Input$UserPersonaUpdateInput {
  factory Input$UserPersonaUpdateInput({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserPersonaUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (personaId != null) r'personaId': personaId,
        if (createdAt != null) r'createdAt': createdAt,
        if (data != null) r'data': data,
      });

  Input$UserPersonaUpdateInput._(this._$data);

  factory Input$UserPersonaUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('personaId')) {
      final l$personaId = data['personaId'];
      result$data['personaId'] = (l$personaId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserPersonaUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get personaId => (_$data['personaId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('personaId')) {
      final l$personaId = personaId;
      result$data['personaId'] = l$personaId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserPersonaUpdateInput<Input$UserPersonaUpdateInput>
      get copyWith => CopyWith$Input$UserPersonaUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonaUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$personaId = personaId;
    final lOther$personaId = other.personaId;
    if (_$data.containsKey('personaId') !=
        other._$data.containsKey('personaId')) {
      return false;
    }
    if (l$personaId != lOther$personaId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$personaId = personaId;
    final l$createdAt = createdAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('personaId') ? l$personaId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonaUpdateInput<TRes> {
  factory CopyWith$Input$UserPersonaUpdateInput(
    Input$UserPersonaUpdateInput instance,
    TRes Function(Input$UserPersonaUpdateInput) then,
  ) = _CopyWithImpl$Input$UserPersonaUpdateInput;

  factory CopyWith$Input$UserPersonaUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonaUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserPersonaUpdateInput<TRes>
    implements CopyWith$Input$UserPersonaUpdateInput<TRes> {
  _CopyWithImpl$Input$UserPersonaUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserPersonaUpdateInput _instance;

  final TRes Function(Input$UserPersonaUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? personaId = _undefined,
    Object? createdAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserPersonaUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (personaId != _undefined) 'personaId': (personaId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserPersonaUpdateInput<TRes>
    implements CopyWith$Input$UserPersonaUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserPersonaUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? personaId,
    DateTime? createdAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserProfileFilter {
  factory Input$UserProfileFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? profileTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserProfileFilter>? and,
    List<Input$UserProfileFilter>? or,
    Input$UserProfileFilter? not,
  }) =>
      Input$UserProfileFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (profileTypeId != null) r'profileTypeId': profileTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserProfileFilter._(this._$data);

  factory Input$UserProfileFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('profileTypeId')) {
      final l$profileTypeId = data['profileTypeId'];
      result$data['profileTypeId'] = l$profileTypeId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$profileTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$UserProfileFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$UserProfileFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserProfileFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserProfileFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get profileTypeId =>
      (_$data['profileTypeId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserProfileFilter>? get and =>
      (_$data['and'] as List<Input$UserProfileFilter>?);

  List<Input$UserProfileFilter>? get or =>
      (_$data['or'] as List<Input$UserProfileFilter>?);

  Input$UserProfileFilter? get not =>
      (_$data['not'] as Input$UserProfileFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('profileTypeId')) {
      final l$profileTypeId = profileTypeId;
      result$data['profileTypeId'] = l$profileTypeId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserProfileFilter<Input$UserProfileFilter> get copyWith =>
      CopyWith$Input$UserProfileFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserProfileFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$profileTypeId = profileTypeId;
    final lOther$profileTypeId = other.profileTypeId;
    if (_$data.containsKey('profileTypeId') !=
        other._$data.containsKey('profileTypeId')) {
      return false;
    }
    if (l$profileTypeId != lOther$profileTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$profileTypeId = profileTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('profileTypeId') ? l$profileTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserProfileFilter<TRes> {
  factory CopyWith$Input$UserProfileFilter(
    Input$UserProfileFilter instance,
    TRes Function(Input$UserProfileFilter) then,
  ) = _CopyWithImpl$Input$UserProfileFilter;

  factory CopyWith$Input$UserProfileFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserProfileFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? profileTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserProfileFilter>? and,
    List<Input$UserProfileFilter>? or,
    Input$UserProfileFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get profileTypeId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserProfileFilter>? Function(
              Iterable<
                  CopyWith$Input$UserProfileFilter<Input$UserProfileFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserProfileFilter>? Function(
              Iterable<
                  CopyWith$Input$UserProfileFilter<Input$UserProfileFilter>>?)
          _fn);
  CopyWith$Input$UserProfileFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserProfileFilter<TRes>
    implements CopyWith$Input$UserProfileFilter<TRes> {
  _CopyWithImpl$Input$UserProfileFilter(
    this._instance,
    this._then,
  );

  final Input$UserProfileFilter _instance;

  final TRes Function(Input$UserProfileFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? profileTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserProfileFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (profileTypeId != _undefined)
          'profileTypeId': (profileTypeId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserProfileFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserProfileFilter>?),
        if (not != _undefined) 'not': (not as Input$UserProfileFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get profileTypeId {
    final local$profileTypeId = _instance.profileTypeId;
    return local$profileTypeId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$profileTypeId, (e) => call(profileTypeId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserProfileFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserProfileFilter<
                          Input$UserProfileFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserProfileFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserProfileFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserProfileFilter<
                          Input$UserProfileFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserProfileFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserProfileFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserProfileFilter.stub(_then(_instance))
        : CopyWith$Input$UserProfileFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserProfileFilter<TRes>
    implements CopyWith$Input$UserProfileFilter<TRes> {
  _CopyWithStubImpl$Input$UserProfileFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? profileTypeId,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserProfileFilter>? and,
    List<Input$UserProfileFilter>? or,
    Input$UserProfileFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get profileTypeId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserProfileFilter<TRes> get not =>
      CopyWith$Input$UserProfileFilter.stub(_res);
}

class Input$UserProfileInsertInput {
  factory Input$UserProfileInsertInput({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$UserProfileInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (profileTypeId != null) r'profileTypeId': profileTypeId,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserProfileInsertInput._(this._$data);

  factory Input$UserProfileInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('profileTypeId')) {
      final l$profileTypeId = data['profileTypeId'];
      result$data['profileTypeId'] = (l$profileTypeId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$UserProfileInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get profileTypeId => (_$data['profileTypeId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('profileTypeId')) {
      final l$profileTypeId = profileTypeId;
      result$data['profileTypeId'] = l$profileTypeId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserProfileInsertInput<Input$UserProfileInsertInput>
      get copyWith => CopyWith$Input$UserProfileInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserProfileInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$profileTypeId = profileTypeId;
    final lOther$profileTypeId = other.profileTypeId;
    if (_$data.containsKey('profileTypeId') !=
        other._$data.containsKey('profileTypeId')) {
      return false;
    }
    if (l$profileTypeId != lOther$profileTypeId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$profileTypeId = profileTypeId;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('profileTypeId') ? l$profileTypeId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserProfileInsertInput<TRes> {
  factory CopyWith$Input$UserProfileInsertInput(
    Input$UserProfileInsertInput instance,
    TRes Function(Input$UserProfileInsertInput) then,
  ) = _CopyWithImpl$Input$UserProfileInsertInput;

  factory CopyWith$Input$UserProfileInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserProfileInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$UserProfileInsertInput<TRes>
    implements CopyWith$Input$UserProfileInsertInput<TRes> {
  _CopyWithImpl$Input$UserProfileInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserProfileInsertInput _instance;

  final TRes Function(Input$UserProfileInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? profileTypeId = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserProfileInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (profileTypeId != _undefined)
          'profileTypeId': (profileTypeId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserProfileInsertInput<TRes>
    implements CopyWith$Input$UserProfileInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserProfileInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$UserProfileOrderBy {
  factory Input$UserProfileOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? profileTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$UserProfileOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (profileTypeId != null) r'profileTypeId': profileTypeId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserProfileOrderBy._(this._$data);

  factory Input$UserProfileOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('profileTypeId')) {
      final l$profileTypeId = data['profileTypeId'];
      result$data['profileTypeId'] = l$profileTypeId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$profileTypeId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$UserProfileOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get profileTypeId =>
      (_$data['profileTypeId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('profileTypeId')) {
      final l$profileTypeId = profileTypeId;
      result$data['profileTypeId'] = l$profileTypeId == null
          ? null
          : toJson$Enum$OrderByDirection(l$profileTypeId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserProfileOrderBy<Input$UserProfileOrderBy> get copyWith =>
      CopyWith$Input$UserProfileOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserProfileOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$profileTypeId = profileTypeId;
    final lOther$profileTypeId = other.profileTypeId;
    if (_$data.containsKey('profileTypeId') !=
        other._$data.containsKey('profileTypeId')) {
      return false;
    }
    if (l$profileTypeId != lOther$profileTypeId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$profileTypeId = profileTypeId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('profileTypeId') ? l$profileTypeId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserProfileOrderBy<TRes> {
  factory CopyWith$Input$UserProfileOrderBy(
    Input$UserProfileOrderBy instance,
    TRes Function(Input$UserProfileOrderBy) then,
  ) = _CopyWithImpl$Input$UserProfileOrderBy;

  factory CopyWith$Input$UserProfileOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserProfileOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? profileTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$UserProfileOrderBy<TRes>
    implements CopyWith$Input$UserProfileOrderBy<TRes> {
  _CopyWithImpl$Input$UserProfileOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserProfileOrderBy _instance;

  final TRes Function(Input$UserProfileOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? profileTypeId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserProfileOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (profileTypeId != _undefined)
          'profileTypeId': (profileTypeId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserProfileOrderBy<TRes>
    implements CopyWith$Input$UserProfileOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserProfileOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? profileTypeId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$UserProfileUpdateInput {
  factory Input$UserProfileUpdateInput({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      Input$UserProfileUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (profileTypeId != null) r'profileTypeId': profileTypeId,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserProfileUpdateInput._(this._$data);

  factory Input$UserProfileUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('profileTypeId')) {
      final l$profileTypeId = data['profileTypeId'];
      result$data['profileTypeId'] = (l$profileTypeId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$UserProfileUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get profileTypeId => (_$data['profileTypeId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('profileTypeId')) {
      final l$profileTypeId = profileTypeId;
      result$data['profileTypeId'] = l$profileTypeId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserProfileUpdateInput<Input$UserProfileUpdateInput>
      get copyWith => CopyWith$Input$UserProfileUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserProfileUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$profileTypeId = profileTypeId;
    final lOther$profileTypeId = other.profileTypeId;
    if (_$data.containsKey('profileTypeId') !=
        other._$data.containsKey('profileTypeId')) {
      return false;
    }
    if (l$profileTypeId != lOther$profileTypeId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$profileTypeId = profileTypeId;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('profileTypeId') ? l$profileTypeId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserProfileUpdateInput<TRes> {
  factory CopyWith$Input$UserProfileUpdateInput(
    Input$UserProfileUpdateInput instance,
    TRes Function(Input$UserProfileUpdateInput) then,
  ) = _CopyWithImpl$Input$UserProfileUpdateInput;

  factory CopyWith$Input$UserProfileUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserProfileUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$UserProfileUpdateInput<TRes>
    implements CopyWith$Input$UserProfileUpdateInput<TRes> {
  _CopyWithImpl$Input$UserProfileUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserProfileUpdateInput _instance;

  final TRes Function(Input$UserProfileUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? profileTypeId = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserProfileUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (profileTypeId != _undefined)
          'profileTypeId': (profileTypeId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserProfileUpdateInput<TRes>
    implements CopyWith$Input$UserProfileUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserProfileUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? profileTypeId,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$UserRoleFilter {
  factory Input$UserRoleFilter({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$UserRoleFilter>? and,
    List<Input$UserRoleFilter>? or,
    Input$UserRoleFilter? not,
  }) =>
      Input$UserRoleFilter._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserRoleFilter._(this._$data);

  factory Input$UserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : Input$UUIDFilter.fromJson((l$roleId as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
              (e) => Input$UserRoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
              (e) => Input$UserRoleFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserRoleFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get roleId => (_$data['roleId'] as Input$UUIDFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserRoleFilter>? get and =>
      (_$data['and'] as List<Input$UserRoleFilter>?);

  List<Input$UserRoleFilter>? get or =>
      (_$data['or'] as List<Input$UserRoleFilter>?);

  Input$UserRoleFilter? get not => (_$data['not'] as Input$UserRoleFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserRoleFilter<Input$UserRoleFilter> get copyWith =>
      CopyWith$Input$UserRoleFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRoleFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$roleId = roleId;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRoleFilter<TRes> {
  factory CopyWith$Input$UserRoleFilter(
    Input$UserRoleFilter instance,
    TRes Function(Input$UserRoleFilter) then,
  ) = _CopyWithImpl$Input$UserRoleFilter;

  factory CopyWith$Input$UserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRoleFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$UserRoleFilter>? and,
    List<Input$UserRoleFilter>? or,
    Input$UserRoleFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get roleId;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserRoleFilter>? Function(
              Iterable<CopyWith$Input$UserRoleFilter<Input$UserRoleFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserRoleFilter>? Function(
              Iterable<CopyWith$Input$UserRoleFilter<Input$UserRoleFilter>>?)
          _fn);
  CopyWith$Input$UserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserRoleFilter<TRes>
    implements CopyWith$Input$UserRoleFilter<TRes> {
  _CopyWithImpl$Input$UserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$UserRoleFilter _instance;

  final TRes Function(Input$UserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserRoleFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (roleId != _undefined) 'roleId': (roleId as Input$UUIDFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserRoleFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserRoleFilter>?),
        if (not != _undefined) 'not': (not as Input$UserRoleFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get roleId {
    final local$roleId = _instance.roleId;
    return local$roleId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$roleId, (e) => call(roleId: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserRoleFilter<Input$UserRoleFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserRoleFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserRoleFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserRoleFilter<Input$UserRoleFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserRoleFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$UserRoleFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserRoleFilter<TRes>
    implements CopyWith$Input$UserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$UserRoleFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? roleId,
    Input$IDFilter? nodeId,
    List<Input$UserRoleFilter>? and,
    List<Input$UserRoleFilter>? or,
    Input$UserRoleFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get roleId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserRoleFilter<TRes> get not =>
      CopyWith$Input$UserRoleFilter.stub(_res);
}

class Input$UserRoleInsertInput {
  factory Input$UserRoleInsertInput({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  }) =>
      Input$UserRoleInsertInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
        if (data != null) r'data': data,
      });

  Input$UserRoleInsertInput._(this._$data);

  factory Input$UserRoleInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserRoleInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get userId => (_$data['userId'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserRoleInsertInput<Input$UserRoleInsertInput> get copyWith =>
      CopyWith$Input$UserRoleInsertInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRoleInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$roleId = roleId;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRoleInsertInput<TRes> {
  factory CopyWith$Input$UserRoleInsertInput(
    Input$UserRoleInsertInput instance,
    TRes Function(Input$UserRoleInsertInput) then,
  ) = _CopyWithImpl$Input$UserRoleInsertInput;

  factory CopyWith$Input$UserRoleInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRoleInsertInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserRoleInsertInput<TRes>
    implements CopyWith$Input$UserRoleInsertInput<TRes> {
  _CopyWithImpl$Input$UserRoleInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserRoleInsertInput _instance;

  final TRes Function(Input$UserRoleInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserRoleInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserRoleInsertInput<TRes>
    implements CopyWith$Input$UserRoleInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserRoleInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserRoleOrderBy {
  factory Input$UserRoleOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  }) =>
      Input$UserRoleOrderBy._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
      });

  Input$UserRoleOrderBy._(this._$data);

  factory Input$UserRoleOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = l$roleId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$roleId as String));
    }
    return Input$UserRoleOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get roleId =>
      (_$data['roleId'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] =
          l$roleId == null ? null : toJson$Enum$OrderByDirection(l$roleId);
    }
    return result$data;
  }

  CopyWith$Input$UserRoleOrderBy<Input$UserRoleOrderBy> get copyWith =>
      CopyWith$Input$UserRoleOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRoleOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$roleId = roleId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRoleOrderBy<TRes> {
  factory CopyWith$Input$UserRoleOrderBy(
    Input$UserRoleOrderBy instance,
    TRes Function(Input$UserRoleOrderBy) then,
  ) = _CopyWithImpl$Input$UserRoleOrderBy;

  factory CopyWith$Input$UserRoleOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRoleOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  });
}

class _CopyWithImpl$Input$UserRoleOrderBy<TRes>
    implements CopyWith$Input$UserRoleOrderBy<TRes> {
  _CopyWithImpl$Input$UserRoleOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserRoleOrderBy _instance;

  final TRes Function(Input$UserRoleOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
  }) =>
      _then(Input$UserRoleOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (roleId != _undefined) 'roleId': (roleId as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserRoleOrderBy<TRes>
    implements CopyWith$Input$UserRoleOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserRoleOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? roleId,
  }) =>
      _res;
}

class Input$UserRoleUpdateInput {
  factory Input$UserRoleUpdateInput({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  }) =>
      Input$UserRoleUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (userId != null) r'userId': userId,
        if (roleId != null) r'roleId': roleId,
        if (data != null) r'data': data,
      });

  Input$UserRoleUpdateInput._(this._$data);

  factory Input$UserRoleUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('roleId')) {
      final l$roleId = data['roleId'];
      result$data['roleId'] = (l$roleId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserRoleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get userId => (_$data['userId'] as String?);

  String? get roleId => (_$data['roleId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('roleId')) {
      final l$roleId = roleId;
      result$data['roleId'] = l$roleId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserRoleUpdateInput<Input$UserRoleUpdateInput> get copyWith =>
      CopyWith$Input$UserRoleUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRoleUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$roleId = roleId;
    final lOther$roleId = other.roleId;
    if (_$data.containsKey('roleId') != other._$data.containsKey('roleId')) {
      return false;
    }
    if (l$roleId != lOther$roleId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$userId = userId;
    final l$roleId = roleId;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('roleId') ? l$roleId : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRoleUpdateInput<TRes> {
  factory CopyWith$Input$UserRoleUpdateInput(
    Input$UserRoleUpdateInput instance,
    TRes Function(Input$UserRoleUpdateInput) then,
  ) = _CopyWithImpl$Input$UserRoleUpdateInput;

  factory CopyWith$Input$UserRoleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRoleUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserRoleUpdateInput<TRes>
    implements CopyWith$Input$UserRoleUpdateInput<TRes> {
  _CopyWithImpl$Input$UserRoleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserRoleUpdateInput _instance;

  final TRes Function(Input$UserRoleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? userId = _undefined,
    Object? roleId = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserRoleUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (roleId != _undefined) 'roleId': (roleId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserRoleUpdateInput<TRes>
    implements CopyWith$Input$UserRoleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserRoleUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? userId,
    String? roleId,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserSurveyAnswerFilter {
  factory Input$UserSurveyAnswerFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userSurveyId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyQuestionId,
    Input$UUIDFilter? answerChoiceId,
    Input$StringFilter? answerText,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyAnswerFilter>? and,
    List<Input$UserSurveyAnswerFilter>? or,
    Input$UserSurveyAnswerFilter? not,
  }) =>
      Input$UserSurveyAnswerFilter._({
        if (id != null) r'id': id,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyQuestionId != null) r'surveyQuestionId': surveyQuestionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (answerText != null) r'answerText': answerText,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserSurveyAnswerFilter._(this._$data);

  factory Input$UserSurveyAnswerFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userSurveyId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = data['surveyQuestionId'];
      result$data['surveyQuestionId'] = l$surveyQuestionId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$surveyQuestionId as Map<String, dynamic>));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : Input$UUIDFilter.fromJson(
              (l$answerChoiceId as Map<String, dynamic>));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = l$answerText == null
          ? null
          : Input$StringFilter.fromJson((l$answerText as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserSurveyAnswerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserSurveyAnswerFilter.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserSurveyAnswerFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$UserSurveyAnswerFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userSurveyId =>
      (_$data['userSurveyId'] as Input$UUIDFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$UUIDFilter? get surveyQuestionId =>
      (_$data['surveyQuestionId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get answerChoiceId =>
      (_$data['answerChoiceId'] as Input$UUIDFilter?);

  Input$StringFilter? get answerText =>
      (_$data['answerText'] as Input$StringFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserSurveyAnswerFilter>? get and =>
      (_$data['and'] as List<Input$UserSurveyAnswerFilter>?);

  List<Input$UserSurveyAnswerFilter>? get or =>
      (_$data['or'] as List<Input$UserSurveyAnswerFilter>?);

  Input$UserSurveyAnswerFilter? get not =>
      (_$data['not'] as Input$UserSurveyAnswerFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = surveyQuestionId;
      result$data['surveyQuestionId'] = l$surveyQuestionId?.toJson();
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId?.toJson();
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyAnswerFilter<Input$UserSurveyAnswerFilter>
      get copyWith => CopyWith$Input$UserSurveyAnswerFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyAnswerFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyQuestionId = surveyQuestionId;
    final lOther$surveyQuestionId = other.surveyQuestionId;
    if (_$data.containsKey('surveyQuestionId') !=
        other._$data.containsKey('surveyQuestionId')) {
      return false;
    }
    if (l$surveyQuestionId != lOther$surveyQuestionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userSurveyId = userSurveyId;
    final l$createdAt = createdAt;
    final l$surveyQuestionId = surveyQuestionId;
    final l$answerChoiceId = answerChoiceId;
    final l$answerText = answerText;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyQuestionId') ? l$surveyQuestionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyAnswerFilter<TRes> {
  factory CopyWith$Input$UserSurveyAnswerFilter(
    Input$UserSurveyAnswerFilter instance,
    TRes Function(Input$UserSurveyAnswerFilter) then,
  ) = _CopyWithImpl$Input$UserSurveyAnswerFilter;

  factory CopyWith$Input$UserSurveyAnswerFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyAnswerFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userSurveyId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyQuestionId,
    Input$UUIDFilter? answerChoiceId,
    Input$StringFilter? answerText,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyAnswerFilter>? and,
    List<Input$UserSurveyAnswerFilter>? or,
    Input$UserSurveyAnswerFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userSurveyId;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$UUIDFilter<TRes> get surveyQuestionId;
  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId;
  CopyWith$Input$StringFilter<TRes> get answerText;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserSurveyAnswerFilter>? Function(
              Iterable<
                  CopyWith$Input$UserSurveyAnswerFilter<
                      Input$UserSurveyAnswerFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserSurveyAnswerFilter>? Function(
              Iterable<
                  CopyWith$Input$UserSurveyAnswerFilter<
                      Input$UserSurveyAnswerFilter>>?)
          _fn);
  CopyWith$Input$UserSurveyAnswerFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserSurveyAnswerFilter<TRes>
    implements CopyWith$Input$UserSurveyAnswerFilter<TRes> {
  _CopyWithImpl$Input$UserSurveyAnswerFilter(
    this._instance,
    this._then,
  );

  final Input$UserSurveyAnswerFilter _instance;

  final TRes Function(Input$UserSurveyAnswerFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userSurveyId = _undefined,
    Object? createdAt = _undefined,
    Object? surveyQuestionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? answerText = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserSurveyAnswerFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as Input$UUIDFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (surveyQuestionId != _undefined)
          'surveyQuestionId': (surveyQuestionId as Input$UUIDFilter?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Input$UUIDFilter?),
        if (answerText != _undefined)
          'answerText': (answerText as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$UserSurveyAnswerFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserSurveyAnswerFilter>?),
        if (not != _undefined) 'not': (not as Input$UserSurveyAnswerFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userSurveyId {
    final local$userSurveyId = _instance.userSurveyId;
    return local$userSurveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$userSurveyId, (e) => call(userSurveyId: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get surveyQuestionId {
    final local$surveyQuestionId = _instance.surveyQuestionId;
    return local$surveyQuestionId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$surveyQuestionId, (e) => call(surveyQuestionId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId {
    final local$answerChoiceId = _instance.answerChoiceId;
    return local$answerChoiceId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(
            local$answerChoiceId, (e) => call(answerChoiceId: e));
  }

  CopyWith$Input$StringFilter<TRes> get answerText {
    final local$answerText = _instance.answerText;
    return local$answerText == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$answerText, (e) => call(answerText: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserSurveyAnswerFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserSurveyAnswerFilter<
                          Input$UserSurveyAnswerFilter>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$UserSurveyAnswerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$UserSurveyAnswerFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserSurveyAnswerFilter<
                          Input$UserSurveyAnswerFilter>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$UserSurveyAnswerFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UserSurveyAnswerFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserSurveyAnswerFilter.stub(_then(_instance))
        : CopyWith$Input$UserSurveyAnswerFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserSurveyAnswerFilter<TRes>
    implements CopyWith$Input$UserSurveyAnswerFilter<TRes> {
  _CopyWithStubImpl$Input$UserSurveyAnswerFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userSurveyId,
    Input$DatetimeFilter? createdAt,
    Input$UUIDFilter? surveyQuestionId,
    Input$UUIDFilter? answerChoiceId,
    Input$StringFilter? answerText,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyAnswerFilter>? and,
    List<Input$UserSurveyAnswerFilter>? or,
    Input$UserSurveyAnswerFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userSurveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get surveyQuestionId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get answerChoiceId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get answerText =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserSurveyAnswerFilter<TRes> get not =>
      CopyWith$Input$UserSurveyAnswerFilter.stub(_res);
}

class Input$UserSurveyAnswerInsertInput {
  factory Input$UserSurveyAnswerInsertInput({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  }) =>
      Input$UserSurveyAnswerInsertInput._({
        if (id != null) r'id': id,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyQuestionId != null) r'surveyQuestionId': surveyQuestionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (data != null) r'data': data,
        if (answerText != null) r'answerText': answerText,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserSurveyAnswerInsertInput._(this._$data);

  factory Input$UserSurveyAnswerInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = (l$userSurveyId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = data['surveyQuestionId'];
      result$data['surveyQuestionId'] = (l$surveyQuestionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = (l$answerText as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$UserSurveyAnswerInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userSurveyId => (_$data['userSurveyId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get surveyQuestionId => (_$data['surveyQuestionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get answerText => (_$data['answerText'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = surveyQuestionId;
      result$data['surveyQuestionId'] = l$surveyQuestionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyAnswerInsertInput<Input$UserSurveyAnswerInsertInput>
      get copyWith => CopyWith$Input$UserSurveyAnswerInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyAnswerInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyQuestionId = surveyQuestionId;
    final lOther$surveyQuestionId = other.surveyQuestionId;
    if (_$data.containsKey('surveyQuestionId') !=
        other._$data.containsKey('surveyQuestionId')) {
      return false;
    }
    if (l$surveyQuestionId != lOther$surveyQuestionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userSurveyId = userSurveyId;
    final l$createdAt = createdAt;
    final l$surveyQuestionId = surveyQuestionId;
    final l$answerChoiceId = answerChoiceId;
    final l$data = data;
    final l$answerText = answerText;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyQuestionId') ? l$surveyQuestionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyAnswerInsertInput<TRes> {
  factory CopyWith$Input$UserSurveyAnswerInsertInput(
    Input$UserSurveyAnswerInsertInput instance,
    TRes Function(Input$UserSurveyAnswerInsertInput) then,
  ) = _CopyWithImpl$Input$UserSurveyAnswerInsertInput;

  factory CopyWith$Input$UserSurveyAnswerInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyAnswerInsertInput;

  TRes call({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSurveyAnswerInsertInput<TRes>
    implements CopyWith$Input$UserSurveyAnswerInsertInput<TRes> {
  _CopyWithImpl$Input$UserSurveyAnswerInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserSurveyAnswerInsertInput _instance;

  final TRes Function(Input$UserSurveyAnswerInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userSurveyId = _undefined,
    Object? createdAt = _undefined,
    Object? surveyQuestionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? data = _undefined,
    Object? answerText = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserSurveyAnswerInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (surveyQuestionId != _undefined)
          'surveyQuestionId': (surveyQuestionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (answerText != _undefined) 'answerText': (answerText as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyAnswerInsertInput<TRes>
    implements CopyWith$Input$UserSurveyAnswerInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserSurveyAnswerInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$UserSurveyAnswerOrderBy {
  factory Input$UserSurveyAnswerOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyQuestionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? answerText,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$UserSurveyAnswerOrderBy._({
        if (id != null) r'id': id,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyQuestionId != null) r'surveyQuestionId': surveyQuestionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (answerText != null) r'answerText': answerText,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserSurveyAnswerOrderBy._(this._$data);

  factory Input$UserSurveyAnswerOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userSurveyId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = data['surveyQuestionId'];
      result$data['surveyQuestionId'] = l$surveyQuestionId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$surveyQuestionId as String));
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$answerChoiceId as String));
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = l$answerText == null
          ? null
          : fromJson$Enum$OrderByDirection((l$answerText as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$UserSurveyAnswerOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userSurveyId =>
      (_$data['userSurveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get surveyQuestionId =>
      (_$data['surveyQuestionId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get answerChoiceId =>
      (_$data['answerChoiceId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get answerText =>
      (_$data['answerText'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId == null
          ? null
          : toJson$Enum$OrderByDirection(l$userSurveyId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = surveyQuestionId;
      result$data['surveyQuestionId'] = l$surveyQuestionId == null
          ? null
          : toJson$Enum$OrderByDirection(l$surveyQuestionId);
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId == null
          ? null
          : toJson$Enum$OrderByDirection(l$answerChoiceId);
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText == null
          ? null
          : toJson$Enum$OrderByDirection(l$answerText);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyAnswerOrderBy<Input$UserSurveyAnswerOrderBy>
      get copyWith => CopyWith$Input$UserSurveyAnswerOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyAnswerOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyQuestionId = surveyQuestionId;
    final lOther$surveyQuestionId = other.surveyQuestionId;
    if (_$data.containsKey('surveyQuestionId') !=
        other._$data.containsKey('surveyQuestionId')) {
      return false;
    }
    if (l$surveyQuestionId != lOther$surveyQuestionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userSurveyId = userSurveyId;
    final l$createdAt = createdAt;
    final l$surveyQuestionId = surveyQuestionId;
    final l$answerChoiceId = answerChoiceId;
    final l$answerText = answerText;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyQuestionId') ? l$surveyQuestionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyAnswerOrderBy<TRes> {
  factory CopyWith$Input$UserSurveyAnswerOrderBy(
    Input$UserSurveyAnswerOrderBy instance,
    TRes Function(Input$UserSurveyAnswerOrderBy) then,
  ) = _CopyWithImpl$Input$UserSurveyAnswerOrderBy;

  factory CopyWith$Input$UserSurveyAnswerOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyAnswerOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyQuestionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? answerText,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSurveyAnswerOrderBy<TRes>
    implements CopyWith$Input$UserSurveyAnswerOrderBy<TRes> {
  _CopyWithImpl$Input$UserSurveyAnswerOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserSurveyAnswerOrderBy _instance;

  final TRes Function(Input$UserSurveyAnswerOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userSurveyId = _undefined,
    Object? createdAt = _undefined,
    Object? surveyQuestionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? answerText = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserSurveyAnswerOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (surveyQuestionId != _undefined)
          'surveyQuestionId': (surveyQuestionId as Enum$OrderByDirection?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as Enum$OrderByDirection?),
        if (answerText != _undefined)
          'answerText': (answerText as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyAnswerOrderBy<TRes>
    implements CopyWith$Input$UserSurveyAnswerOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserSurveyAnswerOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userSurveyId,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? surveyQuestionId,
    Enum$OrderByDirection? answerChoiceId,
    Enum$OrderByDirection? answerText,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$UserSurveyAnswerUpdateInput {
  factory Input$UserSurveyAnswerUpdateInput({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  }) =>
      Input$UserSurveyAnswerUpdateInput._({
        if (id != null) r'id': id,
        if (userSurveyId != null) r'userSurveyId': userSurveyId,
        if (createdAt != null) r'createdAt': createdAt,
        if (surveyQuestionId != null) r'surveyQuestionId': surveyQuestionId,
        if (answerChoiceId != null) r'answerChoiceId': answerChoiceId,
        if (data != null) r'data': data,
        if (answerText != null) r'answerText': answerText,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserSurveyAnswerUpdateInput._(this._$data);

  factory Input$UserSurveyAnswerUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userSurveyId')) {
      final l$userSurveyId = data['userSurveyId'];
      result$data['userSurveyId'] = (l$userSurveyId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = data['surveyQuestionId'];
      result$data['surveyQuestionId'] = (l$surveyQuestionId as String?);
    }
    if (data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = data['answerChoiceId'];
      result$data['answerChoiceId'] = (l$answerChoiceId as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('answerText')) {
      final l$answerText = data['answerText'];
      result$data['answerText'] = (l$answerText as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    return Input$UserSurveyAnswerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userSurveyId => (_$data['userSurveyId'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get surveyQuestionId => (_$data['surveyQuestionId'] as String?);

  String? get answerChoiceId => (_$data['answerChoiceId'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get answerText => (_$data['answerText'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userSurveyId')) {
      final l$userSurveyId = userSurveyId;
      result$data['userSurveyId'] = l$userSurveyId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('surveyQuestionId')) {
      final l$surveyQuestionId = surveyQuestionId;
      result$data['surveyQuestionId'] = l$surveyQuestionId;
    }
    if (_$data.containsKey('answerChoiceId')) {
      final l$answerChoiceId = answerChoiceId;
      result$data['answerChoiceId'] = l$answerChoiceId;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('answerText')) {
      final l$answerText = answerText;
      result$data['answerText'] = l$answerText;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyAnswerUpdateInput<Input$UserSurveyAnswerUpdateInput>
      get copyWith => CopyWith$Input$UserSurveyAnswerUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyAnswerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userSurveyId = userSurveyId;
    final lOther$userSurveyId = other.userSurveyId;
    if (_$data.containsKey('userSurveyId') !=
        other._$data.containsKey('userSurveyId')) {
      return false;
    }
    if (l$userSurveyId != lOther$userSurveyId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$surveyQuestionId = surveyQuestionId;
    final lOther$surveyQuestionId = other.surveyQuestionId;
    if (_$data.containsKey('surveyQuestionId') !=
        other._$data.containsKey('surveyQuestionId')) {
      return false;
    }
    if (l$surveyQuestionId != lOther$surveyQuestionId) {
      return false;
    }
    final l$answerChoiceId = answerChoiceId;
    final lOther$answerChoiceId = other.answerChoiceId;
    if (_$data.containsKey('answerChoiceId') !=
        other._$data.containsKey('answerChoiceId')) {
      return false;
    }
    if (l$answerChoiceId != lOther$answerChoiceId) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$answerText = answerText;
    final lOther$answerText = other.answerText;
    if (_$data.containsKey('answerText') !=
        other._$data.containsKey('answerText')) {
      return false;
    }
    if (l$answerText != lOther$answerText) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userSurveyId = userSurveyId;
    final l$createdAt = createdAt;
    final l$surveyQuestionId = surveyQuestionId;
    final l$answerChoiceId = answerChoiceId;
    final l$data = data;
    final l$answerText = answerText;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userSurveyId') ? l$userSurveyId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('surveyQuestionId') ? l$surveyQuestionId : const {},
      _$data.containsKey('answerChoiceId') ? l$answerChoiceId : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('answerText') ? l$answerText : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyAnswerUpdateInput<TRes> {
  factory CopyWith$Input$UserSurveyAnswerUpdateInput(
    Input$UserSurveyAnswerUpdateInput instance,
    TRes Function(Input$UserSurveyAnswerUpdateInput) then,
  ) = _CopyWithImpl$Input$UserSurveyAnswerUpdateInput;

  factory CopyWith$Input$UserSurveyAnswerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyAnswerUpdateInput;

  TRes call({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSurveyAnswerUpdateInput<TRes>
    implements CopyWith$Input$UserSurveyAnswerUpdateInput<TRes> {
  _CopyWithImpl$Input$UserSurveyAnswerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserSurveyAnswerUpdateInput _instance;

  final TRes Function(Input$UserSurveyAnswerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userSurveyId = _undefined,
    Object? createdAt = _undefined,
    Object? surveyQuestionId = _undefined,
    Object? answerChoiceId = _undefined,
    Object? data = _undefined,
    Object? answerText = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserSurveyAnswerUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userSurveyId != _undefined)
          'userSurveyId': (userSurveyId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (surveyQuestionId != _undefined)
          'surveyQuestionId': (surveyQuestionId as String?),
        if (answerChoiceId != _undefined)
          'answerChoiceId': (answerChoiceId as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (answerText != _undefined) 'answerText': (answerText as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyAnswerUpdateInput<TRes>
    implements CopyWith$Input$UserSurveyAnswerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserSurveyAnswerUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userSurveyId,
    DateTime? createdAt,
    String? surveyQuestionId,
    String? answerChoiceId,
    Map<String, dynamic>? data,
    String? answerText,
    DateTime? updatedAt,
  }) =>
      _res;
}

class Input$UserSurveyFilter {
  factory Input$UserSurveyFilter({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isComplete,
    Input$DatetimeFilter? completedAt,
    Input$BooleanFilter? isAbandoned,
    Input$DatetimeFilter? abandonedAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyFilter>? and,
    List<Input$UserSurveyFilter>? or,
    Input$UserSurveyFilter? not,
  }) =>
      Input$UserSurveyFilter._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (surveyId != null) r'surveyId': surveyId,
        if (isStarted != null) r'isStarted': isStarted,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (isComplete != null) r'isComplete': isComplete,
        if (completedAt != null) r'completedAt': completedAt,
        if (isAbandoned != null) r'isAbandoned': isAbandoned,
        if (abandonedAt != null) r'abandonedAt': abandonedAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$UserSurveyFilter._(this._$data);

  factory Input$UserSurveyFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$UUIDFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : Input$UUIDFilter.fromJson((l$surveyId as Map<String, dynamic>));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : Input$BooleanFilter.fromJson((l$isStarted as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$startedAt as Map<String, dynamic>));
    }
    if (data.containsKey('isComplete')) {
      final l$isComplete = data['isComplete'];
      result$data['isComplete'] = l$isComplete == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isComplete as Map<String, dynamic>));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$completedAt as Map<String, dynamic>));
    }
    if (data.containsKey('isAbandoned')) {
      final l$isAbandoned = data['isAbandoned'];
      result$data['isAbandoned'] = l$isAbandoned == null
          ? null
          : Input$BooleanFilter.fromJson(
              (l$isAbandoned as Map<String, dynamic>));
    }
    if (data.containsKey('abandonedAt')) {
      final l$abandonedAt = data['abandonedAt'];
      result$data['abandonedAt'] = l$abandonedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$abandonedAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$UserSurveyFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$UserSurveyFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$UserSurveyFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$UserSurveyFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$UUIDFilter? get userId => (_$data['userId'] as Input$UUIDFilter?);

  Input$UUIDFilter? get surveyId => (_$data['surveyId'] as Input$UUIDFilter?);

  Input$BooleanFilter? get isStarted =>
      (_$data['isStarted'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get startedAt =>
      (_$data['startedAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isComplete =>
      (_$data['isComplete'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get completedAt =>
      (_$data['completedAt'] as Input$DatetimeFilter?);

  Input$BooleanFilter? get isAbandoned =>
      (_$data['isAbandoned'] as Input$BooleanFilter?);

  Input$DatetimeFilter? get abandonedAt =>
      (_$data['abandonedAt'] as Input$DatetimeFilter?);

  Input$DatetimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DatetimeFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$UserSurveyFilter>? get and =>
      (_$data['and'] as List<Input$UserSurveyFilter>?);

  List<Input$UserSurveyFilter>? get or =>
      (_$data['or'] as List<Input$UserSurveyFilter>?);

  Input$UserSurveyFilter? get not => (_$data['not'] as Input$UserSurveyFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId?.toJson();
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toJson();
    }
    if (_$data.containsKey('isComplete')) {
      final l$isComplete = isComplete;
      result$data['isComplete'] = l$isComplete?.toJson();
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toJson();
    }
    if (_$data.containsKey('isAbandoned')) {
      final l$isAbandoned = isAbandoned;
      result$data['isAbandoned'] = l$isAbandoned?.toJson();
    }
    if (_$data.containsKey('abandonedAt')) {
      final l$abandonedAt = abandonedAt;
      result$data['abandonedAt'] = l$abandonedAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyFilter<Input$UserSurveyFilter> get copyWith =>
      CopyWith$Input$UserSurveyFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isComplete = isComplete;
    final lOther$isComplete = other.isComplete;
    if (_$data.containsKey('isComplete') !=
        other._$data.containsKey('isComplete')) {
      return false;
    }
    if (l$isComplete != lOther$isComplete) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isAbandoned = isAbandoned;
    final lOther$isAbandoned = other.isAbandoned;
    if (_$data.containsKey('isAbandoned') !=
        other._$data.containsKey('isAbandoned')) {
      return false;
    }
    if (l$isAbandoned != lOther$isAbandoned) {
      return false;
    }
    final l$abandonedAt = abandonedAt;
    final lOther$abandonedAt = other.abandonedAt;
    if (_$data.containsKey('abandonedAt') !=
        other._$data.containsKey('abandonedAt')) {
      return false;
    }
    if (l$abandonedAt != lOther$abandonedAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$surveyId = surveyId;
    final l$isStarted = isStarted;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$isComplete = isComplete;
    final l$completedAt = completedAt;
    final l$isAbandoned = isAbandoned;
    final l$abandonedAt = abandonedAt;
    final l$updatedAt = updatedAt;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isComplete') ? l$isComplete : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isAbandoned') ? l$isAbandoned : const {},
      _$data.containsKey('abandonedAt') ? l$abandonedAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyFilter<TRes> {
  factory CopyWith$Input$UserSurveyFilter(
    Input$UserSurveyFilter instance,
    TRes Function(Input$UserSurveyFilter) then,
  ) = _CopyWithImpl$Input$UserSurveyFilter;

  factory CopyWith$Input$UserSurveyFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isComplete,
    Input$DatetimeFilter? completedAt,
    Input$BooleanFilter? isAbandoned,
    Input$DatetimeFilter? abandonedAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyFilter>? and,
    List<Input$UserSurveyFilter>? or,
    Input$UserSurveyFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$UUIDFilter<TRes> get userId;
  CopyWith$Input$UUIDFilter<TRes> get surveyId;
  CopyWith$Input$BooleanFilter<TRes> get isStarted;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$DatetimeFilter<TRes> get startedAt;
  CopyWith$Input$BooleanFilter<TRes> get isComplete;
  CopyWith$Input$DatetimeFilter<TRes> get completedAt;
  CopyWith$Input$BooleanFilter<TRes> get isAbandoned;
  CopyWith$Input$DatetimeFilter<TRes> get abandonedAt;
  CopyWith$Input$DatetimeFilter<TRes> get updatedAt;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$UserSurveyFilter>? Function(
              Iterable<
                  CopyWith$Input$UserSurveyFilter<Input$UserSurveyFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$UserSurveyFilter>? Function(
              Iterable<
                  CopyWith$Input$UserSurveyFilter<Input$UserSurveyFilter>>?)
          _fn);
  CopyWith$Input$UserSurveyFilter<TRes> get not;
}

class _CopyWithImpl$Input$UserSurveyFilter<TRes>
    implements CopyWith$Input$UserSurveyFilter<TRes> {
  _CopyWithImpl$Input$UserSurveyFilter(
    this._instance,
    this._then,
  );

  final Input$UserSurveyFilter _instance;

  final TRes Function(Input$UserSurveyFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? surveyId = _undefined,
    Object? isStarted = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? isComplete = _undefined,
    Object? completedAt = _undefined,
    Object? isAbandoned = _undefined,
    Object? abandonedAt = _undefined,
    Object? updatedAt = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$UserSurveyFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (userId != _undefined) 'userId': (userId as Input$UUIDFilter?),
        if (surveyId != _undefined) 'surveyId': (surveyId as Input$UUIDFilter?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Input$BooleanFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Input$DatetimeFilter?),
        if (isComplete != _undefined)
          'isComplete': (isComplete as Input$BooleanFilter?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Input$DatetimeFilter?),
        if (isAbandoned != _undefined)
          'isAbandoned': (isAbandoned as Input$BooleanFilter?),
        if (abandonedAt != _undefined)
          'abandonedAt': (abandonedAt as Input$DatetimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DatetimeFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined) 'and': (and as List<Input$UserSurveyFilter>?),
        if (or != _undefined) 'or': (or as List<Input$UserSurveyFilter>?),
        if (not != _undefined) 'not': (not as Input$UserSurveyFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$UUIDFilter<TRes> get surveyId {
    final local$surveyId = _instance.surveyId;
    return local$surveyId == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$surveyId, (e) => call(surveyId: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isStarted {
    final local$isStarted = _instance.isStarted;
    return local$isStarted == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isStarted, (e) => call(isStarted: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get startedAt {
    final local$startedAt = _instance.startedAt;
    return local$startedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$startedAt, (e) => call(startedAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isComplete {
    final local$isComplete = _instance.isComplete;
    return local$isComplete == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isComplete, (e) => call(isComplete: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get completedAt {
    final local$completedAt = _instance.completedAt;
    return local$completedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$completedAt, (e) => call(completedAt: e));
  }

  CopyWith$Input$BooleanFilter<TRes> get isAbandoned {
    final local$isAbandoned = _instance.isAbandoned;
    return local$isAbandoned == null
        ? CopyWith$Input$BooleanFilter.stub(_then(_instance))
        : CopyWith$Input$BooleanFilter(
            local$isAbandoned, (e) => call(isAbandoned: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get abandonedAt {
    final local$abandonedAt = _instance.abandonedAt;
    return local$abandonedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$abandonedAt, (e) => call(abandonedAt: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$UserSurveyFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserSurveyFilter<Input$UserSurveyFilter>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$UserSurveyFilter(
                e,
                (i) => i,
              )))?.toList());

  TRes or(
          Iterable<Input$UserSurveyFilter>? Function(
                  Iterable<
                      CopyWith$Input$UserSurveyFilter<Input$UserSurveyFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$UserSurveyFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UserSurveyFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$UserSurveyFilter.stub(_then(_instance))
        : CopyWith$Input$UserSurveyFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UserSurveyFilter<TRes>
    implements CopyWith$Input$UserSurveyFilter<TRes> {
  _CopyWithStubImpl$Input$UserSurveyFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$UUIDFilter? userId,
    Input$UUIDFilter? surveyId,
    Input$BooleanFilter? isStarted,
    Input$DatetimeFilter? createdAt,
    Input$DatetimeFilter? startedAt,
    Input$BooleanFilter? isComplete,
    Input$DatetimeFilter? completedAt,
    Input$BooleanFilter? isAbandoned,
    Input$DatetimeFilter? abandonedAt,
    Input$DatetimeFilter? updatedAt,
    Input$IDFilter? nodeId,
    List<Input$UserSurveyFilter>? and,
    List<Input$UserSurveyFilter>? or,
    Input$UserSurveyFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get userId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$UUIDFilter<TRes> get surveyId =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isStarted =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get startedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isComplete =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get completedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$BooleanFilter<TRes> get isAbandoned =>
      CopyWith$Input$BooleanFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get abandonedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserSurveyFilter<TRes> get not =>
      CopyWith$Input$UserSurveyFilter.stub(_res);
}

class Input$UserSurveyInsertInput {
  factory Input$UserSurveyInsertInput({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserSurveyInsertInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (surveyId != null) r'surveyId': surveyId,
        if (isStarted != null) r'isStarted': isStarted,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (isComplete != null) r'isComplete': isComplete,
        if (completedAt != null) r'completedAt': completedAt,
        if (isAbandoned != null) r'isAbandoned': isAbandoned,
        if (abandonedAt != null) r'abandonedAt': abandonedAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (data != null) r'data': data,
      });

  Input$UserSurveyInsertInput._(this._$data);

  factory Input$UserSurveyInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('isComplete')) {
      final l$isComplete = data['isComplete'];
      result$data['isComplete'] = (l$isComplete as bool?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('isAbandoned')) {
      final l$isAbandoned = data['isAbandoned'];
      result$data['isAbandoned'] = (l$isAbandoned as bool?);
    }
    if (data.containsKey('abandonedAt')) {
      final l$abandonedAt = data['abandonedAt'];
      result$data['abandonedAt'] = l$abandonedAt == null
          ? null
          : DateTime.parse((l$abandonedAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserSurveyInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  bool? get isComplete => (_$data['isComplete'] as bool?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  bool? get isAbandoned => (_$data['isAbandoned'] as bool?);

  DateTime? get abandonedAt => (_$data['abandonedAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('isComplete')) {
      final l$isComplete = isComplete;
      result$data['isComplete'] = l$isComplete;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('isAbandoned')) {
      final l$isAbandoned = isAbandoned;
      result$data['isAbandoned'] = l$isAbandoned;
    }
    if (_$data.containsKey('abandonedAt')) {
      final l$abandonedAt = abandonedAt;
      result$data['abandonedAt'] = l$abandonedAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyInsertInput<Input$UserSurveyInsertInput>
      get copyWith => CopyWith$Input$UserSurveyInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isComplete = isComplete;
    final lOther$isComplete = other.isComplete;
    if (_$data.containsKey('isComplete') !=
        other._$data.containsKey('isComplete')) {
      return false;
    }
    if (l$isComplete != lOther$isComplete) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isAbandoned = isAbandoned;
    final lOther$isAbandoned = other.isAbandoned;
    if (_$data.containsKey('isAbandoned') !=
        other._$data.containsKey('isAbandoned')) {
      return false;
    }
    if (l$isAbandoned != lOther$isAbandoned) {
      return false;
    }
    final l$abandonedAt = abandonedAt;
    final lOther$abandonedAt = other.abandonedAt;
    if (_$data.containsKey('abandonedAt') !=
        other._$data.containsKey('abandonedAt')) {
      return false;
    }
    if (l$abandonedAt != lOther$abandonedAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$surveyId = surveyId;
    final l$isStarted = isStarted;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$isComplete = isComplete;
    final l$completedAt = completedAt;
    final l$isAbandoned = isAbandoned;
    final l$abandonedAt = abandonedAt;
    final l$updatedAt = updatedAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isComplete') ? l$isComplete : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isAbandoned') ? l$isAbandoned : const {},
      _$data.containsKey('abandonedAt') ? l$abandonedAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyInsertInput<TRes> {
  factory CopyWith$Input$UserSurveyInsertInput(
    Input$UserSurveyInsertInput instance,
    TRes Function(Input$UserSurveyInsertInput) then,
  ) = _CopyWithImpl$Input$UserSurveyInsertInput;

  factory CopyWith$Input$UserSurveyInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyInsertInput;

  TRes call({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserSurveyInsertInput<TRes>
    implements CopyWith$Input$UserSurveyInsertInput<TRes> {
  _CopyWithImpl$Input$UserSurveyInsertInput(
    this._instance,
    this._then,
  );

  final Input$UserSurveyInsertInput _instance;

  final TRes Function(Input$UserSurveyInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? surveyId = _undefined,
    Object? isStarted = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? isComplete = _undefined,
    Object? completedAt = _undefined,
    Object? isAbandoned = _undefined,
    Object? abandonedAt = _undefined,
    Object? updatedAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserSurveyInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (isComplete != _undefined) 'isComplete': (isComplete as bool?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (isAbandoned != _undefined) 'isAbandoned': (isAbandoned as bool?),
        if (abandonedAt != _undefined)
          'abandonedAt': (abandonedAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyInsertInput<TRes>
    implements CopyWith$Input$UserSurveyInsertInput<TRes> {
  _CopyWithStubImpl$Input$UserSurveyInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserSurveyOrderBy {
  factory Input$UserSurveyOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isComplete,
    Enum$OrderByDirection? completedAt,
    Enum$OrderByDirection? isAbandoned,
    Enum$OrderByDirection? abandonedAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      Input$UserSurveyOrderBy._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (surveyId != null) r'surveyId': surveyId,
        if (isStarted != null) r'isStarted': isStarted,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (isComplete != null) r'isComplete': isComplete,
        if (completedAt != null) r'completedAt': completedAt,
        if (isAbandoned != null) r'isAbandoned': isAbandoned,
        if (abandonedAt != null) r'abandonedAt': abandonedAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$UserSurveyOrderBy._(this._$data);

  factory Input$UserSurveyOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$userId as String));
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = l$surveyId == null
          ? null
          : fromJson$Enum$OrderByDirection((l$surveyId as String));
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = l$isStarted == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isStarted as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = l$startedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$startedAt as String));
    }
    if (data.containsKey('isComplete')) {
      final l$isComplete = data['isComplete'];
      result$data['isComplete'] = l$isComplete == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isComplete as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$completedAt as String));
    }
    if (data.containsKey('isAbandoned')) {
      final l$isAbandoned = data['isAbandoned'];
      result$data['isAbandoned'] = l$isAbandoned == null
          ? null
          : fromJson$Enum$OrderByDirection((l$isAbandoned as String));
    }
    if (data.containsKey('abandonedAt')) {
      final l$abandonedAt = data['abandonedAt'];
      result$data['abandonedAt'] = l$abandonedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$abandonedAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$updatedAt as String));
    }
    return Input$UserSurveyOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get userId =>
      (_$data['userId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get surveyId =>
      (_$data['surveyId'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isStarted =>
      (_$data['isStarted'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get startedAt =>
      (_$data['startedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isComplete =>
      (_$data['isComplete'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get completedAt =>
      (_$data['completedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get isAbandoned =>
      (_$data['isAbandoned'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get abandonedAt =>
      (_$data['abandonedAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get updatedAt =>
      (_$data['updatedAt'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$OrderByDirection(l$userId);
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] =
          l$surveyId == null ? null : toJson$Enum$OrderByDirection(l$surveyId);
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted == null
          ? null
          : toJson$Enum$OrderByDirection(l$isStarted);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$startedAt);
    }
    if (_$data.containsKey('isComplete')) {
      final l$isComplete = isComplete;
      result$data['isComplete'] = l$isComplete == null
          ? null
          : toJson$Enum$OrderByDirection(l$isComplete);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$completedAt);
    }
    if (_$data.containsKey('isAbandoned')) {
      final l$isAbandoned = isAbandoned;
      result$data['isAbandoned'] = l$isAbandoned == null
          ? null
          : toJson$Enum$OrderByDirection(l$isAbandoned);
    }
    if (_$data.containsKey('abandonedAt')) {
      final l$abandonedAt = abandonedAt;
      result$data['abandonedAt'] = l$abandonedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$abandonedAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyOrderBy<Input$UserSurveyOrderBy> get copyWith =>
      CopyWith$Input$UserSurveyOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isComplete = isComplete;
    final lOther$isComplete = other.isComplete;
    if (_$data.containsKey('isComplete') !=
        other._$data.containsKey('isComplete')) {
      return false;
    }
    if (l$isComplete != lOther$isComplete) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isAbandoned = isAbandoned;
    final lOther$isAbandoned = other.isAbandoned;
    if (_$data.containsKey('isAbandoned') !=
        other._$data.containsKey('isAbandoned')) {
      return false;
    }
    if (l$isAbandoned != lOther$isAbandoned) {
      return false;
    }
    final l$abandonedAt = abandonedAt;
    final lOther$abandonedAt = other.abandonedAt;
    if (_$data.containsKey('abandonedAt') !=
        other._$data.containsKey('abandonedAt')) {
      return false;
    }
    if (l$abandonedAt != lOther$abandonedAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$surveyId = surveyId;
    final l$isStarted = isStarted;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$isComplete = isComplete;
    final l$completedAt = completedAt;
    final l$isAbandoned = isAbandoned;
    final l$abandonedAt = abandonedAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isComplete') ? l$isComplete : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isAbandoned') ? l$isAbandoned : const {},
      _$data.containsKey('abandonedAt') ? l$abandonedAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyOrderBy<TRes> {
  factory CopyWith$Input$UserSurveyOrderBy(
    Input$UserSurveyOrderBy instance,
    TRes Function(Input$UserSurveyOrderBy) then,
  ) = _CopyWithImpl$Input$UserSurveyOrderBy;

  factory CopyWith$Input$UserSurveyOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isComplete,
    Enum$OrderByDirection? completedAt,
    Enum$OrderByDirection? isAbandoned,
    Enum$OrderByDirection? abandonedAt,
    Enum$OrderByDirection? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSurveyOrderBy<TRes>
    implements CopyWith$Input$UserSurveyOrderBy<TRes> {
  _CopyWithImpl$Input$UserSurveyOrderBy(
    this._instance,
    this._then,
  );

  final Input$UserSurveyOrderBy _instance;

  final TRes Function(Input$UserSurveyOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? surveyId = _undefined,
    Object? isStarted = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? isComplete = _undefined,
    Object? completedAt = _undefined,
    Object? isAbandoned = _undefined,
    Object? abandonedAt = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$UserSurveyOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (userId != _undefined) 'userId': (userId as Enum$OrderByDirection?),
        if (surveyId != _undefined)
          'surveyId': (surveyId as Enum$OrderByDirection?),
        if (isStarted != _undefined)
          'isStarted': (isStarted as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (startedAt != _undefined)
          'startedAt': (startedAt as Enum$OrderByDirection?),
        if (isComplete != _undefined)
          'isComplete': (isComplete as Enum$OrderByDirection?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as Enum$OrderByDirection?),
        if (isAbandoned != _undefined)
          'isAbandoned': (isAbandoned as Enum$OrderByDirection?),
        if (abandonedAt != _undefined)
          'abandonedAt': (abandonedAt as Enum$OrderByDirection?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyOrderBy<TRes>
    implements CopyWith$Input$UserSurveyOrderBy<TRes> {
  _CopyWithStubImpl$Input$UserSurveyOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? userId,
    Enum$OrderByDirection? surveyId,
    Enum$OrderByDirection? isStarted,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? startedAt,
    Enum$OrderByDirection? isComplete,
    Enum$OrderByDirection? completedAt,
    Enum$OrderByDirection? isAbandoned,
    Enum$OrderByDirection? abandonedAt,
    Enum$OrderByDirection? updatedAt,
  }) =>
      _res;
}

class Input$UserSurveyUpdateInput {
  factory Input$UserSurveyUpdateInput({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  }) =>
      Input$UserSurveyUpdateInput._({
        if (id != null) r'id': id,
        if (userId != null) r'userId': userId,
        if (surveyId != null) r'surveyId': surveyId,
        if (isStarted != null) r'isStarted': isStarted,
        if (createdAt != null) r'createdAt': createdAt,
        if (startedAt != null) r'startedAt': startedAt,
        if (isComplete != null) r'isComplete': isComplete,
        if (completedAt != null) r'completedAt': completedAt,
        if (isAbandoned != null) r'isAbandoned': isAbandoned,
        if (abandonedAt != null) r'abandonedAt': abandonedAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (data != null) r'data': data,
      });

  Input$UserSurveyUpdateInput._(this._$data);

  factory Input$UserSurveyUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('surveyId')) {
      final l$surveyId = data['surveyId'];
      result$data['surveyId'] = (l$surveyId as String?);
    }
    if (data.containsKey('isStarted')) {
      final l$isStarted = data['isStarted'];
      result$data['isStarted'] = (l$isStarted as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('isComplete')) {
      final l$isComplete = data['isComplete'];
      result$data['isComplete'] = (l$isComplete as bool?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('isAbandoned')) {
      final l$isAbandoned = data['isAbandoned'];
      result$data['isAbandoned'] = (l$isAbandoned as bool?);
    }
    if (data.containsKey('abandonedAt')) {
      final l$abandonedAt = data['abandonedAt'];
      result$data['abandonedAt'] = l$abandonedAt == null
          ? null
          : DateTime.parse((l$abandonedAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    return Input$UserSurveyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get surveyId => (_$data['surveyId'] as String?);

  bool? get isStarted => (_$data['isStarted'] as bool?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);

  bool? get isComplete => (_$data['isComplete'] as bool?);

  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);

  bool? get isAbandoned => (_$data['isAbandoned'] as bool?);

  DateTime? get abandonedAt => (_$data['abandonedAt'] as DateTime?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('surveyId')) {
      final l$surveyId = surveyId;
      result$data['surveyId'] = l$surveyId;
    }
    if (_$data.containsKey('isStarted')) {
      final l$isStarted = isStarted;
      result$data['isStarted'] = l$isStarted;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('isComplete')) {
      final l$isComplete = isComplete;
      result$data['isComplete'] = l$isComplete;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('isAbandoned')) {
      final l$isAbandoned = isAbandoned;
      result$data['isAbandoned'] = l$isAbandoned;
    }
    if (_$data.containsKey('abandonedAt')) {
      final l$abandonedAt = abandonedAt;
      result$data['abandonedAt'] = l$abandonedAt?.toIso8601String();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    return result$data;
  }

  CopyWith$Input$UserSurveyUpdateInput<Input$UserSurveyUpdateInput>
      get copyWith => CopyWith$Input$UserSurveyUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserSurveyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$surveyId = surveyId;
    final lOther$surveyId = other.surveyId;
    if (_$data.containsKey('surveyId') !=
        other._$data.containsKey('surveyId')) {
      return false;
    }
    if (l$surveyId != lOther$surveyId) {
      return false;
    }
    final l$isStarted = isStarted;
    final lOther$isStarted = other.isStarted;
    if (_$data.containsKey('isStarted') !=
        other._$data.containsKey('isStarted')) {
      return false;
    }
    if (l$isStarted != lOther$isStarted) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$isComplete = isComplete;
    final lOther$isComplete = other.isComplete;
    if (_$data.containsKey('isComplete') !=
        other._$data.containsKey('isComplete')) {
      return false;
    }
    if (l$isComplete != lOther$isComplete) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isAbandoned = isAbandoned;
    final lOther$isAbandoned = other.isAbandoned;
    if (_$data.containsKey('isAbandoned') !=
        other._$data.containsKey('isAbandoned')) {
      return false;
    }
    if (l$isAbandoned != lOther$isAbandoned) {
      return false;
    }
    final l$abandonedAt = abandonedAt;
    final lOther$abandonedAt = other.abandonedAt;
    if (_$data.containsKey('abandonedAt') !=
        other._$data.containsKey('abandonedAt')) {
      return false;
    }
    if (l$abandonedAt != lOther$abandonedAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$surveyId = surveyId;
    final l$isStarted = isStarted;
    final l$createdAt = createdAt;
    final l$startedAt = startedAt;
    final l$isComplete = isComplete;
    final l$completedAt = completedAt;
    final l$isAbandoned = isAbandoned;
    final l$abandonedAt = abandonedAt;
    final l$updatedAt = updatedAt;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('surveyId') ? l$surveyId : const {},
      _$data.containsKey('isStarted') ? l$isStarted : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('isComplete') ? l$isComplete : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isAbandoned') ? l$isAbandoned : const {},
      _$data.containsKey('abandonedAt') ? l$abandonedAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSurveyUpdateInput<TRes> {
  factory CopyWith$Input$UserSurveyUpdateInput(
    Input$UserSurveyUpdateInput instance,
    TRes Function(Input$UserSurveyUpdateInput) then,
  ) = _CopyWithImpl$Input$UserSurveyUpdateInput;

  factory CopyWith$Input$UserSurveyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSurveyUpdateInput;

  TRes call({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  });
}

class _CopyWithImpl$Input$UserSurveyUpdateInput<TRes>
    implements CopyWith$Input$UserSurveyUpdateInput<TRes> {
  _CopyWithImpl$Input$UserSurveyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserSurveyUpdateInput _instance;

  final TRes Function(Input$UserSurveyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? surveyId = _undefined,
    Object? isStarted = _undefined,
    Object? createdAt = _undefined,
    Object? startedAt = _undefined,
    Object? isComplete = _undefined,
    Object? completedAt = _undefined,
    Object? isAbandoned = _undefined,
    Object? abandonedAt = _undefined,
    Object? updatedAt = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserSurveyUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (surveyId != _undefined) 'surveyId': (surveyId as String?),
        if (isStarted != _undefined) 'isStarted': (isStarted as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (isComplete != _undefined) 'isComplete': (isComplete as bool?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (isAbandoned != _undefined) 'isAbandoned': (isAbandoned as bool?),
        if (abandonedAt != _undefined)
          'abandonedAt': (abandonedAt as DateTime?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$Input$UserSurveyUpdateInput<TRes>
    implements CopyWith$Input$UserSurveyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserSurveyUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? userId,
    String? surveyId,
    bool? isStarted,
    DateTime? createdAt,
    DateTime? startedAt,
    bool? isComplete,
    DateTime? completedAt,
    bool? isAbandoned,
    DateTime? abandonedAt,
    DateTime? updatedAt,
    Map<String, dynamic>? data,
  }) =>
      _res;
}

class Input$UserUpdateInput {
  factory Input$UserUpdateInput({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  }) =>
      Input$UserUpdateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (email != null) r'email': email,
        if (data != null) r'data': data,
        if (lastName != null) r'lastName': lastName,
        if (firstName != null) r'firstName': firstName,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (displayName != null) r'displayName': displayName,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (kratosId != null) r'kratosId': kratosId,
        if (supabaseUserId != null) r'supabaseUserId': supabaseUserId,
      });

  Input$UserUpdateInput._(this._$data);

  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = (l$avatarUrl as String?);
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] =
          l$updatedAt == null ? null : DateTime.parse((l$updatedAt as String));
    }
    if (data.containsKey('kratosId')) {
      final l$kratosId = data['kratosId'];
      result$data['kratosId'] = (l$kratosId as String?);
    }
    if (data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = data['supabaseUserId'];
      result$data['supabaseUserId'] = (l$supabaseUserId as String?);
    }
    return Input$UserUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get email => (_$data['email'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get firstName => (_$data['firstName'] as String?);

  String? get avatarUrl => (_$data['avatarUrl'] as String?);

  String? get displayName => (_$data['displayName'] as String?);

  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);

  String? get kratosId => (_$data['kratosId'] as String?);

  String? get supabaseUserId => (_$data['supabaseUserId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl;
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toIso8601String();
    }
    if (_$data.containsKey('kratosId')) {
      final l$kratosId = kratosId;
      result$data['kratosId'] = l$kratosId;
    }
    if (_$data.containsKey('supabaseUserId')) {
      final l$supabaseUserId = supabaseUserId;
      result$data['supabaseUserId'] = l$supabaseUserId;
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateInput<Input$UserUpdateInput> get copyWith =>
      CopyWith$Input$UserUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$kratosId = kratosId;
    final lOther$kratosId = other.kratosId;
    if (_$data.containsKey('kratosId') !=
        other._$data.containsKey('kratosId')) {
      return false;
    }
    if (l$kratosId != lOther$kratosId) {
      return false;
    }
    final l$supabaseUserId = supabaseUserId;
    final lOther$supabaseUserId = other.supabaseUserId;
    if (_$data.containsKey('supabaseUserId') !=
        other._$data.containsKey('supabaseUserId')) {
      return false;
    }
    if (l$supabaseUserId != lOther$supabaseUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$email = email;
    final l$data = data;
    final l$lastName = lastName;
    final l$firstName = firstName;
    final l$avatarUrl = avatarUrl;
    final l$displayName = displayName;
    final l$updatedAt = updatedAt;
    final l$kratosId = kratosId;
    final l$supabaseUserId = supabaseUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('kratosId') ? l$kratosId : const {},
      _$data.containsKey('supabaseUserId') ? l$supabaseUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateInput<TRes> {
  factory CopyWith$Input$UserUpdateInput(
    Input$UserUpdateInput instance,
    TRes Function(Input$UserUpdateInput) then,
  ) = _CopyWithImpl$Input$UserUpdateInput;

  factory CopyWith$Input$UserUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateInput;

  TRes call({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  });
}

class _CopyWithImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithImpl$Input$UserUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateInput _instance;

  final TRes Function(Input$UserUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? email = _undefined,
    Object? data = _undefined,
    Object? lastName = _undefined,
    Object? firstName = _undefined,
    Object? avatarUrl = _undefined,
    Object? displayName = _undefined,
    Object? updatedAt = _undefined,
    Object? kratosId = _undefined,
    Object? supabaseUserId = _undefined,
  }) =>
      _then(Input$UserUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (email != _undefined) 'email': (email as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as String?),
        if (displayName != _undefined) 'displayName': (displayName as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (kratosId != _undefined) 'kratosId': (kratosId as String?),
        if (supabaseUserId != _undefined)
          'supabaseUserId': (supabaseUserId as String?),
      }));
}

class _CopyWithStubImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    DateTime? createdAt,
    String? email,
    Map<String, dynamic>? data,
    String? lastName,
    String? firstName,
    String? avatarUrl,
    String? displayName,
    DateTime? updatedAt,
    String? kratosId,
    String? supabaseUserId,
  }) =>
      _res;
}

class Input$UUIDFilter {
  factory Input$UUIDFilter({
    String? eq,
    List<String>? $in,
    Enum$FilterIs? $is,
    String? neq,
  }) =>
      Input$UUIDFilter._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if ($is != null) r'is': $is,
        if (neq != null) r'neq': neq,
      });

  Input$UUIDFilter._(this._$data);

  factory Input$UUIDFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] =
          l$$is == null ? null : fromJson$Enum$FilterIs((l$$is as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    return Input$UUIDFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  Enum$FilterIs? get $is => (_$data['is'] as Enum$FilterIs?);

  String? get neq => (_$data['neq'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is == null ? null : toJson$Enum$FilterIs(l$$is);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$UUIDFilter<Input$UUIDFilter> get copyWith =>
      CopyWith$Input$UUIDFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UUIDFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$$is = $is;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$UUIDFilter<TRes> {
  factory CopyWith$Input$UUIDFilter(
    Input$UUIDFilter instance,
    TRes Function(Input$UUIDFilter) then,
  ) = _CopyWithImpl$Input$UUIDFilter;

  factory CopyWith$Input$UUIDFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UUIDFilter;

  TRes call({
    String? eq,
    List<String>? $in,
    Enum$FilterIs? $is,
    String? neq,
  });
}

class _CopyWithImpl$Input$UUIDFilter<TRes>
    implements CopyWith$Input$UUIDFilter<TRes> {
  _CopyWithImpl$Input$UUIDFilter(
    this._instance,
    this._then,
  );

  final Input$UUIDFilter _instance;

  final TRes Function(Input$UUIDFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? $is = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$UUIDFilter._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if ($is != _undefined) 'is': ($is as Enum$FilterIs?),
        if (neq != _undefined) 'neq': (neq as String?),
      }));
}

class _CopyWithStubImpl$Input$UUIDFilter<TRes>
    implements CopyWith$Input$UUIDFilter<TRes> {
  _CopyWithStubImpl$Input$UUIDFilter(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? $in,
    Enum$FilterIs? $is,
    String? neq,
  }) =>
      _res;
}

class Input$VectorDatabaseFilter {
  factory Input$VectorDatabaseFilter({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$VectorDatabaseFilter>? and,
    List<Input$VectorDatabaseFilter>? or,
    Input$VectorDatabaseFilter? not,
  }) =>
      Input$VectorDatabaseFilter._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
        if (nodeId != null) r'nodeId': nodeId,
        if (and != null) r'and': and,
        if (or != null) r'or': or,
        if (not != null) r'not': not,
      });

  Input$VectorDatabaseFilter._(this._$data);

  factory Input$VectorDatabaseFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$UUIDFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringFilter.fromJson((l$key as Map<String, dynamic>));
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = l$url == null
          ? null
          : Input$StringFilter.fromJson((l$url as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DatetimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : Input$StringFilter.fromJson((l$iconUrl as Map<String, dynamic>));
    }
    if (data.containsKey('nodeId')) {
      final l$nodeId = data['nodeId'];
      result$data['nodeId'] = l$nodeId == null
          ? null
          : Input$IDFilter.fromJson((l$nodeId as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$VectorDatabaseFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$VectorDatabaseFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$VectorDatabaseFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$VectorDatabaseFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UUIDFilter? get id => (_$data['id'] as Input$UUIDFilter?);

  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);

  Input$StringFilter? get key => (_$data['key'] as Input$StringFilter?);

  Input$StringFilter? get url => (_$data['url'] as Input$StringFilter?);

  Input$DatetimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DatetimeFilter?);

  Input$StringFilter? get iconUrl => (_$data['iconUrl'] as Input$StringFilter?);

  Input$IDFilter? get nodeId => (_$data['nodeId'] as Input$IDFilter?);

  List<Input$VectorDatabaseFilter>? get and =>
      (_$data['and'] as List<Input$VectorDatabaseFilter>?);

  List<Input$VectorDatabaseFilter>? get or =>
      (_$data['or'] as List<Input$VectorDatabaseFilter>?);

  Input$VectorDatabaseFilter? get not =>
      (_$data['not'] as Input$VectorDatabaseFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl?.toJson();
    }
    if (_$data.containsKey('nodeId')) {
      final l$nodeId = nodeId;
      result$data['nodeId'] = l$nodeId?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$VectorDatabaseFilter<Input$VectorDatabaseFilter>
      get copyWith => CopyWith$Input$VectorDatabaseFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VectorDatabaseFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    final l$nodeId = nodeId;
    final lOther$nodeId = other.nodeId;
    if (_$data.containsKey('nodeId') != other._$data.containsKey('nodeId')) {
      return false;
    }
    if (l$nodeId != lOther$nodeId) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    final l$nodeId = nodeId;
    final l$and = and;
    final l$or = or;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
      _$data.containsKey('nodeId') ? l$nodeId : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$VectorDatabaseFilter<TRes> {
  factory CopyWith$Input$VectorDatabaseFilter(
    Input$VectorDatabaseFilter instance,
    TRes Function(Input$VectorDatabaseFilter) then,
  ) = _CopyWithImpl$Input$VectorDatabaseFilter;

  factory CopyWith$Input$VectorDatabaseFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$VectorDatabaseFilter;

  TRes call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$VectorDatabaseFilter>? and,
    List<Input$VectorDatabaseFilter>? or,
    Input$VectorDatabaseFilter? not,
  });
  CopyWith$Input$UUIDFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get key;
  CopyWith$Input$StringFilter<TRes> get url;
  CopyWith$Input$DatetimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get iconUrl;
  CopyWith$Input$IDFilter<TRes> get nodeId;
  TRes and(
      Iterable<Input$VectorDatabaseFilter>? Function(
              Iterable<
                  CopyWith$Input$VectorDatabaseFilter<
                      Input$VectorDatabaseFilter>>?)
          _fn);
  TRes or(
      Iterable<Input$VectorDatabaseFilter>? Function(
              Iterable<
                  CopyWith$Input$VectorDatabaseFilter<
                      Input$VectorDatabaseFilter>>?)
          _fn);
  CopyWith$Input$VectorDatabaseFilter<TRes> get not;
}

class _CopyWithImpl$Input$VectorDatabaseFilter<TRes>
    implements CopyWith$Input$VectorDatabaseFilter<TRes> {
  _CopyWithImpl$Input$VectorDatabaseFilter(
    this._instance,
    this._then,
  );

  final Input$VectorDatabaseFilter _instance;

  final TRes Function(Input$VectorDatabaseFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
    Object? nodeId = _undefined,
    Object? and = _undefined,
    Object? or = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$VectorDatabaseFilter._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Input$UUIDFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (key != _undefined) 'key': (key as Input$StringFilter?),
        if (url != _undefined) 'url': (url as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DatetimeFilter?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as Input$StringFilter?),
        if (nodeId != _undefined) 'nodeId': (nodeId as Input$IDFilter?),
        if (and != _undefined)
          'and': (and as List<Input$VectorDatabaseFilter>?),
        if (or != _undefined) 'or': (or as List<Input$VectorDatabaseFilter>?),
        if (not != _undefined) 'not': (not as Input$VectorDatabaseFilter?),
      }));

  CopyWith$Input$UUIDFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$UUIDFilter.stub(_then(_instance))
        : CopyWith$Input$UUIDFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$key, (e) => call(key: e));
  }

  CopyWith$Input$StringFilter<TRes> get url {
    final local$url = _instance.url;
    return local$url == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$url, (e) => call(url: e));
  }

  CopyWith$Input$DatetimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DatetimeFilter.stub(_then(_instance))
        : CopyWith$Input$DatetimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get iconUrl {
    final local$iconUrl = _instance.iconUrl;
    return local$iconUrl == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$iconUrl, (e) => call(iconUrl: e));
  }

  CopyWith$Input$IDFilter<TRes> get nodeId {
    final local$nodeId = _instance.nodeId;
    return local$nodeId == null
        ? CopyWith$Input$IDFilter.stub(_then(_instance))
        : CopyWith$Input$IDFilter(local$nodeId, (e) => call(nodeId: e));
  }

  TRes and(
          Iterable<Input$VectorDatabaseFilter>? Function(
                  Iterable<
                      CopyWith$Input$VectorDatabaseFilter<
                          Input$VectorDatabaseFilter>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$VectorDatabaseFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes or(
          Iterable<Input$VectorDatabaseFilter>? Function(
                  Iterable<
                      CopyWith$Input$VectorDatabaseFilter<
                          Input$VectorDatabaseFilter>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$VectorDatabaseFilter(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$VectorDatabaseFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$VectorDatabaseFilter.stub(_then(_instance))
        : CopyWith$Input$VectorDatabaseFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$VectorDatabaseFilter<TRes>
    implements CopyWith$Input$VectorDatabaseFilter<TRes> {
  _CopyWithStubImpl$Input$VectorDatabaseFilter(this._res);

  TRes _res;

  call({
    Input$UUIDFilter? id,
    Input$StringFilter? name,
    Input$StringFilter? key,
    Input$StringFilter? url,
    Input$DatetimeFilter? createdAt,
    Input$StringFilter? iconUrl,
    Input$IDFilter? nodeId,
    List<Input$VectorDatabaseFilter>? and,
    List<Input$VectorDatabaseFilter>? or,
    Input$VectorDatabaseFilter? not,
  }) =>
      _res;

  CopyWith$Input$UUIDFilter<TRes> get id =>
      CopyWith$Input$UUIDFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get key =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get url =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DatetimeFilter<TRes> get createdAt =>
      CopyWith$Input$DatetimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get iconUrl =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$IDFilter<TRes> get nodeId =>
      CopyWith$Input$IDFilter.stub(_res);

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$VectorDatabaseFilter<TRes> get not =>
      CopyWith$Input$VectorDatabaseFilter.stub(_res);
}

class Input$VectorDatabaseInsertInput {
  factory Input$VectorDatabaseInsertInput({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$VectorDatabaseInsertInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (url != null) r'url': url,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$VectorDatabaseInsertInput._(this._$data);

  factory Input$VectorDatabaseInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$VectorDatabaseInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get url => (_$data['url'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$VectorDatabaseInsertInput<Input$VectorDatabaseInsertInput>
      get copyWith => CopyWith$Input$VectorDatabaseInsertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VectorDatabaseInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$url = url;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$VectorDatabaseInsertInput<TRes> {
  factory CopyWith$Input$VectorDatabaseInsertInput(
    Input$VectorDatabaseInsertInput instance,
    TRes Function(Input$VectorDatabaseInsertInput) then,
  ) = _CopyWithImpl$Input$VectorDatabaseInsertInput;

  factory CopyWith$Input$VectorDatabaseInsertInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VectorDatabaseInsertInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$VectorDatabaseInsertInput<TRes>
    implements CopyWith$Input$VectorDatabaseInsertInput<TRes> {
  _CopyWithImpl$Input$VectorDatabaseInsertInput(
    this._instance,
    this._then,
  );

  final Input$VectorDatabaseInsertInput _instance;

  final TRes Function(Input$VectorDatabaseInsertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? url = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$VectorDatabaseInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (url != _undefined) 'url': (url as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$VectorDatabaseInsertInput<TRes>
    implements CopyWith$Input$VectorDatabaseInsertInput<TRes> {
  _CopyWithStubImpl$Input$VectorDatabaseInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

class Input$VectorDatabaseOrderBy {
  factory Input$VectorDatabaseOrderBy({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      Input$VectorDatabaseOrderBy._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (url != null) r'url': url,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$VectorDatabaseOrderBy._(this._$data);

  factory Input$VectorDatabaseOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$OrderByDirection((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$OrderByDirection((l$name as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$OrderByDirection((l$key as String));
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = l$url == null
          ? null
          : fromJson$Enum$OrderByDirection((l$url as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$OrderByDirection((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = l$iconUrl == null
          ? null
          : fromJson$Enum$OrderByDirection((l$iconUrl as String));
    }
    return Input$VectorDatabaseOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderByDirection? get id => (_$data['id'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get name => (_$data['name'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get key => (_$data['key'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get url => (_$data['url'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get createdAt =>
      (_$data['createdAt'] as Enum$OrderByDirection?);

  Enum$OrderByDirection? get iconUrl =>
      (_$data['iconUrl'] as Enum$OrderByDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] =
          l$id == null ? null : toJson$Enum$OrderByDirection(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$OrderByDirection(l$name);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] =
          l$key == null ? null : toJson$Enum$OrderByDirection(l$key);
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] =
          l$url == null ? null : toJson$Enum$OrderByDirection(l$url);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$OrderByDirection(l$createdAt);
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] =
          l$iconUrl == null ? null : toJson$Enum$OrderByDirection(l$iconUrl);
    }
    return result$data;
  }

  CopyWith$Input$VectorDatabaseOrderBy<Input$VectorDatabaseOrderBy>
      get copyWith => CopyWith$Input$VectorDatabaseOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VectorDatabaseOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$url = url;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$VectorDatabaseOrderBy<TRes> {
  factory CopyWith$Input$VectorDatabaseOrderBy(
    Input$VectorDatabaseOrderBy instance,
    TRes Function(Input$VectorDatabaseOrderBy) then,
  ) = _CopyWithImpl$Input$VectorDatabaseOrderBy;

  factory CopyWith$Input$VectorDatabaseOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$VectorDatabaseOrderBy;

  TRes call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  });
}

class _CopyWithImpl$Input$VectorDatabaseOrderBy<TRes>
    implements CopyWith$Input$VectorDatabaseOrderBy<TRes> {
  _CopyWithImpl$Input$VectorDatabaseOrderBy(
    this._instance,
    this._then,
  );

  final Input$VectorDatabaseOrderBy _instance;

  final TRes Function(Input$VectorDatabaseOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? url = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$VectorDatabaseOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderByDirection?),
        if (name != _undefined) 'name': (name as Enum$OrderByDirection?),
        if (key != _undefined) 'key': (key as Enum$OrderByDirection?),
        if (url != _undefined) 'url': (url as Enum$OrderByDirection?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$OrderByDirection?),
        if (iconUrl != _undefined)
          'iconUrl': (iconUrl as Enum$OrderByDirection?),
      }));
}

class _CopyWithStubImpl$Input$VectorDatabaseOrderBy<TRes>
    implements CopyWith$Input$VectorDatabaseOrderBy<TRes> {
  _CopyWithStubImpl$Input$VectorDatabaseOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderByDirection? id,
    Enum$OrderByDirection? name,
    Enum$OrderByDirection? key,
    Enum$OrderByDirection? url,
    Enum$OrderByDirection? createdAt,
    Enum$OrderByDirection? iconUrl,
  }) =>
      _res;
}

class Input$VectorDatabaseUpdateInput {
  factory Input$VectorDatabaseUpdateInput({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      Input$VectorDatabaseUpdateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (key != null) r'key': key,
        if (url != null) r'url': url,
        if (data != null) r'data': data,
        if (createdAt != null) r'createdAt': createdAt,
        if (iconUrl != null) r'iconUrl': iconUrl,
      });

  Input$VectorDatabaseUpdateInput._(this._$data);

  factory Input$VectorDatabaseUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = (l$key as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = l$data == null ? null : jsonFieldFromJson(l$data);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] =
          l$createdAt == null ? null : DateTime.parse((l$createdAt as String));
    }
    if (data.containsKey('iconUrl')) {
      final l$iconUrl = data['iconUrl'];
      result$data['iconUrl'] = (l$iconUrl as String?);
    }
    return Input$VectorDatabaseUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get key => (_$data['key'] as String?);

  String? get url => (_$data['url'] as String?);

  Map<String, dynamic>? get data => (_$data['data'] as Map<String, dynamic>?);

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);

  String? get iconUrl => (_$data['iconUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data == null ? null : jsonFieldToJson(l$data);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toIso8601String();
    }
    if (_$data.containsKey('iconUrl')) {
      final l$iconUrl = iconUrl;
      result$data['iconUrl'] = l$iconUrl;
    }
    return result$data;
  }

  CopyWith$Input$VectorDatabaseUpdateInput<Input$VectorDatabaseUpdateInput>
      get copyWith => CopyWith$Input$VectorDatabaseUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VectorDatabaseUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$iconUrl = iconUrl;
    final lOther$iconUrl = other.iconUrl;
    if (_$data.containsKey('iconUrl') != other._$data.containsKey('iconUrl')) {
      return false;
    }
    if (l$iconUrl != lOther$iconUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$key = key;
    final l$url = url;
    final l$data = data;
    final l$createdAt = createdAt;
    final l$iconUrl = iconUrl;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('data') ? l$data : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('iconUrl') ? l$iconUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$VectorDatabaseUpdateInput<TRes> {
  factory CopyWith$Input$VectorDatabaseUpdateInput(
    Input$VectorDatabaseUpdateInput instance,
    TRes Function(Input$VectorDatabaseUpdateInput) then,
  ) = _CopyWithImpl$Input$VectorDatabaseUpdateInput;

  factory CopyWith$Input$VectorDatabaseUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VectorDatabaseUpdateInput;

  TRes call({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  });
}

class _CopyWithImpl$Input$VectorDatabaseUpdateInput<TRes>
    implements CopyWith$Input$VectorDatabaseUpdateInput<TRes> {
  _CopyWithImpl$Input$VectorDatabaseUpdateInput(
    this._instance,
    this._then,
  );

  final Input$VectorDatabaseUpdateInput _instance;

  final TRes Function(Input$VectorDatabaseUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? key = _undefined,
    Object? url = _undefined,
    Object? data = _undefined,
    Object? createdAt = _undefined,
    Object? iconUrl = _undefined,
  }) =>
      _then(Input$VectorDatabaseUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (key != _undefined) 'key': (key as String?),
        if (url != _undefined) 'url': (url as String?),
        if (data != _undefined) 'data': (data as Map<String, dynamic>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (iconUrl != _undefined) 'iconUrl': (iconUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$VectorDatabaseUpdateInput<TRes>
    implements CopyWith$Input$VectorDatabaseUpdateInput<TRes> {
  _CopyWithStubImpl$Input$VectorDatabaseUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? key,
    String? url,
    Map<String, dynamic>? data,
    DateTime? createdAt,
    String? iconUrl,
  }) =>
      _res;
}

enum Enum$FilterIs {
  NULL,
  NOT_NULL,
  $unknown;

  factory Enum$FilterIs.fromJson(String value) => fromJson$Enum$FilterIs(value);

  String toJson() => toJson$Enum$FilterIs(this);
}

String toJson$Enum$FilterIs(Enum$FilterIs e) {
  switch (e) {
    case Enum$FilterIs.NULL:
      return r'NULL';
    case Enum$FilterIs.NOT_NULL:
      return r'NOT_NULL';
    case Enum$FilterIs.$unknown:
      return r'$unknown';
  }
}

Enum$FilterIs fromJson$Enum$FilterIs(String value) {
  switch (value) {
    case r'NULL':
      return Enum$FilterIs.NULL;
    case r'NOT_NULL':
      return Enum$FilterIs.NOT_NULL;
    default:
      return Enum$FilterIs.$unknown;
  }
}

enum Enum$OrderByDirection {
  AscNullsFirst,
  AscNullsLast,
  DescNullsFirst,
  DescNullsLast,
  $unknown;

  factory Enum$OrderByDirection.fromJson(String value) =>
      fromJson$Enum$OrderByDirection(value);

  String toJson() => toJson$Enum$OrderByDirection(this);
}

String toJson$Enum$OrderByDirection(Enum$OrderByDirection e) {
  switch (e) {
    case Enum$OrderByDirection.AscNullsFirst:
      return r'AscNullsFirst';
    case Enum$OrderByDirection.AscNullsLast:
      return r'AscNullsLast';
    case Enum$OrderByDirection.DescNullsFirst:
      return r'DescNullsFirst';
    case Enum$OrderByDirection.DescNullsLast:
      return r'DescNullsLast';
    case Enum$OrderByDirection.$unknown:
      return r'$unknown';
  }
}

Enum$OrderByDirection fromJson$Enum$OrderByDirection(String value) {
  switch (value) {
    case r'AscNullsFirst':
      return Enum$OrderByDirection.AscNullsFirst;
    case r'AscNullsLast':
      return Enum$OrderByDirection.AscNullsLast;
    case r'DescNullsFirst':
      return Enum$OrderByDirection.DescNullsFirst;
    case r'DescNullsLast':
      return Enum$OrderByDirection.DescNullsLast;
    default:
      return Enum$OrderByDirection.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown;

  factory Enum$__TypeKind.fromJson(String value) =>
      fromJson$Enum$__TypeKind(value);

  String toJson() => toJson$Enum$__TypeKind(this);
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown;

  factory Enum$__DirectiveLocation.fromJson(String value) =>
      fromJson$Enum$__DirectiveLocation(value);

  String toJson() => toJson$Enum$__DirectiveLocation(this);
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{
  'Node': {
    'Agent',
    'AgentTool',
    'AiConfig',
    'AiConfigType',
    'AnswerChoice',
    'ApiType',
    'Application',
    'ApplicationAgent',
    'ApplicationTable',
    'ApplicationTool',
    'ApplicationType',
    'ApplicationUser',
    'ApplicationUserRole',
    'Asset',
    'AssetStatus',
    'AssetType',
    'AssetTypeMimeType',
    'ChatMessage',
    'ChatRole',
    'ChatSession',
    'Content',
    'ContentContentPart',
    'ContentPart',
    'ContentPartContentPart',
    'ContentTemplate',
    'ContentTemplateVariable',
    'ContentTemplateVariableValue',
    'ContentType',
    'CreationType',
    'Document',
    'DocumentTemplate',
    'DocumentType',
    'Feature',
    'Firehouse',
    'FirehousePartner',
    'Form',
    'FormQuestion',
    'HeroItem',
    'MimeType',
    'Notification',
    'NotificationType',
    'Onboarding',
    'OnboardingForm',
    'OnboardingStep',
    'OnboardingSurvey',
    'OnboardingType',
    'Partner',
    'PartnerType',
    'Persona',
    'PersonaOnboarding',
    'ProfileType',
    'Prompt',
    'PromptTemplate',
    'PromptTemplateVariable',
    'PublicationState',
    'Question',
    'QuestionAnwserChoice',
    'QuestionType',
    'Role',
    'Survey',
    'SurveyQuestion',
    'TemplateVariable',
    'TemplateVariableType',
    'Testimonial',
    'Tool',
    'ToolType',
    'User',
    'UserAnswerChoice',
    'UserForm',
    'UserFormQuestionAnswer',
    'UserOnboarding',
    'UserOnboardingStep',
    'UserPersona',
    'UserProfile',
    'UserRole',
    'UserSurvey',
    'UserSurveyAnswer',
    'VectorDatabase',
  }
};
